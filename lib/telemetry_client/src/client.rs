// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[doc(inline)]
pub use ::aws_smithy_client::Builder;
#[derive(Debug)]
pub(crate) struct Handle {
    pub(crate) conf: crate::Config,
    pub(crate) runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
}

///
/// An ergonomic client for the service.
///
/// This client allows ergonomic access to the service.
/// Each method corresponds to an API defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// Client for calling the service.
///
/// ## Client types and purposes
///
/// Clients generated by smithy-rs have two separate client layers:
///
/// 1. The Smithy [`Client`](::aws_smithy_client::Client): A _lower level client_ that is not tied
/// to the service and directly operates on operation structs. A Smithy client is composed of a
/// connector, middleware, and retry strategy.
/// 2. The "fluent" [`Client`]: A _higher level client_ that is convenient to use.
///
/// The vast majority of use-cases don't require using the Smithy client, so it is usually only relevant
/// for client construction. Because of this, this documentation will refer to the fluent client as simply
/// the "client". The Smithy client is only relevant when customizing the connector, middleware, or
/// retry strategy, or for even more advanced use cases.
///
/// ## Constructing a `Client`
///
/// A fluent [`Client`] is composed of a Smithy client and service configuration. In order to
/// construct one, a Smithy client must be created first, and this is done using
/// the [`client::Builder`](crate::client::Builder) struct:
///
/// ```rust,no_run
/// let smithy_client = telemetry_client::client::Builder::new()
///     // Use the default HTTPS connector
///     .dyn_https_connector(Default::default())
///     // Use a no-op middleware
///     .middleware_fn(|request| request)
///     // Build a type-erased Smithy client
///     .build_dyn();
/// ```
///
/// The client builder has generics `C`, `M`, and `R` representing the connector, middleware, and
/// retry strategy:
///
/// - A connector (`C`) specifies how HTTP requests are translated into HTTP responses. This will typically be
/// an HTTP client (like `hyper`), but you can also provide your own, like a mock connector for testing.
/// - Middleware (`M`) modifies requests prior to them being sent to the service. Most commonly, middleware decide
/// what endpoint the requests should be sent to, as well as perform authentication and authorization (such
/// as HTTP basic auth or AWS SigV4). You can also have middleware that performs request/response tracing,
/// throttling, or other middleware-like tasks.
/// - A retry strategy (`R`) dictates the behavior for requests that fail. The default,
/// [`RetryMode::Standard`](aws_smithy_types::retry::RetryMode::Standard) is generally what you want since
/// it provides a well-vetted exponential backoff retry implementation.
///
/// Once the Smithy client is created, a service config and fluent client can be created. Generally, you
/// want to call [`Client::with_config`], which takes a Smithy client and the service [`Config`](crate::Config).
/// The config is constructed using the [builder pattern], and has several builder methods to further
/// customize the client.
///
/// In _most_ circumstances, you will want to use the following pattern to construct a client:
///
/// ```rust,no_run
/// let smithy_client = telemetry_client::client::Builder::new()
///     .dyn_https_connector(Default::default())
/// #  /*
///     .middleware(/* discussed below */)
/// #  */
/// #  .middleware_fn(|r| r)
///     .build_dyn();
///
/// let config = telemetry_client::Config::builder().build();
/// let client = telemetry_client::Client::with_config(smithy_client, config);
/// ```
///
/// _Note:_ Client construction is expensive due to connection thread pool initialization, and should be done
/// once at application start-up.
///
/// For middleware, you'll want to use whatever matches the routing, authentication, and authorization
/// required by the target service. For example, for the AWS SDK which uses [SigV4-signed requests], the
/// middleware looks like this:
///
/// ```rust,ignore
/// use aws_endpoint::AwsEndpointStage;
/// use aws_http::auth::CredentialsStage;
/// use aws_http::recursion_detection::RecursionDetectionStage;
/// use aws_http::user_agent::UserAgentStage;
/// use aws_sig_auth::middleware::SigV4SigningStage;
/// use aws_sig_auth::signer::SigV4Signer;
/// use aws_smithy_client::retry::Config as RetryConfig;
/// use aws_smithy_http_tower::map_request::{AsyncMapRequestLayer, MapRequestLayer};
/// use std::fmt::Debug;
/// use tower::layer::util::{Identity, Stack};
/// use tower::ServiceBuilder;
///
/// type AwsMiddlewareStack = Stack<
///     MapRequestLayer<RecursionDetectionStage>,
///     Stack<
///         MapRequestLayer<SigV4SigningStage>,
///         Stack<
///             AsyncMapRequestLayer<CredentialsStage>,
///             Stack<
///                 MapRequestLayer<UserAgentStage>,
///                 Stack<MapRequestLayer<AwsEndpointStage>, Identity>,
///             >,
///         >,
///     >,
/// >;
///
/// /// AWS Middleware Stack
/// ///
/// /// This implements the middleware stack for this service. It will:
/// /// 1. Load credentials asynchronously into the property bag
/// /// 2. Sign the request with SigV4
/// /// 3. Resolve an Endpoint for the request
/// /// 4. Add a user agent to the request
/// #[derive(Debug, Default, Clone)]
/// #[non_exhaustive]
/// pub struct AwsMiddleware;
///
/// impl AwsMiddleware {
///     /// Create a new `AwsMiddleware` stack
///     ///
///     /// Note: `AwsMiddleware` holds no state.
///     pub fn new() -> Self {
///         AwsMiddleware::default()
///     }
/// }
///
/// // define the middleware stack in a non-generic location to reduce code bloat.
/// fn base() -> ServiceBuilder<AwsMiddlewareStack> {
///     let credential_provider = AsyncMapRequestLayer::for_mapper(CredentialsStage::new());
///     let signer = MapRequestLayer::for_mapper(SigV4SigningStage::new(SigV4Signer::new()));
///     let endpoint_resolver = MapRequestLayer::for_mapper(AwsEndpointStage);
///     let user_agent = MapRequestLayer::for_mapper(UserAgentStage::new());
///     let recursion_detection = MapRequestLayer::for_mapper(RecursionDetectionStage::new());
///     // These layers can be considered as occurring in order, that is:
///     // 1. Resolve an endpoint
///     // 2. Add a user agent
///     // 3. Acquire credentials
///     // 4. Sign with credentials
///     // (5. Dispatch over the wire)
///     ServiceBuilder::new()
///         .layer(endpoint_resolver)
///         .layer(user_agent)
///         .layer(credential_provider)
///         .layer(signer)
///         .layer(recursion_detection)
/// }
///
/// impl<S> tower::Layer<S> for AwsMiddleware {
///     type Service = <AwsMiddlewareStack as tower::Layer<S>>::Service;
///
///     fn layer(&self, inner: S) -> Self::Service {
///         base().service(inner)
///     }
/// }
/// ```
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#builders-enable-construction-of-complex-values-c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html""",
/// # Using the `Client`
///
/// A client has a function for every operation that can be performed by the service.
/// For example, the [`PostErrorReport`](crate::operation::post_error_report) operation has
/// a [`Client::post_error_report`], function which returns a builder for that operation.
/// The fluent builder ultimately has a `send()` function that returns an async future that
/// returns a result, as illustrated below:
///
/// ```rust,ignore
/// let result = client.post_error_report()
///     .aws_product("example")
///     .send()
///     .await;
/// ```
///
/// The underlying HTTP requests that get made by this can be modified with the `customize_operation`
/// function on the fluent builder. See the [`customize`](crate::client::customize) module for more
/// information.
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct Client {
    handle: ::std::sync::Arc<Handle>,
}

impl Client {
    /// Creates a new client from the service [`Config`](crate::Config).
    ///
    /// # Panics
    ///
    /// This method will panic if the `conf` has retry or timeouts enabled without a `sleep_impl`.
    /// If you experience this panic, it can be fixed by setting the `sleep_impl`, or by disabling
    /// retries and timeouts.
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf
            .retry_config()
            .cloned()
            .unwrap_or_else(::aws_smithy_types::retry::RetryConfig::disabled);
        let timeout_config = conf
            .timeout_config()
            .cloned()
            .unwrap_or_else(::aws_smithy_types::timeout::TimeoutConfig::disabled);
        let sleep_impl = conf.sleep_impl();
        if (retry_config.has_retry() || timeout_config.has_timeouts()) && sleep_impl.is_none() {
            panic!(
                "An async sleep implementation is required for retries or timeouts to work. \
                                        Set the `sleep_impl` on the Config passed into this function to fix this panic."
            );
        }

        Self {
            handle: ::std::sync::Arc::new(Handle {
                conf: conf.clone(),
                runtime_plugins: crate::config::base_client_runtime_plugins(conf),
            }),
        }
    }

    /// Returns the client's configuration.
    pub fn config(&self) -> &crate::Config {
        &self.handle.conf
    }

    #[doc(hidden)]
    // TODO(enableNewSmithyRuntimeCleanup): Delete this function when cleaning up middleware
    // This is currently kept around so the tests still compile in both modes
    /// Creates a client with the given service configuration.
    pub fn with_config<C, M, R>(_client: ::aws_smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self::from_conf(conf)
    }

    #[doc(hidden)]
    // TODO(enableNewSmithyRuntimeCleanup): Delete this function when cleaning up middleware
    // This is currently kept around so the tests still compile in both modes
    /// Returns the client's configuration.
    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}

/// Operation customization and supporting types.
///
/// The underlying HTTP requests made during an operation can be customized
/// by calling the `customize()` method on the builder returned from a client
/// operation call. For example, this can be used to add an additional HTTP header:
///
/// ```ignore
/// # async fn wrapper() -> ::std::result::Result<(), telemetry_client::Error> {
/// # let client: telemetry_client::Client = unimplemented!();
/// use ::http::header::{HeaderName, HeaderValue};
///
/// let result = client.post_error_report()
///     .customize()
///     .await?
///     .mutate_request(|req| {
///         // Add `x-example-header` with value
///         req.headers_mut()
///             .insert(
///                 HeaderName::from_static("x-example-header"),
///                 HeaderValue::from_static("1"),
///             );
///     })
///     .send()
///     .await;
/// # }
/// ```
pub mod customize;

mod post_error_report;

mod post_feedback;

mod post_metrics;
