// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: local.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// == Commands ==
public enum Local_IntegrationAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case install // = 0
  case verifyInstall // = 1
  case uninstall // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .install
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .install
    case 1: self = .verifyInstall
    case 2: self = .uninstall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .install: return 0
    case .verifyInstall: return 1
    case .uninstall: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Local_IntegrationAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Local_IntegrationAction] = [
    .install,
    .verifyInstall,
    .uninstall,
  ]
}

#endif  // swift(>=4.2)

public struct Local_LocalMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Local_LocalMessage.OneOf_Type? = nil

  /// expect a response from the host app
  public var command: Local_Command {
    get {
      if case .command(let v)? = type {return v}
      return Local_Command()
    }
    set {type = .command(newValue)}
  }

  /// one way update only, no response expected
  public var hook: Local_Hook {
    get {
      if case .hook(let v)? = type {return v}
      return Local_Hook()
    }
    set {type = .hook(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    /// expect a response from the host app
    case command(Local_Command)
    /// one way update only, no response expected
    case hook(Local_Hook)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_LocalMessage.OneOf_Type, rhs: Local_LocalMessage.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.command, .command): return {
        guard case .command(let l) = lhs, case .command(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hook, .hook): return {
        guard case .hook(let l) = lhs, case .hook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Local_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// opt-out of response from host app
  public var noResponse: Bool {
    get {return _noResponse ?? false}
    set {_noResponse = newValue}
  }
  /// Returns true if `noResponse` has been explicitly set.
  public var hasNoResponse: Bool {return self._noResponse != nil}
  /// Clears the value of `noResponse`. Subsequent reads from it will return its default value.
  public mutating func clearNoResponse() {self._noResponse = nil}

  public var command: Local_Command.OneOf_Command? = nil

  public var terminalIntegration: Local_TerminalIntegrationCommand {
    get {
      if case .terminalIntegration(let v)? = command {return v}
      return Local_TerminalIntegrationCommand()
    }
    set {command = .terminalIntegration(newValue)}
  }

  public var listTerminalIntegrations: Local_ListTerminalIntegrationsCommand {
    get {
      if case .listTerminalIntegrations(let v)? = command {return v}
      return Local_ListTerminalIntegrationsCommand()
    }
    set {command = .listTerminalIntegrations(newValue)}
  }

  public var logout: Local_LogoutCommand {
    get {
      if case .logout(let v)? = command {return v}
      return Local_LogoutCommand()
    }
    set {command = .logout(newValue)}
  }

  public var restart: Local_RestartCommand {
    get {
      if case .restart(let v)? = command {return v}
      return Local_RestartCommand()
    }
    set {command = .restart(newValue)}
  }

  public var quit: Local_QuitCommand {
    get {
      if case .quit(let v)? = command {return v}
      return Local_QuitCommand()
    }
    set {command = .quit(newValue)}
  }

  public var update: Local_UpdateCommand {
    get {
      if case .update(let v)? = command {return v}
      return Local_UpdateCommand()
    }
    set {command = .update(newValue)}
  }

  public var diagnostics: Local_DiagnosticsCommand {
    get {
      if case .diagnostics(let v)? = command {return v}
      return Local_DiagnosticsCommand()
    }
    set {command = .diagnostics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Command: Equatable {
    case terminalIntegration(Local_TerminalIntegrationCommand)
    case listTerminalIntegrations(Local_ListTerminalIntegrationsCommand)
    case logout(Local_LogoutCommand)
    case restart(Local_RestartCommand)
    case quit(Local_QuitCommand)
    case update(Local_UpdateCommand)
    case diagnostics(Local_DiagnosticsCommand)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_Command.OneOf_Command, rhs: Local_Command.OneOf_Command) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.terminalIntegration, .terminalIntegration): return {
        guard case .terminalIntegration(let l) = lhs, case .terminalIntegration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listTerminalIntegrations, .listTerminalIntegrations): return {
        guard case .listTerminalIntegrations(let l) = lhs, case .listTerminalIntegrations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logout, .logout): return {
        guard case .logout(let l) = lhs, case .logout(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restart, .restart): return {
        guard case .restart(let l) = lhs, case .restart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.quit, .quit): return {
        guard case .quit(let l) = lhs, case .quit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diagnostics, .diagnostics): return {
        guard case .diagnostics(let l) = lhs, case .diagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _noResponse: Bool? = nil
}

public struct Local_Hook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hook: Local_Hook.OneOf_Hook? = nil

  public var editbuffer: Local_EditBufferHook {
    get {
      if case .editbuffer(let v)? = hook {return v}
      return Local_EditBufferHook()
    }
    set {hook = .editbuffer(newValue)}
  }

  public var prompt: Local_PromptHook {
    get {
      if case .prompt(let v)? = hook {return v}
      return Local_PromptHook()
    }
    set {hook = .prompt(newValue)}
  }

  public var preexec: Local_PreExecHook {
    get {
      if case .preexec(let v)? = hook {return v}
      return Local_PreExecHook()
    }
    set {hook = .preexec(newValue)}
  }

  public var postexec: Local_PostExecHook {
    get {
      if case .postexec(let v)? = hook {return v}
      return Local_PostExecHook()
    }
    set {hook = .postexec(newValue)}
  }

  public var keyboardfocuschanged: Local_KeyboardFocusChangedHook {
    get {
      if case .keyboardfocuschanged(let v)? = hook {return v}
      return Local_KeyboardFocusChangedHook()
    }
    set {hook = .keyboardfocuschanged(newValue)}
  }

  public var tmuxpanechanged: Local_TmuxPaneChangedHook {
    get {
      if case .tmuxpanechanged(let v)? = hook {return v}
      return Local_TmuxPaneChangedHook()
    }
    set {hook = .tmuxpanechanged(newValue)}
  }

  public var openedsshconnection: Local_OpenedSSHConnectionHook {
    get {
      if case .openedsshconnection(let v)? = hook {return v}
      return Local_OpenedSSHConnectionHook()
    }
    set {hook = .openedsshconnection(newValue)}
  }

  public var callback: Local_CallbackHook {
    get {
      if case .callback(let v)? = hook {return v}
      return Local_CallbackHook()
    }
    set {hook = .callback(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Hook: Equatable {
    case editbuffer(Local_EditBufferHook)
    case prompt(Local_PromptHook)
    case preexec(Local_PreExecHook)
    case postexec(Local_PostExecHook)
    case keyboardfocuschanged(Local_KeyboardFocusChangedHook)
    case tmuxpanechanged(Local_TmuxPaneChangedHook)
    case openedsshconnection(Local_OpenedSSHConnectionHook)
    case callback(Local_CallbackHook)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_Hook.OneOf_Hook, rhs: Local_Hook.OneOf_Hook) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.editbuffer, .editbuffer): return {
        guard case .editbuffer(let l) = lhs, case .editbuffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prompt, .prompt): return {
        guard case .prompt(let l) = lhs, case .prompt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preexec, .preexec): return {
        guard case .preexec(let l) = lhs, case .preexec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postexec, .postexec): return {
        guard case .postexec(let l) = lhs, case .postexec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyboardfocuschanged, .keyboardfocuschanged): return {
        guard case .keyboardfocuschanged(let l) = lhs, case .keyboardfocuschanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tmuxpanechanged, .tmuxpanechanged): return {
        guard case .tmuxpanechanged(let l) = lhs, case .tmuxpanechanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openedsshconnection, .openedsshconnection): return {
        guard case .openedsshconnection(let l) = lhs, case .openedsshconnection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callback, .callback): return {
        guard case .callback(let l) = lhs, case .callback(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Local_TerminalIntegrationCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var action: Local_IntegrationAction = .install

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_ListTerminalIntegrationsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_LogoutCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_RestartCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_QuitCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_UpdateCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_DiagnosticsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// == Hooks ==
public struct Local_ShellContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pid: Int32 = 0

  /// /dev/ttys## of terminal session
  public var ttys: String = String()

  /// the name of the shell
  public var shell: String = String()

  /// the directory where the user ran the command
  public var currentWorkingDirectory: String = String()

  /// the value of $TERM_SESSION_ID 
  public var sessionID: String = String()

  public var integrationVersion: String {
    get {return _integrationVersion ?? String()}
    set {_integrationVersion = newValue}
  }
  /// Returns true if `integrationVersion` has been explicitly set.
  public var hasIntegrationVersion: Bool {return self._integrationVersion != nil}
  /// Clears the value of `integrationVersion`. Subsequent reads from it will return its default value.
  public mutating func clearIntegrationVersion() {self._integrationVersion = nil}

  public var terminal: String {
    get {return _terminal ?? String()}
    set {_terminal = newValue}
  }
  /// Returns true if `terminal` has been explicitly set.
  public var hasTerminal: Bool {return self._terminal != nil}
  /// Clears the value of `terminal`. Subsequent reads from it will return its default value.
  public mutating func clearTerminal() {self._terminal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _integrationVersion: String? = nil
  fileprivate var _terminal: String? = nil
}

public struct Local_EditBufferHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var text: String = String()

  public var cursor: Int64 = 0

  ///string integration_version = 3;
  ///string shell = 3;
  ///string sessionId = 4;
  public var histno: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_PromptHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_PreExecHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// the full command that was run in the shell
  public var command: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_PostExecHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// the full command that was run in the shell
  public var command: String = String()

  /// the exit code of the command
  public var exitCode: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_KeyboardFocusChangedHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bundleIdentifier: String = String()

  /// a unique identifier associated with the pane or tab that is currently focused
  public var focusedSession: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_TmuxPaneChangedHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paneIdentifier: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_OpenedSSHConnectionHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var controlPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_CallbackHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handlerID: String = String()

  public var filepath: String = String()

  public var exitCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// == Responses ==
public struct Local_ErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exitCode: Int32? = nil
  fileprivate var _message: String? = nil
}

public struct Local_SuccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: String? = nil
}

public struct Local_TerminalIntegration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bundleIdentifier: String = String()

  public var name: String = String()

  public var status: String {
    get {return _status ?? String()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: String? = nil
}

public struct Local_TerminalIntegrationsListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var integrations: [Local_TerminalIntegration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_DiagnosticsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pathToBundle: String = String()

  public var accessibility: String = String()

  public var keypath: String = String()

  public var docker: String = String()

  public var symlinked: String = String()

  public var onlytab: String = String()

  public var installscript: String = String()

  public var psudopath: String = String()

  public var securekeyboard: String = String()

  public var securekeyboardPath: String = String()

  public var currentProcess: String = String()

  public var currentWindowIdentifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_CommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var response: Local_CommandResponse.OneOf_Response? = nil

  public var error: Local_ErrorResponse {
    get {
      if case .error(let v)? = response {return v}
      return Local_ErrorResponse()
    }
    set {response = .error(newValue)}
  }

  public var success: Local_SuccessResponse {
    get {
      if case .success(let v)? = response {return v}
      return Local_SuccessResponse()
    }
    set {response = .success(newValue)}
  }

  /// ... add structured responses for specific commands, as necessary
  public var integrationList: Local_TerminalIntegrationsListResponse {
    get {
      if case .integrationList(let v)? = response {return v}
      return Local_TerminalIntegrationsListResponse()
    }
    set {response = .integrationList(newValue)}
  }

  public var diagnostics: Local_DiagnosticsResponse {
    get {
      if case .diagnostics(let v)? = response {return v}
      return Local_DiagnosticsResponse()
    }
    set {response = .diagnostics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case error(Local_ErrorResponse)
    case success(Local_SuccessResponse)
    /// ... add structured responses for specific commands, as necessary
    case integrationList(Local_TerminalIntegrationsListResponse)
    case diagnostics(Local_DiagnosticsResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_CommandResponse.OneOf_Response, rhs: Local_CommandResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integrationList, .integrationList): return {
        guard case .integrationList(let l) = lhs, case .integrationList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diagnostics, .diagnostics): return {
        guard case .diagnostics(let l) = lhs, case .diagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "local"

extension Local_IntegrationAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTALL"),
    1: .same(proto: "VERIFY_INSTALL"),
    2: .same(proto: "UNINSTALL"),
  ]
}

extension Local_LocalMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "command"),
    3: .same(proto: "hook"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Local_Command?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .command(v)
        }
      }()
      case 3: try {
        var v: Local_Hook?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .hook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .hook(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .command?: try {
      guard case .command(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hook?: try {
      guard case .hook(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_LocalMessage, rhs: Local_LocalMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "no_response"),
    100: .standard(proto: "terminal_integration"),
    101: .standard(proto: "list_terminal_integrations"),
    102: .same(proto: "logout"),
    103: .same(proto: "restart"),
    104: .same(proto: "quit"),
    105: .same(proto: "update"),
    106: .same(proto: "diagnostics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._noResponse) }()
      case 100: try {
        var v: Local_TerminalIntegrationCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .terminalIntegration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .terminalIntegration(v)
        }
      }()
      case 101: try {
        var v: Local_ListTerminalIntegrationsCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .listTerminalIntegrations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .listTerminalIntegrations(v)
        }
      }()
      case 102: try {
        var v: Local_LogoutCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .logout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .logout(v)
        }
      }()
      case 103: try {
        var v: Local_RestartCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .restart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .restart(v)
        }
      }()
      case 104: try {
        var v: Local_QuitCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .quit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .quit(v)
        }
      }()
      case 105: try {
        var v: Local_UpdateCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .update(v)
        }
      }()
      case 106: try {
        var v: Local_DiagnosticsCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .diagnostics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .diagnostics(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._noResponse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    switch self.command {
    case .terminalIntegration?: try {
      guard case .terminalIntegration(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .listTerminalIntegrations?: try {
      guard case .listTerminalIntegrations(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .logout?: try {
      guard case .logout(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .restart?: try {
      guard case .restart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .quit?: try {
      guard case .quit(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .update?: try {
      guard case .update(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .diagnostics?: try {
      guard case .diagnostics(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Command, rhs: Local_Command) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._noResponse != rhs._noResponse {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Hook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .same(proto: "editbuffer"),
    101: .same(proto: "prompt"),
    102: .same(proto: "preexec"),
    103: .same(proto: "postexec"),
    104: .same(proto: "keyboardfocuschanged"),
    105: .same(proto: "tmuxpanechanged"),
    106: .same(proto: "openedsshconnection"),
    107: .same(proto: "callback"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 100: try {
        var v: Local_EditBufferHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .editbuffer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .editbuffer(v)
        }
      }()
      case 101: try {
        var v: Local_PromptHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .prompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .prompt(v)
        }
      }()
      case 102: try {
        var v: Local_PreExecHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .preexec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .preexec(v)
        }
      }()
      case 103: try {
        var v: Local_PostExecHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .postexec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .postexec(v)
        }
      }()
      case 104: try {
        var v: Local_KeyboardFocusChangedHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .keyboardfocuschanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .keyboardfocuschanged(v)
        }
      }()
      case 105: try {
        var v: Local_TmuxPaneChangedHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .tmuxpanechanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .tmuxpanechanged(v)
        }
      }()
      case 106: try {
        var v: Local_OpenedSSHConnectionHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .openedsshconnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .openedsshconnection(v)
        }
      }()
      case 107: try {
        var v: Local_CallbackHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .callback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .callback(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.hook {
    case .editbuffer?: try {
      guard case .editbuffer(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .prompt?: try {
      guard case .prompt(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .preexec?: try {
      guard case .preexec(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .postexec?: try {
      guard case .postexec(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .keyboardfocuschanged?: try {
      guard case .keyboardfocuschanged(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .tmuxpanechanged?: try {
      guard case .tmuxpanechanged(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .openedsshconnection?: try {
      guard case .openedsshconnection(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .callback?: try {
      guard case .callback(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Hook, rhs: Local_Hook) -> Bool {
    if lhs.hook != rhs.hook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegrationCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegrationCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if self.action != .install {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegrationCommand, rhs: Local_TerminalIntegrationCommand) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ListTerminalIntegrationsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTerminalIntegrationsCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ListTerminalIntegrationsCommand, rhs: Local_ListTerminalIntegrationsCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_LogoutCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_LogoutCommand, rhs: Local_LogoutCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_RestartCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestartCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_RestartCommand, rhs: Local_RestartCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_QuitCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuitCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_QuitCommand, rhs: Local_QuitCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_UpdateCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_UpdateCommand, rhs: Local_UpdateCommand) -> Bool {
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_DiagnosticsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiagnosticsCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_DiagnosticsCommand, rhs: Local_DiagnosticsCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ShellContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShellContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "ttys"),
    3: .same(proto: "shell"),
    4: .same(proto: "currentWorkingDirectory"),
    5: .same(proto: "sessionId"),
    6: .standard(proto: "integration_version"),
    7: .same(proto: "terminal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ttys) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shell) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currentWorkingDirectory) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._integrationVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._terminal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 1)
    }
    if !self.ttys.isEmpty {
      try visitor.visitSingularStringField(value: self.ttys, fieldNumber: 2)
    }
    if !self.shell.isEmpty {
      try visitor.visitSingularStringField(value: self.shell, fieldNumber: 3)
    }
    if !self.currentWorkingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.currentWorkingDirectory, fieldNumber: 4)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 5)
    }
    try { if let v = self._integrationVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._terminal {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ShellContext, rhs: Local_ShellContext) -> Bool {
    if lhs.pid != rhs.pid {return false}
    if lhs.ttys != rhs.ttys {return false}
    if lhs.shell != rhs.shell {return false}
    if lhs.currentWorkingDirectory != rhs.currentWorkingDirectory {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs._integrationVersion != rhs._integrationVersion {return false}
    if lhs._terminal != rhs._terminal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_EditBufferHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditBufferHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "text"),
    3: .same(proto: "cursor"),
    4: .same(proto: "histno"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.cursor) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.histno) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.cursor != 0 {
      try visitor.visitSingularInt64Field(value: self.cursor, fieldNumber: 3)
    }
    if self.histno != 0 {
      try visitor.visitSingularInt64Field(value: self.histno, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_EditBufferHook, rhs: Local_EditBufferHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.text != rhs.text {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.histno != rhs.histno {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PromptHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PromptHook, rhs: Local_PromptHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PreExecHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreExecHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PreExecHook, rhs: Local_PreExecHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PostExecHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostExecHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "command"),
    3: .standard(proto: "exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PostExecHook, rhs: Local_PostExecHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.command != rhs.command {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_KeyboardFocusChangedHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyboardFocusChangedHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_identifier"),
    2: .standard(proto: "focused_session"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.focusedSession) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleIdentifier, fieldNumber: 1)
    }
    if !self.focusedSession.isEmpty {
      try visitor.visitSingularStringField(value: self.focusedSession, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_KeyboardFocusChangedHook, rhs: Local_KeyboardFocusChangedHook) -> Bool {
    if lhs.bundleIdentifier != rhs.bundleIdentifier {return false}
    if lhs.focusedSession != rhs.focusedSession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TmuxPaneChangedHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TmuxPaneChangedHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pane_identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.paneIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.paneIdentifier != 0 {
      try visitor.visitSingularInt32Field(value: self.paneIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TmuxPaneChangedHook, rhs: Local_TmuxPaneChangedHook) -> Bool {
    if lhs.paneIdentifier != rhs.paneIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_OpenedSSHConnectionHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenedSSHConnectionHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .standard(proto: "control_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.controlPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.controlPath.isEmpty {
      try visitor.visitSingularStringField(value: self.controlPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_OpenedSSHConnectionHook, rhs: Local_OpenedSSHConnectionHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.controlPath != rhs.controlPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_CallbackHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallbackHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "handler_id"),
    2: .same(proto: "filepath"),
    3: .standard(proto: "exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.handlerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filepath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.handlerID.isEmpty {
      try visitor.visitSingularStringField(value: self.handlerID, fieldNumber: 1)
    }
    if !self.filepath.isEmpty {
      try visitor.visitSingularStringField(value: self.filepath, fieldNumber: 2)
    }
    if !self.exitCode.isEmpty {
      try visitor.visitSingularStringField(value: self.exitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_CallbackHook, rhs: Local_CallbackHook) -> Bool {
    if lhs.handlerID != rhs.handlerID {return false}
    if lhs.filepath != rhs.filepath {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exit_code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ErrorResponse, rhs: Local_ErrorResponse) -> Bool {
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_SuccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuccessResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_SuccessResponse, rhs: Local_SuccessResponse) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_identifier"),
    2: .same(proto: "name"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bundleIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleIdentifier, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._status {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegration, rhs: Local_TerminalIntegration) -> Bool {
    if lhs.bundleIdentifier != rhs.bundleIdentifier {return false}
    if lhs.name != rhs.name {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegrationsListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegrationsListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "integrations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.integrations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.integrations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.integrations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegrationsListResponse, rhs: Local_TerminalIntegrationsListResponse) -> Bool {
    if lhs.integrations != rhs.integrations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_DiagnosticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiagnosticsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_to_bundle"),
    2: .same(proto: "accessibility"),
    3: .same(proto: "keypath"),
    4: .same(proto: "docker"),
    5: .same(proto: "symlinked"),
    6: .same(proto: "onlytab"),
    7: .same(proto: "installscript"),
    8: .same(proto: "psudopath"),
    9: .same(proto: "securekeyboard"),
    10: .standard(proto: "securekeyboard_path"),
    11: .standard(proto: "current_process"),
    12: .standard(proto: "current_window_identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pathToBundle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessibility) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keypath) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.docker) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.symlinked) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.onlytab) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.installscript) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.psudopath) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.securekeyboard) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.securekeyboardPath) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.currentProcess) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.currentWindowIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathToBundle.isEmpty {
      try visitor.visitSingularStringField(value: self.pathToBundle, fieldNumber: 1)
    }
    if !self.accessibility.isEmpty {
      try visitor.visitSingularStringField(value: self.accessibility, fieldNumber: 2)
    }
    if !self.keypath.isEmpty {
      try visitor.visitSingularStringField(value: self.keypath, fieldNumber: 3)
    }
    if !self.docker.isEmpty {
      try visitor.visitSingularStringField(value: self.docker, fieldNumber: 4)
    }
    if !self.symlinked.isEmpty {
      try visitor.visitSingularStringField(value: self.symlinked, fieldNumber: 5)
    }
    if !self.onlytab.isEmpty {
      try visitor.visitSingularStringField(value: self.onlytab, fieldNumber: 6)
    }
    if !self.installscript.isEmpty {
      try visitor.visitSingularStringField(value: self.installscript, fieldNumber: 7)
    }
    if !self.psudopath.isEmpty {
      try visitor.visitSingularStringField(value: self.psudopath, fieldNumber: 8)
    }
    if !self.securekeyboard.isEmpty {
      try visitor.visitSingularStringField(value: self.securekeyboard, fieldNumber: 9)
    }
    if !self.securekeyboardPath.isEmpty {
      try visitor.visitSingularStringField(value: self.securekeyboardPath, fieldNumber: 10)
    }
    if !self.currentProcess.isEmpty {
      try visitor.visitSingularStringField(value: self.currentProcess, fieldNumber: 11)
    }
    if !self.currentWindowIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.currentWindowIdentifier, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_DiagnosticsResponse, rhs: Local_DiagnosticsResponse) -> Bool {
    if lhs.pathToBundle != rhs.pathToBundle {return false}
    if lhs.accessibility != rhs.accessibility {return false}
    if lhs.keypath != rhs.keypath {return false}
    if lhs.docker != rhs.docker {return false}
    if lhs.symlinked != rhs.symlinked {return false}
    if lhs.onlytab != rhs.onlytab {return false}
    if lhs.installscript != rhs.installscript {return false}
    if lhs.psudopath != rhs.psudopath {return false}
    if lhs.securekeyboard != rhs.securekeyboard {return false}
    if lhs.securekeyboardPath != rhs.securekeyboardPath {return false}
    if lhs.currentProcess != rhs.currentProcess {return false}
    if lhs.currentWindowIdentifier != rhs.currentWindowIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_CommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
    100: .standard(proto: "integration_list"),
    101: .same(proto: "diagnostics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try {
        var v: Local_ErrorResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 3: try {
        var v: Local_SuccessResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 100: try {
        var v: Local_TerminalIntegrationsListResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .integrationList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .integrationList(v)
        }
      }()
      case 101: try {
        var v: Local_DiagnosticsResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .diagnostics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .diagnostics(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .integrationList?: try {
      guard case .integrationList(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .diagnostics?: try {
      guard case .diagnostics(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_CommandResponse, rhs: Local_CommandResponse) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
