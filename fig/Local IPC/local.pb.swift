// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: local.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// == Commands ==
public enum Local_IntegrationAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case install // = 0
  case verifyInstall // = 1
  case uninstall // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .install
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .install
    case 1: self = .verifyInstall
    case 2: self = .uninstall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .install: return 0
    case .verifyInstall: return 1
    case .uninstall: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Local_IntegrationAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Local_IntegrationAction] = [
    .install,
    .verifyInstall,
    .uninstall
  ]
}

#endif  // swift(>=4.2)

public enum Local_UiElement: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case menuBar // = 0
  case settings // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .menuBar
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .menuBar
    case 1: self = .settings
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .menuBar: return 0
    case .settings: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Local_UiElement: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Local_UiElement] = [
    .menuBar,
    .settings
  ]
}

#endif  // swift(>=4.2)

public struct Local_LocalMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Local_LocalMessage.OneOf_Type?

  /// expect a response from the host app
  public var command: Local_Command {
    get {
      if case .command(let v)? = type {return v}
      return Local_Command()
    }
    set {type = .command(newValue)}
  }

  /// one way update only, no response expected
  public var hook: Local_Hook {
    get {
      if case .hook(let v)? = type {return v}
      return Local_Hook()
    }
    set {type = .hook(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    /// expect a response from the host app
    case command(Local_Command)
    /// one way update only, no response expected
    case hook(Local_Hook)

    #if !swift(>=4.1)
    public static func ==(lhs: Local_LocalMessage.OneOf_Type, rhs: Local_LocalMessage.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.command, .command): return {
        guard case .command(let l) = lhs, case .command(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hook, .hook): return {
        guard case .hook(let l) = lhs, case .hook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
    #endif
  }

  public init() {}
}

public struct Local_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// opt-out of response from host app
  public var noResponse: Bool {
    get {return _noResponse ?? false}
    set {_noResponse = newValue}
  }
  /// Returns true if `noResponse` has been explicitly set.
  public var hasNoResponse: Bool {return self._noResponse != nil}
  /// Clears the value of `noResponse`. Subsequent reads from it will return its default value.
  public mutating func clearNoResponse() {self._noResponse = nil}

  public var command: Local_Command.OneOf_Command?

  public var terminalIntegration: Local_TerminalIntegrationCommand {
    get {
      if case .terminalIntegration(let v)? = command {return v}
      return Local_TerminalIntegrationCommand()
    }
    set {command = .terminalIntegration(newValue)}
  }

  public var listTerminalIntegrations: Local_ListTerminalIntegrationsCommand {
    get {
      if case .listTerminalIntegrations(let v)? = command {return v}
      return Local_ListTerminalIntegrationsCommand()
    }
    set {command = .listTerminalIntegrations(newValue)}
  }

  public var logout: Local_LogoutCommand {
    get {
      if case .logout(let v)? = command {return v}
      return Local_LogoutCommand()
    }
    set {command = .logout(newValue)}
  }

  public var restart: Local_RestartCommand {
    get {
      if case .restart(let v)? = command {return v}
      return Local_RestartCommand()
    }
    set {command = .restart(newValue)}
  }

  public var quit: Local_QuitCommand {
    get {
      if case .quit(let v)? = command {return v}
      return Local_QuitCommand()
    }
    set {command = .quit(newValue)}
  }

  public var update: Local_UpdateCommand {
    get {
      if case .update(let v)? = command {return v}
      return Local_UpdateCommand()
    }
    set {command = .update(newValue)}
  }

  public var diagnostics: Local_DiagnosticsCommand {
    get {
      if case .diagnostics(let v)? = command {return v}
      return Local_DiagnosticsCommand()
    }
    set {command = .diagnostics(newValue)}
  }

  public var reportWindow: Local_ReportWindowCommand {
    get {
      if case .reportWindow(let v)? = command {return v}
      return Local_ReportWindowCommand()
    }
    set {command = .reportWindow(newValue)}
  }

  public var restartSettingsListener: Local_RestartSettingsListenerCommand {
    get {
      if case .restartSettingsListener(let v)? = command {return v}
      return Local_RestartSettingsListenerCommand()
    }
    set {command = .restartSettingsListener(newValue)}
  }

  public var runInstallScript: Local_RunInstallScriptCommand {
    get {
      if case .runInstallScript(let v)? = command {return v}
      return Local_RunInstallScriptCommand()
    }
    set {command = .runInstallScript(newValue)}
  }

  public var build: Local_BuildCommand {
    get {
      if case .build(let v)? = command {return v}
      return Local_BuildCommand()
    }
    set {command = .build(newValue)}
  }

  public var openUiElement: Local_OpenUiElementCommand {
    get {
      if case .openUiElement(let v)? = command {return v}
      return Local_OpenUiElementCommand()
    }
    set {command = .openUiElement(newValue)}
  }

  public var resetCache: Local_ResetCacheCommand {
    get {
      if case .resetCache(let v)? = command {return v}
      return Local_ResetCacheCommand()
    }
    set {command = .resetCache(newValue)}
  }

  public var debugMode: Local_DebugModeCommand {
    get {
      if case .debugMode(let v)? = command {return v}
      return Local_DebugModeCommand()
    }
    set {command = .debugMode(newValue)}
  }

  public var promptAccessibility: Local_PromptAccessibilityCommand {
    get {
      if case .promptAccessibility(let v)? = command {return v}
      return Local_PromptAccessibilityCommand()
    }
    set {command = .promptAccessibility(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Command: Equatable {
    case terminalIntegration(Local_TerminalIntegrationCommand)
    case listTerminalIntegrations(Local_ListTerminalIntegrationsCommand)
    case logout(Local_LogoutCommand)
    case restart(Local_RestartCommand)
    case quit(Local_QuitCommand)
    case update(Local_UpdateCommand)
    case diagnostics(Local_DiagnosticsCommand)
    case reportWindow(Local_ReportWindowCommand)
    case restartSettingsListener(Local_RestartSettingsListenerCommand)
    case runInstallScript(Local_RunInstallScriptCommand)
    case build(Local_BuildCommand)
    case openUiElement(Local_OpenUiElementCommand)
    case resetCache(Local_ResetCacheCommand)
    case debugMode(Local_DebugModeCommand)
    case promptAccessibility(Local_PromptAccessibilityCommand)

    #if !swift(>=4.1)
    public static func ==(lhs: Local_Command.OneOf_Command, rhs: Local_Command.OneOf_Command) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.terminalIntegration, .terminalIntegration): return {
        guard case .terminalIntegration(let l) = lhs, case .terminalIntegration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listTerminalIntegrations, .listTerminalIntegrations): return {
        guard case .listTerminalIntegrations(let l) = lhs, case .listTerminalIntegrations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logout, .logout): return {
        guard case .logout(let l) = lhs, case .logout(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restart, .restart): return {
        guard case .restart(let l) = lhs, case .restart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.quit, .quit): return {
        guard case .quit(let l) = lhs, case .quit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diagnostics, .diagnostics): return {
        guard case .diagnostics(let l) = lhs, case .diagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reportWindow, .reportWindow): return {
        guard case .reportWindow(let l) = lhs, case .reportWindow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restartSettingsListener, .restartSettingsListener): return {
        guard case .restartSettingsListener(let l) = lhs, case .restartSettingsListener(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.runInstallScript, .runInstallScript): return {
        guard case .runInstallScript(let l) = lhs, case .runInstallScript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.build, .build): return {
        guard case .build(let l) = lhs, case .build(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openUiElement, .openUiElement): return {
        guard case .openUiElement(let l) = lhs, case .openUiElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetCache, .resetCache): return {
        guard case .resetCache(let l) = lhs, case .resetCache(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.debugMode, .debugMode): return {
        guard case .debugMode(let l) = lhs, case .debugMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.promptAccessibility, .promptAccessibility): return {
        guard case .promptAccessibility(let l) = lhs, case .promptAccessibility(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
    #endif
  }

  public init() {}

  fileprivate var _id: Int64?
  fileprivate var _noResponse: Bool?
}

public struct Local_Hook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hook: Local_Hook.OneOf_Hook?

  public var editBuffer: Local_EditBufferHook {
    get {
      if case .editBuffer(let v)? = hook {return v}
      return Local_EditBufferHook()
    }
    set {hook = .editBuffer(newValue)}
  }

  public var init_p: Local_InitHook {
    get {
      if case .init_p(let v)? = hook {return v}
      return Local_InitHook()
    }
    set {hook = .init_p(newValue)}
  }

  public var prompt: Local_PromptHook {
    get {
      if case .prompt(let v)? = hook {return v}
      return Local_PromptHook()
    }
    set {hook = .prompt(newValue)}
  }

  public var preExec: Local_PreExecHook {
    get {
      if case .preExec(let v)? = hook {return v}
      return Local_PreExecHook()
    }
    set {hook = .preExec(newValue)}
  }

  public var postExec: Local_PostExecHook {
    get {
      if case .postExec(let v)? = hook {return v}
      return Local_PostExecHook()
    }
    set {hook = .postExec(newValue)}
  }

  public var keyboardFocusChanged: Local_KeyboardFocusChangedHook {
    get {
      if case .keyboardFocusChanged(let v)? = hook {return v}
      return Local_KeyboardFocusChangedHook()
    }
    set {hook = .keyboardFocusChanged(newValue)}
  }

  public var tmuxPaneChanged: Local_TmuxPaneChangedHook {
    get {
      if case .tmuxPaneChanged(let v)? = hook {return v}
      return Local_TmuxPaneChangedHook()
    }
    set {hook = .tmuxPaneChanged(newValue)}
  }

  public var openedSshConnection: Local_OpenedSSHConnectionHook {
    get {
      if case .openedSshConnection(let v)? = hook {return v}
      return Local_OpenedSSHConnectionHook()
    }
    set {hook = .openedSshConnection(newValue)}
  }

  public var callback: Local_CallbackHook {
    get {
      if case .callback(let v)? = hook {return v}
      return Local_CallbackHook()
    }
    set {hook = .callback(newValue)}
  }

  public var integrationReady: Local_IntegrationReadyHook {
    get {
      if case .integrationReady(let v)? = hook {return v}
      return Local_IntegrationReadyHook()
    }
    set {hook = .integrationReady(newValue)}
  }

  public var hide: Local_HideHook {
    get {
      if case .hide(let v)? = hook {return v}
      return Local_HideHook()
    }
    set {hook = .hide(newValue)}
  }

  public var event: Local_EventHook {
    get {
      if case .event(let v)? = hook {return v}
      return Local_EventHook()
    }
    set {hook = .event(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Hook: Equatable {
    case editBuffer(Local_EditBufferHook)
    case init_p(Local_InitHook)
    case prompt(Local_PromptHook)
    case preExec(Local_PreExecHook)
    case postExec(Local_PostExecHook)
    case keyboardFocusChanged(Local_KeyboardFocusChangedHook)
    case tmuxPaneChanged(Local_TmuxPaneChangedHook)
    case openedSshConnection(Local_OpenedSSHConnectionHook)
    case callback(Local_CallbackHook)
    case integrationReady(Local_IntegrationReadyHook)
    case hide(Local_HideHook)
    case event(Local_EventHook)

    #if !swift(>=4.1)
    public static func ==(lhs: Local_Hook.OneOf_Hook, rhs: Local_Hook.OneOf_Hook) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.editBuffer, .editBuffer): return {
        guard case .editBuffer(let l) = lhs, case .editBuffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prompt, .prompt): return {
        guard case .prompt(let l) = lhs, case .prompt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preExec, .preExec): return {
        guard case .preExec(let l) = lhs, case .preExec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postExec, .postExec): return {
        guard case .postExec(let l) = lhs, case .postExec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyboardFocusChanged, .keyboardFocusChanged): return {
        guard case .keyboardFocusChanged(let l) = lhs, case .keyboardFocusChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tmuxPaneChanged, .tmuxPaneChanged): return {
        guard case .tmuxPaneChanged(let l) = lhs, case .tmuxPaneChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openedSshConnection, .openedSshConnection): return {
        guard case .openedSshConnection(let l) = lhs, case .openedSshConnection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callback, .callback): return {
        guard case .callback(let l) = lhs, case .callback(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integrationReady, .integrationReady): return {
        guard case .integrationReady(let l) = lhs, case .integrationReady(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hide, .hide): return {
        guard case .hide(let l) = lhs, case .hide(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
    #endif
  }

  public init() {}
}

public struct Local_TerminalIntegrationCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var action: Local_IntegrationAction = .install

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_ListTerminalIntegrationsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_LogoutCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_RestartCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_QuitCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_UpdateCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_DiagnosticsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_ReportWindowCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var report: String = String()

  public var path: String = String()

  public var figEnvVar: String = String()

  public var terminal: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_RestartSettingsListenerCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_RunInstallScriptCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_BuildCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var branch: String {
    get {return _branch ?? String()}
    set {_branch = newValue}
  }
  /// Returns true if `branch` has been explicitly set.
  public var hasBranch: Bool {return self._branch != nil}
  /// Clears the value of `branch`. Subsequent reads from it will return its default value.
  public mutating func clearBranch() {self._branch = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _branch: String?
}

public struct Local_OpenUiElementCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var element: Local_UiElement = .menuBar

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_ResetCacheCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_DebugModeCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set debug mode to true or false
  public var setDebugMode: Bool {
    get {return _setDebugMode ?? false}
    set {_setDebugMode = newValue}
  }
  /// Returns true if `setDebugMode` has been explicitly set.
  public var hasSetDebugMode: Bool {return self._setDebugMode != nil}
  /// Clears the value of `setDebugMode`. Subsequent reads from it will return its default value.
  public mutating func clearSetDebugMode() {self._setDebugMode = nil}

  /// Toggle debug mode
  public var toggleDebugMode: Bool {
    get {return _toggleDebugMode ?? false}
    set {_toggleDebugMode = newValue}
  }
  /// Returns true if `toggleDebugMode` has been explicitly set.
  public var hasToggleDebugMode: Bool {return self._toggleDebugMode != nil}
  /// Clears the value of `toggleDebugMode`. Subsequent reads from it will return its default value.
  public mutating func clearToggleDebugMode() {self._toggleDebugMode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _setDebugMode: Bool?
  fileprivate var _toggleDebugMode: Bool?
}

public struct Local_PromptAccessibilityCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// == Hooks ==
public struct Local_ShellContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pid: Int32 {
    get {return _storage._pid ?? 0}
    set {_uniqueStorage()._pid = newValue}
  }
  /// Returns true if `pid` has been explicitly set.
  public var hasPid: Bool {return _storage._pid != nil}
  /// Clears the value of `pid`. Subsequent reads from it will return its default value.
  public mutating func clearPid() {_uniqueStorage()._pid = nil}

  /// /dev/ttys## of terminal session
  public var ttys: String {
    get {return _storage._ttys ?? String()}
    set {_uniqueStorage()._ttys = newValue}
  }
  /// Returns true if `ttys` has been explicitly set.
  public var hasTtys: Bool {return _storage._ttys != nil}
  /// Clears the value of `ttys`. Subsequent reads from it will return its default value.
  public mutating func clearTtys() {_uniqueStorage()._ttys = nil}

  /// the name of the process
  public var processName: String {
    get {return _storage._processName ?? String()}
    set {_uniqueStorage()._processName = newValue}
  }
  /// Returns true if `processName` has been explicitly set.
  public var hasProcessName: Bool {return _storage._processName != nil}
  /// Clears the value of `processName`. Subsequent reads from it will return its default value.
  public mutating func clearProcessName() {_uniqueStorage()._processName = nil}

  /// the directory where the user ran the command
  public var currentWorkingDirectory: String {
    get {return _storage._currentWorkingDirectory ?? String()}
    set {_uniqueStorage()._currentWorkingDirectory = newValue}
  }
  /// Returns true if `currentWorkingDirectory` has been explicitly set.
  public var hasCurrentWorkingDirectory: Bool {return _storage._currentWorkingDirectory != nil}
  /// Clears the value of `currentWorkingDirectory`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentWorkingDirectory() {_uniqueStorage()._currentWorkingDirectory = nil}

  /// the value of $TERM_SESSION_ID
  public var sessionID: String {
    get {return _storage._sessionID ?? String()}
    set {_uniqueStorage()._sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return _storage._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {_uniqueStorage()._sessionID = nil}

  public var integrationVersion: Int32 {
    get {return _storage._integrationVersion ?? 0}
    set {_uniqueStorage()._integrationVersion = newValue}
  }
  /// Returns true if `integrationVersion` has been explicitly set.
  public var hasIntegrationVersion: Bool {return _storage._integrationVersion != nil}
  /// Clears the value of `integrationVersion`. Subsequent reads from it will return its default value.
  public mutating func clearIntegrationVersion() {_uniqueStorage()._integrationVersion = nil}

  public var terminal: String {
    get {return _storage._terminal ?? String()}
    set {_uniqueStorage()._terminal = newValue}
  }
  /// Returns true if `terminal` has been explicitly set.
  public var hasTerminal: Bool {return _storage._terminal != nil}
  /// Clears the value of `terminal`. Subsequent reads from it will return its default value.
  public mutating func clearTerminal() {_uniqueStorage()._terminal = nil}

  public var hostname: String {
    get {return _storage._hostname ?? String()}
    set {_uniqueStorage()._hostname = newValue}
  }
  /// Returns true if `hostname` has been explicitly set.
  public var hasHostname: Bool {return _storage._hostname != nil}
  /// Clears the value of `hostname`. Subsequent reads from it will return its default value.
  public mutating func clearHostname() {_uniqueStorage()._hostname = nil}

  public var remoteContext: Local_ShellContext {
    get {return _storage._remoteContext ?? Local_ShellContext()}
    set {_uniqueStorage()._remoteContext = newValue}
  }
  /// Returns true if `remoteContext` has been explicitly set.
  public var hasRemoteContext: Bool {return _storage._remoteContext != nil}
  /// Clears the value of `remoteContext`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteContext() {_uniqueStorage()._remoteContext = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Local_EditBufferHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var text: String = String()

  public var cursor: Int64 = 0

  public var histno: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext?
}

public struct Local_InitHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var calledDirect: Bool = false

  public var bundle: String = String()

  public var env: [String: String] = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext?
}

public struct Local_PromptHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext?
}

public struct Local_PreExecHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// the full command that was run in the shell
  public var command: String {
    get {return _command ?? String()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() {self._command = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext?
  fileprivate var _command: String?
}

public struct Local_PostExecHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// the full command that was run in the shell
  public var command: String = String()

  /// the exit code of the command
  public var exitCode: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext?
}

public struct Local_KeyboardFocusChangedHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appIdentifier: String = String()

  /// a unique identifier associated with the pane or tab that is currently focused
  public var focusedSessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_TmuxPaneChangedHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paneIdentifier: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_OpenedSSHConnectionHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var controlPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext?
}

public struct Local_CallbackHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handlerID: String = String()

  public var filepath: String = String()

  public var exitCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_IntegrationReadyHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_HideHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_EventHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// == Responses ==
public struct Local_ErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exitCode: Int32?
  fileprivate var _message: String?
}

public struct Local_SuccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: String?
}

public struct Local_TerminalIntegration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bundleIdentifier: String = String()

  public var name: String = String()

  public var status: String {
    get {return _status ?? String()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: String?
}

public struct Local_TerminalIntegrationsListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var integrations: [Local_TerminalIntegration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_DiagnosticsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var distribution: String {
    get {return _storage._distribution}
    set {_uniqueStorage()._distribution = newValue}
  }

  public var beta: Bool {
    get {return _storage._beta}
    set {_uniqueStorage()._beta = newValue}
  }

  public var debugAutocomplete: Bool {
    get {return _storage._debugAutocomplete}
    set {_uniqueStorage()._debugAutocomplete = newValue}
  }

  public var developerModeEnabled: Bool {
    get {return _storage._developerModeEnabled}
    set {_uniqueStorage()._developerModeEnabled = newValue}
  }

  public var currentLayoutName: String {
    get {return _storage._currentLayoutName}
    set {_uniqueStorage()._currentLayoutName = newValue}
  }

  public var isRunningOnReadOnlyVolume: Bool {
    get {return _storage._isRunningOnReadOnlyVolume}
    set {_uniqueStorage()._isRunningOnReadOnlyVolume = newValue}
  }

  public var pathToBundle: String {
    get {return _storage._pathToBundle}
    set {_uniqueStorage()._pathToBundle = newValue}
  }

  public var accessibility: String {
    get {return _storage._accessibility}
    set {_uniqueStorage()._accessibility = newValue}
  }

  public var keypath: String {
    get {return _storage._keypath}
    set {_uniqueStorage()._keypath = newValue}
  }

  public var docker: String {
    get {return _storage._docker}
    set {_uniqueStorage()._docker = newValue}
  }

  public var symlinked: String {
    get {return _storage._symlinked}
    set {_uniqueStorage()._symlinked = newValue}
  }

  public var onlytab: String {
    get {return _storage._onlytab}
    set {_uniqueStorage()._onlytab = newValue}
  }

  public var installscript: String {
    get {return _storage._installscript}
    set {_uniqueStorage()._installscript = newValue}
  }

  public var psudoterminalPath: String {
    get {return _storage._psudoterminalPath}
    set {_uniqueStorage()._psudoterminalPath = newValue}
  }

  public var securekeyboard: String {
    get {return _storage._securekeyboard}
    set {_uniqueStorage()._securekeyboard = newValue}
  }

  public var securekeyboardPath: String {
    get {return _storage._securekeyboardPath}
    set {_uniqueStorage()._securekeyboardPath = newValue}
  }

  public var currentProcess: String {
    get {return _storage._currentProcess}
    set {_uniqueStorage()._currentProcess = newValue}
  }

  public var currentWindowIdentifier: String {
    get {return _storage._currentWindowIdentifier}
    set {_uniqueStorage()._currentWindowIdentifier = newValue}
  }

  public var autocomplete: Bool {
    get {return _storage._autocomplete}
    set {_uniqueStorage()._autocomplete = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Local_CommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var response: Local_CommandResponse.OneOf_Response?

  public var error: Local_ErrorResponse {
    get {
      if case .error(let v)? = response {return v}
      return Local_ErrorResponse()
    }
    set {response = .error(newValue)}
  }

  public var success: Local_SuccessResponse {
    get {
      if case .success(let v)? = response {return v}
      return Local_SuccessResponse()
    }
    set {response = .success(newValue)}
  }

  /// ... add structured responses for specific commands, as necessary
  public var integrationList: Local_TerminalIntegrationsListResponse {
    get {
      if case .integrationList(let v)? = response {return v}
      return Local_TerminalIntegrationsListResponse()
    }
    set {response = .integrationList(newValue)}
  }

  public var diagnostics: Local_DiagnosticsResponse {
    get {
      if case .diagnostics(let v)? = response {return v}
      return Local_DiagnosticsResponse()
    }
    set {response = .diagnostics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case error(Local_ErrorResponse)
    case success(Local_SuccessResponse)
    /// ... add structured responses for specific commands, as necessary
    case integrationList(Local_TerminalIntegrationsListResponse)
    case diagnostics(Local_DiagnosticsResponse)

    #if !swift(>=4.1)
    public static func ==(lhs: Local_CommandResponse.OneOf_Response, rhs: Local_CommandResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integrationList, .integrationList): return {
        guard case .integrationList(let l) = lhs, case .integrationList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diagnostics, .diagnostics): return {
        guard case .diagnostics(let l) = lhs, case .diagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
    #endif
  }

  public init() {}

  fileprivate var _id: Int64?
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "local"

extension Local_IntegrationAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTALL"),
    1: .same(proto: "VERIFY_INSTALL"),
    2: .same(proto: "UNINSTALL")
  ]
}

extension Local_UiElement: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MENU_BAR"),
    1: .same(proto: "SETTINGS")
  ]
}

extension Local_LocalMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "command"),
    3: .same(proto: "hook")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Local_Command?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .command(v)
        }
      }()
      case 3: try {
        var v: Local_Hook?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .hook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .hook(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .command?: try {
      guard case .command(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hook?: try {
      guard case .hook(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_LocalMessage, rhs: Local_LocalMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "no_response"),
    100: .standard(proto: "terminal_integration"),
    101: .standard(proto: "list_terminal_integrations"),
    102: .same(proto: "logout"),
    103: .same(proto: "restart"),
    104: .same(proto: "quit"),
    105: .same(proto: "update"),
    106: .same(proto: "diagnostics"),
    107: .standard(proto: "report_window"),
    108: .standard(proto: "restart_settings_listener"),
    109: .standard(proto: "run_install_script"),
    110: .same(proto: "build"),
    111: .standard(proto: "open_ui_element"),
    112: .standard(proto: "reset_cache"),
    113: .standard(proto: "debug_mode"),
    114: .standard(proto: "prompt_accessibility")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._noResponse) }()
      case 100: try {
        var v: Local_TerminalIntegrationCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .terminalIntegration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .terminalIntegration(v)
        }
      }()
      case 101: try {
        var v: Local_ListTerminalIntegrationsCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .listTerminalIntegrations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .listTerminalIntegrations(v)
        }
      }()
      case 102: try {
        var v: Local_LogoutCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .logout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .logout(v)
        }
      }()
      case 103: try {
        var v: Local_RestartCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .restart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .restart(v)
        }
      }()
      case 104: try {
        var v: Local_QuitCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .quit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .quit(v)
        }
      }()
      case 105: try {
        var v: Local_UpdateCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .update(v)
        }
      }()
      case 106: try {
        var v: Local_DiagnosticsCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .diagnostics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .diagnostics(v)
        }
      }()
      case 107: try {
        var v: Local_ReportWindowCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .reportWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .reportWindow(v)
        }
      }()
      case 108: try {
        var v: Local_RestartSettingsListenerCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .restartSettingsListener(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .restartSettingsListener(v)
        }
      }()
      case 109: try {
        var v: Local_RunInstallScriptCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .runInstallScript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .runInstallScript(v)
        }
      }()
      case 110: try {
        var v: Local_BuildCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .build(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .build(v)
        }
      }()
      case 111: try {
        var v: Local_OpenUiElementCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .openUiElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .openUiElement(v)
        }
      }()
      case 112: try {
        var v: Local_ResetCacheCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .resetCache(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .resetCache(v)
        }
      }()
      case 113: try {
        var v: Local_DebugModeCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .debugMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .debugMode(v)
        }
      }()
      case 114: try {
        var v: Local_PromptAccessibilityCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .promptAccessibility(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .promptAccessibility(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._noResponse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    switch self.command {
    case .terminalIntegration?: try {
      guard case .terminalIntegration(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .listTerminalIntegrations?: try {
      guard case .listTerminalIntegrations(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .logout?: try {
      guard case .logout(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .restart?: try {
      guard case .restart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .quit?: try {
      guard case .quit(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .update?: try {
      guard case .update(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .diagnostics?: try {
      guard case .diagnostics(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .reportWindow?: try {
      guard case .reportWindow(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .restartSettingsListener?: try {
      guard case .restartSettingsListener(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .runInstallScript?: try {
      guard case .runInstallScript(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .build?: try {
      guard case .build(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .openUiElement?: try {
      guard case .openUiElement(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .resetCache?: try {
      guard case .resetCache(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .debugMode?: try {
      guard case .debugMode(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .promptAccessibility?: try {
      guard case .promptAccessibility(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Command, rhs: Local_Command) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._noResponse != rhs._noResponse {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Hook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .standard(proto: "edit_buffer"),
    101: .same(proto: "init"),
    102: .same(proto: "prompt"),
    103: .standard(proto: "pre_exec"),
    104: .standard(proto: "post_exec"),
    105: .standard(proto: "keyboard_focus_changed"),
    106: .standard(proto: "tmux_pane_changed"),
    107: .standard(proto: "opened_ssh_connection"),
    108: .same(proto: "callback"),
    109: .standard(proto: "integration_ready"),
    110: .same(proto: "hide"),
    111: .same(proto: "event")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 100: try {
        var v: Local_EditBufferHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .editBuffer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .editBuffer(v)
        }
      }()
      case 101: try {
        var v: Local_InitHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .init_p(v)
        }
      }()
      case 102: try {
        var v: Local_PromptHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .prompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .prompt(v)
        }
      }()
      case 103: try {
        var v: Local_PreExecHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .preExec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .preExec(v)
        }
      }()
      case 104: try {
        var v: Local_PostExecHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .postExec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .postExec(v)
        }
      }()
      case 105: try {
        var v: Local_KeyboardFocusChangedHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .keyboardFocusChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .keyboardFocusChanged(v)
        }
      }()
      case 106: try {
        var v: Local_TmuxPaneChangedHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .tmuxPaneChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .tmuxPaneChanged(v)
        }
      }()
      case 107: try {
        var v: Local_OpenedSSHConnectionHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .openedSshConnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .openedSshConnection(v)
        }
      }()
      case 108: try {
        var v: Local_CallbackHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .callback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .callback(v)
        }
      }()
      case 109: try {
        var v: Local_IntegrationReadyHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .integrationReady(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .integrationReady(v)
        }
      }()
      case 110: try {
        var v: Local_HideHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .hide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .hide(v)
        }
      }()
      case 111: try {
        var v: Local_EventHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .event(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.hook {
    case .editBuffer?: try {
      guard case .editBuffer(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .init_p?: try {
      guard case .init_p(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .prompt?: try {
      guard case .prompt(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .preExec?: try {
      guard case .preExec(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .postExec?: try {
      guard case .postExec(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .keyboardFocusChanged?: try {
      guard case .keyboardFocusChanged(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .tmuxPaneChanged?: try {
      guard case .tmuxPaneChanged(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .openedSshConnection?: try {
      guard case .openedSshConnection(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .callback?: try {
      guard case .callback(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .integrationReady?: try {
      guard case .integrationReady(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .hide?: try {
      guard case .hide(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .event?: try {
      guard case .event(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Hook, rhs: Local_Hook) -> Bool {
    if lhs.hook != rhs.hook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegrationCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegrationCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "action")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if self.action != .install {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegrationCommand, rhs: Local_TerminalIntegrationCommand) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ListTerminalIntegrationsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTerminalIntegrationsCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ListTerminalIntegrationsCommand, rhs: Local_ListTerminalIntegrationsCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_LogoutCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_LogoutCommand, rhs: Local_LogoutCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_RestartCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestartCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_RestartCommand, rhs: Local_RestartCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_QuitCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuitCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_QuitCommand, rhs: Local_QuitCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_UpdateCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "force")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_UpdateCommand, rhs: Local_UpdateCommand) -> Bool {
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_DiagnosticsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiagnosticsCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_DiagnosticsCommand, rhs: Local_DiagnosticsCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ReportWindowCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportWindowCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "report"),
    2: .same(proto: "path"),
    3: .standard(proto: "fig_env_var"),
    4: .same(proto: "terminal")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.report) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.figEnvVar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.terminal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.report.isEmpty {
      try visitor.visitSingularStringField(value: self.report, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.figEnvVar.isEmpty {
      try visitor.visitSingularStringField(value: self.figEnvVar, fieldNumber: 3)
    }
    if !self.terminal.isEmpty {
      try visitor.visitSingularStringField(value: self.terminal, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ReportWindowCommand, rhs: Local_ReportWindowCommand) -> Bool {
    if lhs.report != rhs.report {return false}
    if lhs.path != rhs.path {return false}
    if lhs.figEnvVar != rhs.figEnvVar {return false}
    if lhs.terminal != rhs.terminal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_RestartSettingsListenerCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestartSettingsListenerCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_RestartSettingsListenerCommand, rhs: Local_RestartSettingsListenerCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_RunInstallScriptCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunInstallScriptCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_RunInstallScriptCommand, rhs: Local_RunInstallScriptCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_BuildCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "branch")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._branch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._branch {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_BuildCommand, rhs: Local_BuildCommand) -> Bool {
    if lhs._branch != rhs._branch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_OpenUiElementCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenUiElementCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.element) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.element != .menuBar {
      try visitor.visitSingularEnumField(value: self.element, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_OpenUiElementCommand, rhs: Local_OpenUiElementCommand) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ResetCacheCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetCacheCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ResetCacheCommand, rhs: Local_ResetCacheCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_DebugModeCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DebugModeCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_debug_mode"),
    2: .standard(proto: "toggle_debug_mode")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._setDebugMode) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._toggleDebugMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._setDebugMode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._toggleDebugMode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_DebugModeCommand, rhs: Local_DebugModeCommand) -> Bool {
    if lhs._setDebugMode != rhs._setDebugMode {return false}
    if lhs._toggleDebugMode != rhs._toggleDebugMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PromptAccessibilityCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptAccessibilityCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PromptAccessibilityCommand, rhs: Local_PromptAccessibilityCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ShellContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShellContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "ttys"),
    3: .standard(proto: "process_name"),
    4: .standard(proto: "current_working_directory"),
    5: .standard(proto: "session_id"),
    6: .standard(proto: "integration_version"),
    7: .same(proto: "terminal"),
    8: .same(proto: "hostname"),
    9: .standard(proto: "remote_context")
  ]

  fileprivate class _StorageClass {
    var _pid: Int32?
    var _ttys: String?
    var _processName: String?
    var _currentWorkingDirectory: String?
    var _sessionID: String?
    var _integrationVersion: Int32?
    var _terminal: String?
    var _hostname: String?
    var _remoteContext: Local_ShellContext?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pid = source._pid
      _ttys = source._ttys
      _processName = source._processName
      _currentWorkingDirectory = source._currentWorkingDirectory
      _sessionID = source._sessionID
      _integrationVersion = source._integrationVersion
      _terminal = source._terminal
      _hostname = source._hostname
      _remoteContext = source._remoteContext
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._pid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._ttys) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._processName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._currentWorkingDirectory) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._sessionID) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._integrationVersion) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._terminal) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._hostname) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._remoteContext) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pid {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._ttys {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._processName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._currentWorkingDirectory {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._sessionID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._integrationVersion {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._terminal {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._hostname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._remoteContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ShellContext, rhs: Local_ShellContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pid != rhs_storage._pid {return false}
        if _storage._ttys != rhs_storage._ttys {return false}
        if _storage._processName != rhs_storage._processName {return false}
        if _storage._currentWorkingDirectory != rhs_storage._currentWorkingDirectory {return false}
        if _storage._sessionID != rhs_storage._sessionID {return false}
        if _storage._integrationVersion != rhs_storage._integrationVersion {return false}
        if _storage._terminal != rhs_storage._terminal {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._remoteContext != rhs_storage._remoteContext {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_EditBufferHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditBufferHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "text"),
    3: .same(proto: "cursor"),
    4: .same(proto: "histno")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.cursor) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.histno) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.cursor != 0 {
      try visitor.visitSingularInt64Field(value: self.cursor, fieldNumber: 3)
    }
    if self.histno != 0 {
      try visitor.visitSingularInt64Field(value: self.histno, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_EditBufferHook, rhs: Local_EditBufferHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.text != rhs.text {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.histno != rhs.histno {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_InitHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .standard(proto: "called_direct"),
    3: .same(proto: "bundle"),
    100: .same(proto: "env")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.calledDirect) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bundle) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &self.env) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.calledDirect != false {
      try visitor.visitSingularBoolField(value: self.calledDirect, fieldNumber: 2)
    }
    if !self.bundle.isEmpty {
      try visitor.visitSingularStringField(value: self.bundle, fieldNumber: 3)
    }
    if !self.env.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: self.env, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_InitHook, rhs: Local_InitHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.calledDirect != rhs.calledDirect {return false}
    if lhs.bundle != rhs.bundle {return false}
    if lhs.env != rhs.env {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PromptHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PromptHook, rhs: Local_PromptHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PreExecHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreExecHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "command")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._command {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PreExecHook, rhs: Local_PreExecHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PostExecHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostExecHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "command"),
    3: .standard(proto: "exit_code")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PostExecHook, rhs: Local_PostExecHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.command != rhs.command {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_KeyboardFocusChangedHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyboardFocusChangedHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_identifier"),
    2: .standard(proto: "focused_session_id")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.focusedSessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.appIdentifier, fieldNumber: 1)
    }
    if !self.focusedSessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.focusedSessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_KeyboardFocusChangedHook, rhs: Local_KeyboardFocusChangedHook) -> Bool {
    if lhs.appIdentifier != rhs.appIdentifier {return false}
    if lhs.focusedSessionID != rhs.focusedSessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TmuxPaneChangedHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TmuxPaneChangedHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pane_identifier")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.paneIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.paneIdentifier != 0 {
      try visitor.visitSingularInt32Field(value: self.paneIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TmuxPaneChangedHook, rhs: Local_TmuxPaneChangedHook) -> Bool {
    if lhs.paneIdentifier != rhs.paneIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_OpenedSSHConnectionHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenedSSHConnectionHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .standard(proto: "control_path")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.controlPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.controlPath.isEmpty {
      try visitor.visitSingularStringField(value: self.controlPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_OpenedSSHConnectionHook, rhs: Local_OpenedSSHConnectionHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.controlPath != rhs.controlPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_CallbackHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallbackHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "handler_id"),
    2: .same(proto: "filepath"),
    3: .standard(proto: "exit_code")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.handlerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filepath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.handlerID.isEmpty {
      try visitor.visitSingularStringField(value: self.handlerID, fieldNumber: 1)
    }
    if !self.filepath.isEmpty {
      try visitor.visitSingularStringField(value: self.filepath, fieldNumber: 2)
    }
    if !self.exitCode.isEmpty {
      try visitor.visitSingularStringField(value: self.exitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_CallbackHook, rhs: Local_CallbackHook) -> Bool {
    if lhs.handlerID != rhs.handlerID {return false}
    if lhs.filepath != rhs.filepath {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_IntegrationReadyHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegrationReadyHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_IntegrationReadyHook, rhs: Local_IntegrationReadyHook) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_HideHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HideHook"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_HideHook, rhs: Local_HideHook) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_EventHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_name")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventName.isEmpty {
      try visitor.visitSingularStringField(value: self.eventName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_EventHook, rhs: Local_EventHook) -> Bool {
    if lhs.eventName != rhs.eventName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exit_code"),
    2: .same(proto: "message")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ErrorResponse, rhs: Local_ErrorResponse) -> Bool {
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_SuccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuccessResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_SuccessResponse, rhs: Local_SuccessResponse) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_identifier"),
    2: .same(proto: "name"),
    3: .same(proto: "status")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bundleIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleIdentifier, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._status {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegration, rhs: Local_TerminalIntegration) -> Bool {
    if lhs.bundleIdentifier != rhs.bundleIdentifier {return false}
    if lhs.name != rhs.name {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegrationsListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegrationsListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "integrations")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.integrations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.integrations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.integrations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegrationsListResponse, rhs: Local_TerminalIntegrationsListResponse) -> Bool {
    if lhs.integrations != rhs.integrations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_DiagnosticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiagnosticsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "distribution"),
    2: .same(proto: "beta"),
    3: .standard(proto: "debug_autocomplete"),
    4: .standard(proto: "developer_mode_enabled"),
    5: .standard(proto: "current_layout_name"),
    6: .standard(proto: "is_running_on_read_only_volume"),
    7: .standard(proto: "path_to_bundle"),
    8: .same(proto: "accessibility"),
    9: .same(proto: "keypath"),
    10: .same(proto: "docker"),
    11: .same(proto: "symlinked"),
    12: .same(proto: "onlytab"),
    13: .same(proto: "installscript"),
    14: .standard(proto: "psudoterminal_path"),
    15: .same(proto: "securekeyboard"),
    16: .standard(proto: "securekeyboard_path"),
    17: .standard(proto: "current_process"),
    18: .standard(proto: "current_window_identifier"),
    19: .same(proto: "autocomplete")
  ]

  fileprivate class _StorageClass {
    var _distribution: String = String()
    var _beta: Bool = false
    var _debugAutocomplete: Bool = false
    var _developerModeEnabled: Bool = false
    var _currentLayoutName: String = String()
    var _isRunningOnReadOnlyVolume: Bool = false
    var _pathToBundle: String = String()
    var _accessibility: String = String()
    var _keypath: String = String()
    var _docker: String = String()
    var _symlinked: String = String()
    var _onlytab: String = String()
    var _installscript: String = String()
    var _psudoterminalPath: String = String()
    var _securekeyboard: String = String()
    var _securekeyboardPath: String = String()
    var _currentProcess: String = String()
    var _currentWindowIdentifier: String = String()
    var _autocomplete: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _distribution = source._distribution
      _beta = source._beta
      _debugAutocomplete = source._debugAutocomplete
      _developerModeEnabled = source._developerModeEnabled
      _currentLayoutName = source._currentLayoutName
      _isRunningOnReadOnlyVolume = source._isRunningOnReadOnlyVolume
      _pathToBundle = source._pathToBundle
      _accessibility = source._accessibility
      _keypath = source._keypath
      _docker = source._docker
      _symlinked = source._symlinked
      _onlytab = source._onlytab
      _installscript = source._installscript
      _psudoterminalPath = source._psudoterminalPath
      _securekeyboard = source._securekeyboard
      _securekeyboardPath = source._securekeyboardPath
      _currentProcess = source._currentProcess
      _currentWindowIdentifier = source._currentWindowIdentifier
      _autocomplete = source._autocomplete
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._distribution) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._beta) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._debugAutocomplete) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._developerModeEnabled) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._currentLayoutName) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._isRunningOnReadOnlyVolume) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._pathToBundle) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._accessibility) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._keypath) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._docker) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._symlinked) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._onlytab) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._installscript) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._psudoterminalPath) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._securekeyboard) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._securekeyboardPath) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._currentProcess) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._currentWindowIdentifier) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._autocomplete) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._distribution.isEmpty {
        try visitor.visitSingularStringField(value: _storage._distribution, fieldNumber: 1)
      }
      if _storage._beta != false {
        try visitor.visitSingularBoolField(value: _storage._beta, fieldNumber: 2)
      }
      if _storage._debugAutocomplete != false {
        try visitor.visitSingularBoolField(value: _storage._debugAutocomplete, fieldNumber: 3)
      }
      if _storage._developerModeEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._developerModeEnabled, fieldNumber: 4)
      }
      if !_storage._currentLayoutName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentLayoutName, fieldNumber: 5)
      }
      if _storage._isRunningOnReadOnlyVolume != false {
        try visitor.visitSingularBoolField(value: _storage._isRunningOnReadOnlyVolume, fieldNumber: 6)
      }
      if !_storage._pathToBundle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pathToBundle, fieldNumber: 7)
      }
      if !_storage._accessibility.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accessibility, fieldNumber: 8)
      }
      if !_storage._keypath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._keypath, fieldNumber: 9)
      }
      if !_storage._docker.isEmpty {
        try visitor.visitSingularStringField(value: _storage._docker, fieldNumber: 10)
      }
      if !_storage._symlinked.isEmpty {
        try visitor.visitSingularStringField(value: _storage._symlinked, fieldNumber: 11)
      }
      if !_storage._onlytab.isEmpty {
        try visitor.visitSingularStringField(value: _storage._onlytab, fieldNumber: 12)
      }
      if !_storage._installscript.isEmpty {
        try visitor.visitSingularStringField(value: _storage._installscript, fieldNumber: 13)
      }
      if !_storage._psudoterminalPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._psudoterminalPath, fieldNumber: 14)
      }
      if !_storage._securekeyboard.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securekeyboard, fieldNumber: 15)
      }
      if !_storage._securekeyboardPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securekeyboardPath, fieldNumber: 16)
      }
      if !_storage._currentProcess.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentProcess, fieldNumber: 17)
      }
      if !_storage._currentWindowIdentifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentWindowIdentifier, fieldNumber: 18)
      }
      if _storage._autocomplete != false {
        try visitor.visitSingularBoolField(value: _storage._autocomplete, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_DiagnosticsResponse, rhs: Local_DiagnosticsResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._distribution != rhs_storage._distribution {return false}
        if _storage._beta != rhs_storage._beta {return false}
        if _storage._debugAutocomplete != rhs_storage._debugAutocomplete {return false}
        if _storage._developerModeEnabled != rhs_storage._developerModeEnabled {return false}
        if _storage._currentLayoutName != rhs_storage._currentLayoutName {return false}
        if _storage._isRunningOnReadOnlyVolume != rhs_storage._isRunningOnReadOnlyVolume {return false}
        if _storage._pathToBundle != rhs_storage._pathToBundle {return false}
        if _storage._accessibility != rhs_storage._accessibility {return false}
        if _storage._keypath != rhs_storage._keypath {return false}
        if _storage._docker != rhs_storage._docker {return false}
        if _storage._symlinked != rhs_storage._symlinked {return false}
        if _storage._onlytab != rhs_storage._onlytab {return false}
        if _storage._installscript != rhs_storage._installscript {return false}
        if _storage._psudoterminalPath != rhs_storage._psudoterminalPath {return false}
        if _storage._securekeyboard != rhs_storage._securekeyboard {return false}
        if _storage._securekeyboardPath != rhs_storage._securekeyboardPath {return false}
        if _storage._currentProcess != rhs_storage._currentProcess {return false}
        if _storage._currentWindowIdentifier != rhs_storage._currentWindowIdentifier {return false}
        if _storage._autocomplete != rhs_storage._autocomplete {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_CommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
    100: .standard(proto: "integration_list"),
    101: .same(proto: "diagnostics")
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try {
        var v: Local_ErrorResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 3: try {
        var v: Local_SuccessResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 100: try {
        var v: Local_TerminalIntegrationsListResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .integrationList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .integrationList(v)
        }
      }()
      case 101: try {
        var v: Local_DiagnosticsResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .diagnostics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .diagnostics(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .integrationList?: try {
      guard case .integrationList(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .diagnostics?: try {
      guard case .diagnostics(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_CommandResponse, rhs: Local_CommandResponse) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
