// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: local.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Example Command
public enum Local_IntegrationAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case install // = 0
  case verifyInstall // = 1
  case uninstall // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .install
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .install
    case 1: self = .verifyInstall
    case 2: self = .uninstall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .install: return 0
    case .verifyInstall: return 1
    case .uninstall: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Local_IntegrationAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Local_IntegrationAction] = [
    .install,
    .verifyInstall,
    .uninstall,
  ]
}

#endif  // swift(>=4.2)

public struct Local_LocalMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Local_LocalMessage.OneOf_Type? = nil

  /// expect a response from the host app
  public var command: Local_Command {
    get {
      if case .command(let v)? = type {return v}
      return Local_Command()
    }
    set {type = .command(newValue)}
  }

  /// one way update only, no response expected
  public var hook: Local_Hook {
    get {
      if case .hook(let v)? = type {return v}
      return Local_Hook()
    }
    set {type = .hook(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    /// expect a response from the host app
    case command(Local_Command)
    /// one way update only, no response expected
    case hook(Local_Hook)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_LocalMessage.OneOf_Type, rhs: Local_LocalMessage.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.command, .command): return {
        guard case .command(let l) = lhs, case .command(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hook, .hook): return {
        guard case .hook(let l) = lhs, case .hook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Local_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// opt-out of response from host app
  public var noResponse: Bool {
    get {return _noResponse ?? false}
    set {_noResponse = newValue}
  }
  /// Returns true if `noResponse` has been explicitly set.
  public var hasNoResponse: Bool {return self._noResponse != nil}
  /// Clears the value of `noResponse`. Subsequent reads from it will return its default value.
  public mutating func clearNoResponse() {self._noResponse = nil}

  public var command: Local_Command.OneOf_Command? = nil

  public var terminalIntegrationUpdate: Local_TerminalIntegrationRequest {
    get {
      if case .terminalIntegrationUpdate(let v)? = command {return v}
      return Local_TerminalIntegrationRequest()
    }
    set {command = .terminalIntegrationUpdate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Command: Equatable {
    case terminalIntegrationUpdate(Local_TerminalIntegrationRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_Command.OneOf_Command, rhs: Local_Command.OneOf_Command) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.terminalIntegrationUpdate, .terminalIntegrationUpdate): return {
        guard case .terminalIntegrationUpdate(let l) = lhs, case .terminalIntegrationUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _noResponse: Bool? = nil
}

public struct Local_Hook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hook: Local_Hook.OneOf_Hook? = nil

  public var editbuffer: Local_EditBuffer {
    get {
      if case .editbuffer(let v)? = hook {return v}
      return Local_EditBuffer()
    }
    set {hook = .editbuffer(newValue)}
  }

  public var prompt: Local_Prompt {
    get {
      if case .prompt(let v)? = hook {return v}
      return Local_Prompt()
    }
    set {hook = .prompt(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Hook: Equatable {
    case editbuffer(Local_EditBuffer)
    case prompt(Local_Prompt)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_Hook.OneOf_Hook, rhs: Local_Hook.OneOf_Hook) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.editbuffer, .editbuffer): return {
        guard case .editbuffer(let l) = lhs, case .editbuffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prompt, .prompt): return {
        guard case .prompt(let l) = lhs, case .prompt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Local_TerminalIntegrationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var action: Local_IntegrationAction = .install

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Example Hook
public struct Local_EditBuffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var cursor: Int64 = 0

  public var shell: String = String()

  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_Prompt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pid: Int32 = 0

  public var shell: String = String()

  public var currentWorkingDirectory: String = String()

  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exitCode: Int32? = nil
  fileprivate var _message: String? = nil
}

public struct Local_Success {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: String? = nil
}

public struct Local_CommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var response: Local_CommandResponse.OneOf_Response? = nil

  public var error: Local_Error {
    get {
      if case .error(let v)? = response {return v}
      return Local_Error()
    }
    set {response = .error(newValue)}
  }

  /// ... add structured responses for specific commands, as necessary
  public var success: Local_Success {
    get {
      if case .success(let v)? = response {return v}
      return Local_Success()
    }
    set {response = .success(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case error(Local_Error)
    /// ... add structured responses for specific commands, as necessary
    case success(Local_Success)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_CommandResponse.OneOf_Response, rhs: Local_CommandResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "local"

extension Local_IntegrationAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTALL"),
    1: .same(proto: "VERIFY_INSTALL"),
    2: .same(proto: "UNINSTALL"),
  ]
}

extension Local_LocalMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "command"),
    3: .same(proto: "hook"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Local_Command?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .command(v)
        }
      }()
      case 3: try {
        var v: Local_Hook?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .hook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .hook(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .command?: try {
      guard case .command(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hook?: try {
      guard case .hook(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_LocalMessage, rhs: Local_LocalMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "no_response"),
    100: .standard(proto: "terminal_integration_update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._noResponse) }()
      case 100: try {
        var v: Local_TerminalIntegrationRequest?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .terminalIntegrationUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .terminalIntegrationUpdate(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._noResponse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if case .terminalIntegrationUpdate(let v)? = self.command {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Command, rhs: Local_Command) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._noResponse != rhs._noResponse {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Hook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .same(proto: "editbuffer"),
    101: .same(proto: "prompt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 100: try {
        var v: Local_EditBuffer?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .editbuffer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .editbuffer(v)
        }
      }()
      case 101: try {
        var v: Local_Prompt?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .prompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .prompt(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.hook {
    case .editbuffer?: try {
      guard case .editbuffer(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .prompt?: try {
      guard case .prompt(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Hook, rhs: Local_Hook) -> Bool {
    if lhs.hook != rhs.hook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegrationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegrationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if self.action != .install {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegrationRequest, rhs: Local_TerminalIntegrationRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_EditBuffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditBuffer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "cursor"),
    3: .same(proto: "shell"),
    4: .same(proto: "sessionId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.cursor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shell) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.cursor != 0 {
      try visitor.visitSingularInt64Field(value: self.cursor, fieldNumber: 2)
    }
    if !self.shell.isEmpty {
      try visitor.visitSingularStringField(value: self.shell, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_EditBuffer, rhs: Local_EditBuffer) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.shell != rhs.shell {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Prompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Prompt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "shell"),
    3: .same(proto: "currentWorkingDirectory"),
    4: .same(proto: "sessionId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.shell) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.currentWorkingDirectory) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 1)
    }
    if !self.shell.isEmpty {
      try visitor.visitSingularStringField(value: self.shell, fieldNumber: 2)
    }
    if !self.currentWorkingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.currentWorkingDirectory, fieldNumber: 3)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Prompt, rhs: Local_Prompt) -> Bool {
    if lhs.pid != rhs.pid {return false}
    if lhs.shell != rhs.shell {return false}
    if lhs.currentWorkingDirectory != rhs.currentWorkingDirectory {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exit_code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Error, rhs: Local_Error) -> Bool {
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Success, rhs: Local_Success) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_CommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try {
        var v: Local_Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 3: try {
        var v: Local_Success?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_CommandResponse, rhs: Local_CommandResponse) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
