// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: local.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// == Commands ==
public enum Local_IntegrationAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case install // = 0
  case verifyInstall // = 1
  case uninstall // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .install
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .install
    case 1: self = .verifyInstall
    case 2: self = .uninstall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .install: return 0
    case .verifyInstall: return 1
    case .uninstall: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Local_IntegrationAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Local_IntegrationAction] = [
    .install,
    .verifyInstall,
    .uninstall,
  ]
}

#endif  // swift(>=4.2)

public struct Local_LocalMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Local_LocalMessage.OneOf_Type? = nil

  /// expect a response from the host app
  public var command: Local_Command {
    get {
      if case .command(let v)? = type {return v}
      return Local_Command()
    }
    set {type = .command(newValue)}
  }

  /// one way update only, no response expected
  public var hook: Local_Hook {
    get {
      if case .hook(let v)? = type {return v}
      return Local_Hook()
    }
    set {type = .hook(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    /// expect a response from the host app
    case command(Local_Command)
    /// one way update only, no response expected
    case hook(Local_Hook)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_LocalMessage.OneOf_Type, rhs: Local_LocalMessage.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.command, .command): return {
        guard case .command(let l) = lhs, case .command(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hook, .hook): return {
        guard case .hook(let l) = lhs, case .hook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Local_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// opt-out of response from host app
  public var noResponse: Bool {
    get {return _noResponse ?? false}
    set {_noResponse = newValue}
  }
  /// Returns true if `noResponse` has been explicitly set.
  public var hasNoResponse: Bool {return self._noResponse != nil}
  /// Clears the value of `noResponse`. Subsequent reads from it will return its default value.
  public mutating func clearNoResponse() {self._noResponse = nil}

  public var command: Local_Command.OneOf_Command? = nil

  public var terminalIntegration: Local_TerminalIntegrationCommand {
    get {
      if case .terminalIntegration(let v)? = command {return v}
      return Local_TerminalIntegrationCommand()
    }
    set {command = .terminalIntegration(newValue)}
  }

  public var listTerminalIntegrations: Local_ListTerminalIntegrationsCommand {
    get {
      if case .listTerminalIntegrations(let v)? = command {return v}
      return Local_ListTerminalIntegrationsCommand()
    }
    set {command = .listTerminalIntegrations(newValue)}
  }

  public var logout: Local_LogoutCommand {
    get {
      if case .logout(let v)? = command {return v}
      return Local_LogoutCommand()
    }
    set {command = .logout(newValue)}
  }

  public var restart: Local_RestartCommand {
    get {
      if case .restart(let v)? = command {return v}
      return Local_RestartCommand()
    }
    set {command = .restart(newValue)}
  }

  public var quit: Local_QuitCommand {
    get {
      if case .quit(let v)? = command {return v}
      return Local_QuitCommand()
    }
    set {command = .quit(newValue)}
  }

  public var update: Local_UpdateCommand {
    get {
      if case .update(let v)? = command {return v}
      return Local_UpdateCommand()
    }
    set {command = .update(newValue)}
  }

  public var diagnostics: Local_DiagnosticsCommand {
    get {
      if case .diagnostics(let v)? = command {return v}
      return Local_DiagnosticsCommand()
    }
    set {command = .diagnostics(newValue)}
  }

  public var reportWindow: Local_ReportWindowCommand {
    get {
      if case .reportWindow(let v)? = command {return v}
      return Local_ReportWindowCommand()
    }
    set {command = .reportWindow(newValue)}
  }

  public var restartSettingsListener: Local_RestartSettingsListenerCommand {
    get {
      if case .restartSettingsListener(let v)? = command {return v}
      return Local_RestartSettingsListenerCommand()
    }
    set {command = .restartSettingsListener(newValue)}
  }

  public var runInstallScript: Local_RunInstallScriptCommand {
    get {
      if case .runInstallScript(let v)? = command {return v}
      return Local_RunInstallScriptCommand()
    }
    set {command = .runInstallScript(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Command: Equatable {
    case terminalIntegration(Local_TerminalIntegrationCommand)
    case listTerminalIntegrations(Local_ListTerminalIntegrationsCommand)
    case logout(Local_LogoutCommand)
    case restart(Local_RestartCommand)
    case quit(Local_QuitCommand)
    case update(Local_UpdateCommand)
    case diagnostics(Local_DiagnosticsCommand)
    case reportWindow(Local_ReportWindowCommand)
    case restartSettingsListener(Local_RestartSettingsListenerCommand)
    case runInstallScript(Local_RunInstallScriptCommand)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_Command.OneOf_Command, rhs: Local_Command.OneOf_Command) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.terminalIntegration, .terminalIntegration): return {
        guard case .terminalIntegration(let l) = lhs, case .terminalIntegration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listTerminalIntegrations, .listTerminalIntegrations): return {
        guard case .listTerminalIntegrations(let l) = lhs, case .listTerminalIntegrations(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logout, .logout): return {
        guard case .logout(let l) = lhs, case .logout(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restart, .restart): return {
        guard case .restart(let l) = lhs, case .restart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.quit, .quit): return {
        guard case .quit(let l) = lhs, case .quit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diagnostics, .diagnostics): return {
        guard case .diagnostics(let l) = lhs, case .diagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reportWindow, .reportWindow): return {
        guard case .reportWindow(let l) = lhs, case .reportWindow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restartSettingsListener, .restartSettingsListener): return {
        guard case .restartSettingsListener(let l) = lhs, case .restartSettingsListener(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.runInstallScript, .runInstallScript): return {
        guard case .runInstallScript(let l) = lhs, case .runInstallScript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
  fileprivate var _noResponse: Bool? = nil
}

public struct Local_Hook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hook: Local_Hook.OneOf_Hook? = nil

  public var editBuffer: Local_EditBufferHook {
    get {
      if case .editBuffer(let v)? = hook {return v}
      return Local_EditBufferHook()
    }
    set {hook = .editBuffer(newValue)}
  }

  public var init_p: Local_InitHook {
    get {
      if case .init_p(let v)? = hook {return v}
      return Local_InitHook()
    }
    set {hook = .init_p(newValue)}
  }

  public var prompt: Local_PromptHook {
    get {
      if case .prompt(let v)? = hook {return v}
      return Local_PromptHook()
    }
    set {hook = .prompt(newValue)}
  }

  public var preExec: Local_PreExecHook {
    get {
      if case .preExec(let v)? = hook {return v}
      return Local_PreExecHook()
    }
    set {hook = .preExec(newValue)}
  }

  public var postExec: Local_PostExecHook {
    get {
      if case .postExec(let v)? = hook {return v}
      return Local_PostExecHook()
    }
    set {hook = .postExec(newValue)}
  }

  public var keyboardFocusChanged: Local_KeyboardFocusChangedHook {
    get {
      if case .keyboardFocusChanged(let v)? = hook {return v}
      return Local_KeyboardFocusChangedHook()
    }
    set {hook = .keyboardFocusChanged(newValue)}
  }

  public var tmuxPaneChanged: Local_TmuxPaneChangedHook {
    get {
      if case .tmuxPaneChanged(let v)? = hook {return v}
      return Local_TmuxPaneChangedHook()
    }
    set {hook = .tmuxPaneChanged(newValue)}
  }

  public var openedSshConnection: Local_OpenedSSHConnectionHook {
    get {
      if case .openedSshConnection(let v)? = hook {return v}
      return Local_OpenedSSHConnectionHook()
    }
    set {hook = .openedSshConnection(newValue)}
  }

  public var callback: Local_CallbackHook {
    get {
      if case .callback(let v)? = hook {return v}
      return Local_CallbackHook()
    }
    set {hook = .callback(newValue)}
  }

  public var integrationReady: Local_IntegrationReadyHook {
    get {
      if case .integrationReady(let v)? = hook {return v}
      return Local_IntegrationReadyHook()
    }
    set {hook = .integrationReady(newValue)}
  }

  public var hide: Local_HideHook {
    get {
      if case .hide(let v)? = hook {return v}
      return Local_HideHook()
    }
    set {hook = .hide(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Hook: Equatable {
    case editBuffer(Local_EditBufferHook)
    case init_p(Local_InitHook)
    case prompt(Local_PromptHook)
    case preExec(Local_PreExecHook)
    case postExec(Local_PostExecHook)
    case keyboardFocusChanged(Local_KeyboardFocusChangedHook)
    case tmuxPaneChanged(Local_TmuxPaneChangedHook)
    case openedSshConnection(Local_OpenedSSHConnectionHook)
    case callback(Local_CallbackHook)
    case integrationReady(Local_IntegrationReadyHook)
    case hide(Local_HideHook)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_Hook.OneOf_Hook, rhs: Local_Hook.OneOf_Hook) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.editBuffer, .editBuffer): return {
        guard case .editBuffer(let l) = lhs, case .editBuffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prompt, .prompt): return {
        guard case .prompt(let l) = lhs, case .prompt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preExec, .preExec): return {
        guard case .preExec(let l) = lhs, case .preExec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postExec, .postExec): return {
        guard case .postExec(let l) = lhs, case .postExec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyboardFocusChanged, .keyboardFocusChanged): return {
        guard case .keyboardFocusChanged(let l) = lhs, case .keyboardFocusChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tmuxPaneChanged, .tmuxPaneChanged): return {
        guard case .tmuxPaneChanged(let l) = lhs, case .tmuxPaneChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openedSshConnection, .openedSshConnection): return {
        guard case .openedSshConnection(let l) = lhs, case .openedSshConnection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callback, .callback): return {
        guard case .callback(let l) = lhs, case .callback(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integrationReady, .integrationReady): return {
        guard case .integrationReady(let l) = lhs, case .integrationReady(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hide, .hide): return {
        guard case .hide(let l) = lhs, case .hide(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Local_TerminalIntegrationCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var action: Local_IntegrationAction = .install

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_ListTerminalIntegrationsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_LogoutCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_RestartCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_QuitCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_UpdateCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_DiagnosticsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_ReportWindowCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var report: String = String()

  public var path: String = String()

  public var figEnvVar: String = String()

  public var terminal: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_RestartSettingsListenerCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_RunInstallScriptCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// == Hooks ==
public struct Local_ShellContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pid: Int32 {
    get {return _pid ?? 0}
    set {_pid = newValue}
  }
  /// Returns true if `pid` has been explicitly set.
  public var hasPid: Bool {return self._pid != nil}
  /// Clears the value of `pid`. Subsequent reads from it will return its default value.
  public mutating func clearPid() {self._pid = nil}

  /// /dev/ttys## of terminal session
  public var ttys: String {
    get {return _ttys ?? String()}
    set {_ttys = newValue}
  }
  /// Returns true if `ttys` has been explicitly set.
  public var hasTtys: Bool {return self._ttys != nil}
  /// Clears the value of `ttys`. Subsequent reads from it will return its default value.
  public mutating func clearTtys() {self._ttys = nil}

  /// the name of the shell
  public var shell: String {
    get {return _shell ?? String()}
    set {_shell = newValue}
  }
  /// Returns true if `shell` has been explicitly set.
  public var hasShell: Bool {return self._shell != nil}
  /// Clears the value of `shell`. Subsequent reads from it will return its default value.
  public mutating func clearShell() {self._shell = nil}

  /// the directory where the user ran the command
  public var currentWorkingDirectory: String {
    get {return _currentWorkingDirectory ?? String()}
    set {_currentWorkingDirectory = newValue}
  }
  /// Returns true if `currentWorkingDirectory` has been explicitly set.
  public var hasCurrentWorkingDirectory: Bool {return self._currentWorkingDirectory != nil}
  /// Clears the value of `currentWorkingDirectory`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentWorkingDirectory() {self._currentWorkingDirectory = nil}

  /// the value of $TERM_SESSION_ID 
  public var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var integrationVersion: String {
    get {return _integrationVersion ?? String()}
    set {_integrationVersion = newValue}
  }
  /// Returns true if `integrationVersion` has been explicitly set.
  public var hasIntegrationVersion: Bool {return self._integrationVersion != nil}
  /// Clears the value of `integrationVersion`. Subsequent reads from it will return its default value.
  public mutating func clearIntegrationVersion() {self._integrationVersion = nil}

  public var terminal: String {
    get {return _terminal ?? String()}
    set {_terminal = newValue}
  }
  /// Returns true if `terminal` has been explicitly set.
  public var hasTerminal: Bool {return self._terminal != nil}
  /// Clears the value of `terminal`. Subsequent reads from it will return its default value.
  public mutating func clearTerminal() {self._terminal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pid: Int32? = nil
  fileprivate var _ttys: String? = nil
  fileprivate var _shell: String? = nil
  fileprivate var _currentWorkingDirectory: String? = nil
  fileprivate var _sessionID: String? = nil
  fileprivate var _integrationVersion: String? = nil
  fileprivate var _terminal: String? = nil
}

public struct Local_EditBufferHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var text: String = String()

  public var cursor: Int64 = 0

  public var histno: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_InitHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var calledDirect: Bool = false

  public var bundle: String = String()

  public var env: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_PromptHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_PreExecHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// the full command that was run in the shell
  public var command: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_PostExecHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  /// the full command that was run in the shell
  public var command: String = String()

  /// the exit code of the command
  public var exitCode: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_KeyboardFocusChangedHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bundleIdentifier: String = String()

  /// a unique identifier associated with the pane or tab that is currently focused
  public var focusedSession: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_TmuxPaneChangedHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paneIdentifier: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_OpenedSSHConnectionHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var controlPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
}

public struct Local_CallbackHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handlerID: String = String()

  public var filepath: String = String()

  public var exitCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_IntegrationReadyHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_HideHook {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// == Responses ==
public struct Local_ErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exitCode: Int32? = nil
  fileprivate var _message: String? = nil
}

public struct Local_SuccessResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: String? = nil
}

public struct Local_TerminalIntegration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bundleIdentifier: String = String()

  public var name: String = String()

  public var status: String {
    get {return _status ?? String()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: String? = nil
}

public struct Local_TerminalIntegrationsListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var integrations: [Local_TerminalIntegration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_DiagnosticsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pathToBundle: String = String()

  public var accessibility: String = String()

  public var keypath: String = String()

  public var docker: String = String()

  public var symlinked: String = String()

  public var onlytab: String = String()

  public var installscript: String = String()

  public var psudopath: String = String()

  public var securekeyboard: String = String()

  public var securekeyboardPath: String = String()

  public var currentProcess: String = String()

  public var currentWindowIdentifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Local_CommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var response: Local_CommandResponse.OneOf_Response? = nil

  public var error: Local_ErrorResponse {
    get {
      if case .error(let v)? = response {return v}
      return Local_ErrorResponse()
    }
    set {response = .error(newValue)}
  }

  public var success: Local_SuccessResponse {
    get {
      if case .success(let v)? = response {return v}
      return Local_SuccessResponse()
    }
    set {response = .success(newValue)}
  }

  /// ... add structured responses for specific commands, as necessary
  public var integrationList: Local_TerminalIntegrationsListResponse {
    get {
      if case .integrationList(let v)? = response {return v}
      return Local_TerminalIntegrationsListResponse()
    }
    set {response = .integrationList(newValue)}
  }

  public var diagnostics: Local_DiagnosticsResponse {
    get {
      if case .diagnostics(let v)? = response {return v}
      return Local_DiagnosticsResponse()
    }
    set {response = .diagnostics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case error(Local_ErrorResponse)
    case success(Local_SuccessResponse)
    /// ... add structured responses for specific commands, as necessary
    case integrationList(Local_TerminalIntegrationsListResponse)
    case diagnostics(Local_DiagnosticsResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Local_CommandResponse.OneOf_Response, rhs: Local_CommandResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integrationList, .integrationList): return {
        guard case .integrationList(let l) = lhs, case .integrationList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diagnostics, .diagnostics): return {
        guard case .diagnostics(let l) = lhs, case .diagnostics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "local"

extension Local_IntegrationAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTALL"),
    1: .same(proto: "VERIFY_INSTALL"),
    2: .same(proto: "UNINSTALL"),
  ]
}

extension Local_LocalMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "command"),
    3: .same(proto: "hook"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Local_Command?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .command(v)
        }
      }()
      case 3: try {
        var v: Local_Hook?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .hook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .hook(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .command?: try {
      guard case .command(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hook?: try {
      guard case .hook(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_LocalMessage, rhs: Local_LocalMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "no_response"),
    100: .standard(proto: "terminal_integration"),
    101: .standard(proto: "list_terminal_integrations"),
    102: .same(proto: "logout"),
    103: .same(proto: "restart"),
    104: .same(proto: "quit"),
    105: .same(proto: "update"),
    106: .same(proto: "diagnostics"),
    107: .standard(proto: "report_window"),
    108: .standard(proto: "restart_settings_listener"),
    109: .standard(proto: "run_install_script"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._noResponse) }()
      case 100: try {
        var v: Local_TerminalIntegrationCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .terminalIntegration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .terminalIntegration(v)
        }
      }()
      case 101: try {
        var v: Local_ListTerminalIntegrationsCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .listTerminalIntegrations(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .listTerminalIntegrations(v)
        }
      }()
      case 102: try {
        var v: Local_LogoutCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .logout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .logout(v)
        }
      }()
      case 103: try {
        var v: Local_RestartCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .restart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .restart(v)
        }
      }()
      case 104: try {
        var v: Local_QuitCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .quit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .quit(v)
        }
      }()
      case 105: try {
        var v: Local_UpdateCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .update(v)
        }
      }()
      case 106: try {
        var v: Local_DiagnosticsCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .diagnostics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .diagnostics(v)
        }
      }()
      case 107: try {
        var v: Local_ReportWindowCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .reportWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .reportWindow(v)
        }
      }()
      case 108: try {
        var v: Local_RestartSettingsListenerCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .restartSettingsListener(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .restartSettingsListener(v)
        }
      }()
      case 109: try {
        var v: Local_RunInstallScriptCommand?
        var hadOneofValue = false
        if let current = self.command {
          hadOneofValue = true
          if case .runInstallScript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.command = .runInstallScript(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._noResponse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    switch self.command {
    case .terminalIntegration?: try {
      guard case .terminalIntegration(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .listTerminalIntegrations?: try {
      guard case .listTerminalIntegrations(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .logout?: try {
      guard case .logout(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .restart?: try {
      guard case .restart(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .quit?: try {
      guard case .quit(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .update?: try {
      guard case .update(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .diagnostics?: try {
      guard case .diagnostics(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .reportWindow?: try {
      guard case .reportWindow(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .restartSettingsListener?: try {
      guard case .restartSettingsListener(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .runInstallScript?: try {
      guard case .runInstallScript(let v)? = self.command else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Command, rhs: Local_Command) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._noResponse != rhs._noResponse {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_Hook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .standard(proto: "edit_buffer"),
    101: .same(proto: "init"),
    102: .same(proto: "prompt"),
    103: .standard(proto: "pre_exec"),
    104: .standard(proto: "post_exec"),
    105: .standard(proto: "keyboard_focus_changed"),
    106: .standard(proto: "tmux_pane_changed"),
    107: .standard(proto: "opened_ssh_connection"),
    108: .same(proto: "callback"),
    109: .standard(proto: "integration_ready"),
    110: .same(proto: "hide"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 100: try {
        var v: Local_EditBufferHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .editBuffer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .editBuffer(v)
        }
      }()
      case 101: try {
        var v: Local_InitHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .init_p(v)
        }
      }()
      case 102: try {
        var v: Local_PromptHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .prompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .prompt(v)
        }
      }()
      case 103: try {
        var v: Local_PreExecHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .preExec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .preExec(v)
        }
      }()
      case 104: try {
        var v: Local_PostExecHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .postExec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .postExec(v)
        }
      }()
      case 105: try {
        var v: Local_KeyboardFocusChangedHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .keyboardFocusChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .keyboardFocusChanged(v)
        }
      }()
      case 106: try {
        var v: Local_TmuxPaneChangedHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .tmuxPaneChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .tmuxPaneChanged(v)
        }
      }()
      case 107: try {
        var v: Local_OpenedSSHConnectionHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .openedSshConnection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .openedSshConnection(v)
        }
      }()
      case 108: try {
        var v: Local_CallbackHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .callback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .callback(v)
        }
      }()
      case 109: try {
        var v: Local_IntegrationReadyHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .integrationReady(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .integrationReady(v)
        }
      }()
      case 110: try {
        var v: Local_HideHook?
        var hadOneofValue = false
        if let current = self.hook {
          hadOneofValue = true
          if case .hide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.hook = .hide(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.hook {
    case .editBuffer?: try {
      guard case .editBuffer(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .init_p?: try {
      guard case .init_p(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .prompt?: try {
      guard case .prompt(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .preExec?: try {
      guard case .preExec(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .postExec?: try {
      guard case .postExec(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .keyboardFocusChanged?: try {
      guard case .keyboardFocusChanged(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .tmuxPaneChanged?: try {
      guard case .tmuxPaneChanged(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .openedSshConnection?: try {
      guard case .openedSshConnection(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .callback?: try {
      guard case .callback(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .integrationReady?: try {
      guard case .integrationReady(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .hide?: try {
      guard case .hide(let v)? = self.hook else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_Hook, rhs: Local_Hook) -> Bool {
    if lhs.hook != rhs.hook {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegrationCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegrationCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if self.action != .install {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegrationCommand, rhs: Local_TerminalIntegrationCommand) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ListTerminalIntegrationsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTerminalIntegrationsCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ListTerminalIntegrationsCommand, rhs: Local_ListTerminalIntegrationsCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_LogoutCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_LogoutCommand, rhs: Local_LogoutCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_RestartCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestartCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_RestartCommand, rhs: Local_RestartCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_QuitCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuitCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_QuitCommand, rhs: Local_QuitCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_UpdateCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_UpdateCommand, rhs: Local_UpdateCommand) -> Bool {
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_DiagnosticsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiagnosticsCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_DiagnosticsCommand, rhs: Local_DiagnosticsCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ReportWindowCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportWindowCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "report"),
    2: .same(proto: "path"),
    3: .standard(proto: "fig_env_var"),
    4: .same(proto: "terminal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.report) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.figEnvVar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.terminal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.report.isEmpty {
      try visitor.visitSingularStringField(value: self.report, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.figEnvVar.isEmpty {
      try visitor.visitSingularStringField(value: self.figEnvVar, fieldNumber: 3)
    }
    if !self.terminal.isEmpty {
      try visitor.visitSingularStringField(value: self.terminal, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ReportWindowCommand, rhs: Local_ReportWindowCommand) -> Bool {
    if lhs.report != rhs.report {return false}
    if lhs.path != rhs.path {return false}
    if lhs.figEnvVar != rhs.figEnvVar {return false}
    if lhs.terminal != rhs.terminal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_RestartSettingsListenerCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestartSettingsListenerCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_RestartSettingsListenerCommand, rhs: Local_RestartSettingsListenerCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_RunInstallScriptCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunInstallScriptCommand"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_RunInstallScriptCommand, rhs: Local_RunInstallScriptCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ShellContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShellContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "ttys"),
    3: .same(proto: "shell"),
    4: .same(proto: "currentWorkingDirectory"),
    5: .same(proto: "sessionId"),
    6: .standard(proto: "integration_version"),
    7: .same(proto: "terminal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._pid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ttys) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._shell) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._currentWorkingDirectory) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._integrationVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._terminal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ttys {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shell {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._currentWorkingDirectory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._integrationVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._terminal {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ShellContext, rhs: Local_ShellContext) -> Bool {
    if lhs._pid != rhs._pid {return false}
    if lhs._ttys != rhs._ttys {return false}
    if lhs._shell != rhs._shell {return false}
    if lhs._currentWorkingDirectory != rhs._currentWorkingDirectory {return false}
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._integrationVersion != rhs._integrationVersion {return false}
    if lhs._terminal != rhs._terminal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_EditBufferHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditBufferHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "text"),
    3: .same(proto: "cursor"),
    4: .same(proto: "histno"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.cursor) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.histno) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.cursor != 0 {
      try visitor.visitSingularInt64Field(value: self.cursor, fieldNumber: 3)
    }
    if self.histno != 0 {
      try visitor.visitSingularInt64Field(value: self.histno, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_EditBufferHook, rhs: Local_EditBufferHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.text != rhs.text {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.histno != rhs.histno {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_InitHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .standard(proto: "called_direct"),
    3: .same(proto: "bundle"),
    100: .same(proto: "env"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.calledDirect) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bundle) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.env) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.calledDirect != false {
      try visitor.visitSingularBoolField(value: self.calledDirect, fieldNumber: 2)
    }
    if !self.bundle.isEmpty {
      try visitor.visitSingularStringField(value: self.bundle, fieldNumber: 3)
    }
    if !self.env.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.env, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_InitHook, rhs: Local_InitHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.calledDirect != rhs.calledDirect {return false}
    if lhs.bundle != rhs.bundle {return false}
    if lhs.env != rhs.env {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PromptHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PromptHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PromptHook, rhs: Local_PromptHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PreExecHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreExecHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PreExecHook, rhs: Local_PreExecHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_PostExecHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostExecHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "command"),
    3: .standard(proto: "exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_PostExecHook, rhs: Local_PostExecHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.command != rhs.command {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_KeyboardFocusChangedHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyboardFocusChangedHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_identifier"),
    2: .standard(proto: "focused_session"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.focusedSession) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleIdentifier, fieldNumber: 1)
    }
    if !self.focusedSession.isEmpty {
      try visitor.visitSingularStringField(value: self.focusedSession, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_KeyboardFocusChangedHook, rhs: Local_KeyboardFocusChangedHook) -> Bool {
    if lhs.bundleIdentifier != rhs.bundleIdentifier {return false}
    if lhs.focusedSession != rhs.focusedSession {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TmuxPaneChangedHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TmuxPaneChangedHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pane_identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.paneIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.paneIdentifier != 0 {
      try visitor.visitSingularInt32Field(value: self.paneIdentifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TmuxPaneChangedHook, rhs: Local_TmuxPaneChangedHook) -> Bool {
    if lhs.paneIdentifier != rhs.paneIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_OpenedSSHConnectionHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenedSSHConnectionHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .standard(proto: "control_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.controlPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.controlPath.isEmpty {
      try visitor.visitSingularStringField(value: self.controlPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_OpenedSSHConnectionHook, rhs: Local_OpenedSSHConnectionHook) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.controlPath != rhs.controlPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_CallbackHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallbackHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "handler_id"),
    2: .same(proto: "filepath"),
    3: .standard(proto: "exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.handlerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filepath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.handlerID.isEmpty {
      try visitor.visitSingularStringField(value: self.handlerID, fieldNumber: 1)
    }
    if !self.filepath.isEmpty {
      try visitor.visitSingularStringField(value: self.filepath, fieldNumber: 2)
    }
    if !self.exitCode.isEmpty {
      try visitor.visitSingularStringField(value: self.exitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_CallbackHook, rhs: Local_CallbackHook) -> Bool {
    if lhs.handlerID != rhs.handlerID {return false}
    if lhs.filepath != rhs.filepath {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_IntegrationReadyHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegrationReadyHook"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_IntegrationReadyHook, rhs: Local_IntegrationReadyHook) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_HideHook: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HideHook"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_HideHook, rhs: Local_HideHook) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_ErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exit_code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_ErrorResponse, rhs: Local_ErrorResponse) -> Bool {
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_SuccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuccessResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_SuccessResponse, rhs: Local_SuccessResponse) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_identifier"),
    2: .same(proto: "name"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.bundleIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleIdentifier, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._status {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegration, rhs: Local_TerminalIntegration) -> Bool {
    if lhs.bundleIdentifier != rhs.bundleIdentifier {return false}
    if lhs.name != rhs.name {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_TerminalIntegrationsListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalIntegrationsListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "integrations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.integrations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.integrations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.integrations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_TerminalIntegrationsListResponse, rhs: Local_TerminalIntegrationsListResponse) -> Bool {
    if lhs.integrations != rhs.integrations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_DiagnosticsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiagnosticsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_to_bundle"),
    2: .same(proto: "accessibility"),
    3: .same(proto: "keypath"),
    4: .same(proto: "docker"),
    5: .same(proto: "symlinked"),
    6: .same(proto: "onlytab"),
    7: .same(proto: "installscript"),
    8: .same(proto: "psudopath"),
    9: .same(proto: "securekeyboard"),
    10: .standard(proto: "securekeyboard_path"),
    11: .standard(proto: "current_process"),
    12: .standard(proto: "current_window_identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pathToBundle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessibility) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keypath) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.docker) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.symlinked) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.onlytab) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.installscript) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.psudopath) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.securekeyboard) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.securekeyboardPath) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.currentProcess) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.currentWindowIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathToBundle.isEmpty {
      try visitor.visitSingularStringField(value: self.pathToBundle, fieldNumber: 1)
    }
    if !self.accessibility.isEmpty {
      try visitor.visitSingularStringField(value: self.accessibility, fieldNumber: 2)
    }
    if !self.keypath.isEmpty {
      try visitor.visitSingularStringField(value: self.keypath, fieldNumber: 3)
    }
    if !self.docker.isEmpty {
      try visitor.visitSingularStringField(value: self.docker, fieldNumber: 4)
    }
    if !self.symlinked.isEmpty {
      try visitor.visitSingularStringField(value: self.symlinked, fieldNumber: 5)
    }
    if !self.onlytab.isEmpty {
      try visitor.visitSingularStringField(value: self.onlytab, fieldNumber: 6)
    }
    if !self.installscript.isEmpty {
      try visitor.visitSingularStringField(value: self.installscript, fieldNumber: 7)
    }
    if !self.psudopath.isEmpty {
      try visitor.visitSingularStringField(value: self.psudopath, fieldNumber: 8)
    }
    if !self.securekeyboard.isEmpty {
      try visitor.visitSingularStringField(value: self.securekeyboard, fieldNumber: 9)
    }
    if !self.securekeyboardPath.isEmpty {
      try visitor.visitSingularStringField(value: self.securekeyboardPath, fieldNumber: 10)
    }
    if !self.currentProcess.isEmpty {
      try visitor.visitSingularStringField(value: self.currentProcess, fieldNumber: 11)
    }
    if !self.currentWindowIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.currentWindowIdentifier, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_DiagnosticsResponse, rhs: Local_DiagnosticsResponse) -> Bool {
    if lhs.pathToBundle != rhs.pathToBundle {return false}
    if lhs.accessibility != rhs.accessibility {return false}
    if lhs.keypath != rhs.keypath {return false}
    if lhs.docker != rhs.docker {return false}
    if lhs.symlinked != rhs.symlinked {return false}
    if lhs.onlytab != rhs.onlytab {return false}
    if lhs.installscript != rhs.installscript {return false}
    if lhs.psudopath != rhs.psudopath {return false}
    if lhs.securekeyboard != rhs.securekeyboard {return false}
    if lhs.securekeyboardPath != rhs.securekeyboardPath {return false}
    if lhs.currentProcess != rhs.currentProcess {return false}
    if lhs.currentWindowIdentifier != rhs.currentWindowIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Local_CommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
    100: .standard(proto: "integration_list"),
    101: .same(proto: "diagnostics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try {
        var v: Local_ErrorResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 3: try {
        var v: Local_SuccessResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 100: try {
        var v: Local_TerminalIntegrationsListResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .integrationList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .integrationList(v)
        }
      }()
      case 101: try {
        var v: Local_DiagnosticsResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .diagnostics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .diagnostics(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .integrationList?: try {
      guard case .integrationList(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .diagnostics?: try {
      guard case .diagnostics(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Local_CommandResponse, rhs: Local_CommandResponse) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
