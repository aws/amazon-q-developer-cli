// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Iterm2_SelectionMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case character // = 0
  case word // = 1
  case line // = 2
  case smart // = 3
  case box // = 4
  case wholeLine // = 5

  init() {
    self = .character
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .character
    case 1: self = .word
    case 2: self = .line
    case 3: self = .smart
    case 4: self = .box
    case 5: self = .wholeLine
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .character: return 0
    case .word: return 1
    case .line: return 2
    case .smart: return 3
    case .box: return 4
    case .wholeLine: return 5
    }
  }

}

#if swift(>=4.2)

extension Iterm2_SelectionMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Iterm2_NotificationType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Notifications that use the `session` parameter.
  case notifyOnKeystroke // = 1
  case notifyOnScreenUpdate // = 2
  case notifyOnPrompt // = 3
  case notifyOnLocationChange // = 4
  case notifyOnCustomEscapeSequence // = 5
  case notifyOnVariableChange // = 12

  /// Does not send a notification
  case keystrokeFilter // = 14

  /// Notifications that ignore the `session` parameter.
  case notifyOnNewSession // = 6
  case notifyOnTerminateSession // = 7
  case notifyOnLayoutChange // = 8
  case notifyOnFocusChange // = 9
  case notifyOnServerOriginatedRpc // = 10
  case notifyOnBroadcastChange // = 11
  case notifyOnProfileChange // = 13

  init() {
    self = .notifyOnKeystroke
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .notifyOnKeystroke
    case 2: self = .notifyOnScreenUpdate
    case 3: self = .notifyOnPrompt
    case 4: self = .notifyOnLocationChange
    case 5: self = .notifyOnCustomEscapeSequence
    case 6: self = .notifyOnNewSession
    case 7: self = .notifyOnTerminateSession
    case 8: self = .notifyOnLayoutChange
    case 9: self = .notifyOnFocusChange
    case 10: self = .notifyOnServerOriginatedRpc
    case 11: self = .notifyOnBroadcastChange
    case 12: self = .notifyOnVariableChange
    case 13: self = .notifyOnProfileChange
    case 14: self = .keystrokeFilter
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .notifyOnKeystroke: return 1
    case .notifyOnScreenUpdate: return 2
    case .notifyOnPrompt: return 3
    case .notifyOnLocationChange: return 4
    case .notifyOnCustomEscapeSequence: return 5
    case .notifyOnNewSession: return 6
    case .notifyOnTerminateSession: return 7
    case .notifyOnLayoutChange: return 8
    case .notifyOnFocusChange: return 9
    case .notifyOnServerOriginatedRpc: return 10
    case .notifyOnBroadcastChange: return 11
    case .notifyOnVariableChange: return 12
    case .notifyOnProfileChange: return 13
    case .keystrokeFilter: return 14
    }
  }

}

#if swift(>=4.2)

extension Iterm2_NotificationType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Iterm2_Modifiers: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case control // = 1
  case option // = 2
  case command // = 3
  case shift // = 4
  case function // = 5
  case numpad // = 6

  init() {
    self = .control
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .control
    case 2: self = .option
    case 3: self = .command
    case 4: self = .shift
    case 5: self = .function
    case 6: self = .numpad
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .control: return 1
    case .option: return 2
    case .command: return 3
    case .shift: return 4
    case .function: return 5
    case .numpad: return 6
    }
  }

}

#if swift(>=4.2)

extension Iterm2_Modifiers: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Iterm2_VariableScope: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case session // = 1
  case tab // = 2
  case window // = 3
  case app // = 4

  init() {
    self = .session
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .session
    case 2: self = .tab
    case 3: self = .window
    case 4: self = .app
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .session: return 1
    case .tab: return 2
    case .window: return 3
    case .app: return 4
    }
  }

}

#if swift(>=4.2)

extension Iterm2_VariableScope: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Iterm2_PromptMonitorMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case prompt // = 1
  case commandStart // = 2
  case commandEnd // = 3

  init() {
    self = .prompt
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .prompt
    case 2: self = .commandStart
    case 3: self = .commandEnd
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .prompt: return 1
    case .commandStart: return 2
    case .commandEnd: return 3
    }
  }

}

#if swift(>=4.2)

extension Iterm2_PromptMonitorMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// All requests are wrapped in this message. This encoded message is the entirety of the payload
/// of messages sent over WebSocket from client to iTerm2.
struct Iterm2_ClientOriginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _storage._id ?? 0}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var submessage: OneOf_Submessage? {
    get {return _storage._submessage}
    set {_uniqueStorage()._submessage = newValue}
  }

  var getBufferRequest: Iterm2_GetBufferRequest {
    get {
      if case .getBufferRequest(let v)? = _storage._submessage {return v}
      return Iterm2_GetBufferRequest()
    }
    set {_uniqueStorage()._submessage = .getBufferRequest(newValue)}
  }

  var getPromptRequest: Iterm2_GetPromptRequest {
    get {
      if case .getPromptRequest(let v)? = _storage._submessage {return v}
      return Iterm2_GetPromptRequest()
    }
    set {_uniqueStorage()._submessage = .getPromptRequest(newValue)}
  }

  var transactionRequest: Iterm2_TransactionRequest {
    get {
      if case .transactionRequest(let v)? = _storage._submessage {return v}
      return Iterm2_TransactionRequest()
    }
    set {_uniqueStorage()._submessage = .transactionRequest(newValue)}
  }

  var notificationRequest: Iterm2_NotificationRequest {
    get {
      if case .notificationRequest(let v)? = _storage._submessage {return v}
      return Iterm2_NotificationRequest()
    }
    set {_uniqueStorage()._submessage = .notificationRequest(newValue)}
  }

  var registerToolRequest: Iterm2_RegisterToolRequest {
    get {
      if case .registerToolRequest(let v)? = _storage._submessage {return v}
      return Iterm2_RegisterToolRequest()
    }
    set {_uniqueStorage()._submessage = .registerToolRequest(newValue)}
  }

  var setProfilePropertyRequest: Iterm2_SetProfilePropertyRequest {
    get {
      if case .setProfilePropertyRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SetProfilePropertyRequest()
    }
    set {_uniqueStorage()._submessage = .setProfilePropertyRequest(newValue)}
  }

  var listSessionsRequest: Iterm2_ListSessionsRequest {
    get {
      if case .listSessionsRequest(let v)? = _storage._submessage {return v}
      return Iterm2_ListSessionsRequest()
    }
    set {_uniqueStorage()._submessage = .listSessionsRequest(newValue)}
  }

  var sendTextRequest: Iterm2_SendTextRequest {
    get {
      if case .sendTextRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SendTextRequest()
    }
    set {_uniqueStorage()._submessage = .sendTextRequest(newValue)}
  }

  var createTabRequest: Iterm2_CreateTabRequest {
    get {
      if case .createTabRequest(let v)? = _storage._submessage {return v}
      return Iterm2_CreateTabRequest()
    }
    set {_uniqueStorage()._submessage = .createTabRequest(newValue)}
  }

  var splitPaneRequest: Iterm2_SplitPaneRequest {
    get {
      if case .splitPaneRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SplitPaneRequest()
    }
    set {_uniqueStorage()._submessage = .splitPaneRequest(newValue)}
  }

  var getProfilePropertyRequest: Iterm2_GetProfilePropertyRequest {
    get {
      if case .getProfilePropertyRequest(let v)? = _storage._submessage {return v}
      return Iterm2_GetProfilePropertyRequest()
    }
    set {_uniqueStorage()._submessage = .getProfilePropertyRequest(newValue)}
  }

  var setPropertyRequest: Iterm2_SetPropertyRequest {
    get {
      if case .setPropertyRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SetPropertyRequest()
    }
    set {_uniqueStorage()._submessage = .setPropertyRequest(newValue)}
  }

  var getPropertyRequest: Iterm2_GetPropertyRequest {
    get {
      if case .getPropertyRequest(let v)? = _storage._submessage {return v}
      return Iterm2_GetPropertyRequest()
    }
    set {_uniqueStorage()._submessage = .getPropertyRequest(newValue)}
  }

  var injectRequest: Iterm2_InjectRequest {
    get {
      if case .injectRequest(let v)? = _storage._submessage {return v}
      return Iterm2_InjectRequest()
    }
    set {_uniqueStorage()._submessage = .injectRequest(newValue)}
  }

  var activateRequest: Iterm2_ActivateRequest {
    get {
      if case .activateRequest(let v)? = _storage._submessage {return v}
      return Iterm2_ActivateRequest()
    }
    set {_uniqueStorage()._submessage = .activateRequest(newValue)}
  }

  var variableRequest: Iterm2_VariableRequest {
    get {
      if case .variableRequest(let v)? = _storage._submessage {return v}
      return Iterm2_VariableRequest()
    }
    set {_uniqueStorage()._submessage = .variableRequest(newValue)}
  }

  var savedArrangementRequest: Iterm2_SavedArrangementRequest {
    get {
      if case .savedArrangementRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SavedArrangementRequest()
    }
    set {_uniqueStorage()._submessage = .savedArrangementRequest(newValue)}
  }

  var focusRequest: Iterm2_FocusRequest {
    get {
      if case .focusRequest(let v)? = _storage._submessage {return v}
      return Iterm2_FocusRequest()
    }
    set {_uniqueStorage()._submessage = .focusRequest(newValue)}
  }

  var listProfilesRequest: Iterm2_ListProfilesRequest {
    get {
      if case .listProfilesRequest(let v)? = _storage._submessage {return v}
      return Iterm2_ListProfilesRequest()
    }
    set {_uniqueStorage()._submessage = .listProfilesRequest(newValue)}
  }

  var serverOriginatedRpcResultRequest: Iterm2_ServerOriginatedRPCResultRequest {
    get {
      if case .serverOriginatedRpcResultRequest(let v)? = _storage._submessage {return v}
      return Iterm2_ServerOriginatedRPCResultRequest()
    }
    set {_uniqueStorage()._submessage = .serverOriginatedRpcResultRequest(newValue)}
  }

  var restartSessionRequest: Iterm2_RestartSessionRequest {
    get {
      if case .restartSessionRequest(let v)? = _storage._submessage {return v}
      return Iterm2_RestartSessionRequest()
    }
    set {_uniqueStorage()._submessage = .restartSessionRequest(newValue)}
  }

  var menuItemRequest: Iterm2_MenuItemRequest {
    get {
      if case .menuItemRequest(let v)? = _storage._submessage {return v}
      return Iterm2_MenuItemRequest()
    }
    set {_uniqueStorage()._submessage = .menuItemRequest(newValue)}
  }

  var setTabLayoutRequest: Iterm2_SetTabLayoutRequest {
    get {
      if case .setTabLayoutRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SetTabLayoutRequest()
    }
    set {_uniqueStorage()._submessage = .setTabLayoutRequest(newValue)}
  }

  var getBroadcastDomainsRequest: Iterm2_GetBroadcastDomainsRequest {
    get {
      if case .getBroadcastDomainsRequest(let v)? = _storage._submessage {return v}
      return Iterm2_GetBroadcastDomainsRequest()
    }
    set {_uniqueStorage()._submessage = .getBroadcastDomainsRequest(newValue)}
  }

  var tmuxRequest: Iterm2_TmuxRequest {
    get {
      if case .tmuxRequest(let v)? = _storage._submessage {return v}
      return Iterm2_TmuxRequest()
    }
    set {_uniqueStorage()._submessage = .tmuxRequest(newValue)}
  }

  var reorderTabsRequest: Iterm2_ReorderTabsRequest {
    get {
      if case .reorderTabsRequest(let v)? = _storage._submessage {return v}
      return Iterm2_ReorderTabsRequest()
    }
    set {_uniqueStorage()._submessage = .reorderTabsRequest(newValue)}
  }

  var preferencesRequest: Iterm2_PreferencesRequest {
    get {
      if case .preferencesRequest(let v)? = _storage._submessage {return v}
      return Iterm2_PreferencesRequest()
    }
    set {_uniqueStorage()._submessage = .preferencesRequest(newValue)}
  }

  var colorPresetRequest: Iterm2_ColorPresetRequest {
    get {
      if case .colorPresetRequest(let v)? = _storage._submessage {return v}
      return Iterm2_ColorPresetRequest()
    }
    set {_uniqueStorage()._submessage = .colorPresetRequest(newValue)}
  }

  var selectionRequest: Iterm2_SelectionRequest {
    get {
      if case .selectionRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SelectionRequest()
    }
    set {_uniqueStorage()._submessage = .selectionRequest(newValue)}
  }

  var statusBarComponentRequest: Iterm2_StatusBarComponentRequest {
    get {
      if case .statusBarComponentRequest(let v)? = _storage._submessage {return v}
      return Iterm2_StatusBarComponentRequest()
    }
    set {_uniqueStorage()._submessage = .statusBarComponentRequest(newValue)}
  }

  var setBroadcastDomainsRequest: Iterm2_SetBroadcastDomainsRequest {
    get {
      if case .setBroadcastDomainsRequest(let v)? = _storage._submessage {return v}
      return Iterm2_SetBroadcastDomainsRequest()
    }
    set {_uniqueStorage()._submessage = .setBroadcastDomainsRequest(newValue)}
  }

  var closeRequest: Iterm2_CloseRequest {
    get {
      if case .closeRequest(let v)? = _storage._submessage {return v}
      return Iterm2_CloseRequest()
    }
    set {_uniqueStorage()._submessage = .closeRequest(newValue)}
  }

  var invokeFunctionRequest: Iterm2_InvokeFunctionRequest {
    get {
      if case .invokeFunctionRequest(let v)? = _storage._submessage {return v}
      return Iterm2_InvokeFunctionRequest()
    }
    set {_uniqueStorage()._submessage = .invokeFunctionRequest(newValue)}
  }

  var listPromptsRequest: Iterm2_ListPromptsRequest {
    get {
      if case .listPromptsRequest(let v)? = _storage._submessage {return v}
      return Iterm2_ListPromptsRequest()
    }
    set {_uniqueStorage()._submessage = .listPromptsRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Submessage: Equatable {
    case getBufferRequest(Iterm2_GetBufferRequest)
    case getPromptRequest(Iterm2_GetPromptRequest)
    case transactionRequest(Iterm2_TransactionRequest)
    case notificationRequest(Iterm2_NotificationRequest)
    case registerToolRequest(Iterm2_RegisterToolRequest)
    case setProfilePropertyRequest(Iterm2_SetProfilePropertyRequest)
    case listSessionsRequest(Iterm2_ListSessionsRequest)
    case sendTextRequest(Iterm2_SendTextRequest)
    case createTabRequest(Iterm2_CreateTabRequest)
    case splitPaneRequest(Iterm2_SplitPaneRequest)
    case getProfilePropertyRequest(Iterm2_GetProfilePropertyRequest)
    case setPropertyRequest(Iterm2_SetPropertyRequest)
    case getPropertyRequest(Iterm2_GetPropertyRequest)
    case injectRequest(Iterm2_InjectRequest)
    case activateRequest(Iterm2_ActivateRequest)
    case variableRequest(Iterm2_VariableRequest)
    case savedArrangementRequest(Iterm2_SavedArrangementRequest)
    case focusRequest(Iterm2_FocusRequest)
    case listProfilesRequest(Iterm2_ListProfilesRequest)
    case serverOriginatedRpcResultRequest(Iterm2_ServerOriginatedRPCResultRequest)
    case restartSessionRequest(Iterm2_RestartSessionRequest)
    case menuItemRequest(Iterm2_MenuItemRequest)
    case setTabLayoutRequest(Iterm2_SetTabLayoutRequest)
    case getBroadcastDomainsRequest(Iterm2_GetBroadcastDomainsRequest)
    case tmuxRequest(Iterm2_TmuxRequest)
    case reorderTabsRequest(Iterm2_ReorderTabsRequest)
    case preferencesRequest(Iterm2_PreferencesRequest)
    case colorPresetRequest(Iterm2_ColorPresetRequest)
    case selectionRequest(Iterm2_SelectionRequest)
    case statusBarComponentRequest(Iterm2_StatusBarComponentRequest)
    case setBroadcastDomainsRequest(Iterm2_SetBroadcastDomainsRequest)
    case closeRequest(Iterm2_CloseRequest)
    case invokeFunctionRequest(Iterm2_InvokeFunctionRequest)
    case listPromptsRequest(Iterm2_ListPromptsRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_ClientOriginatedMessage.OneOf_Submessage, rhs: Iterm2_ClientOriginatedMessage.OneOf_Submessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getBufferRequest, .getBufferRequest): return {
        guard case .getBufferRequest(let l) = lhs, case .getBufferRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getPromptRequest, .getPromptRequest): return {
        guard case .getPromptRequest(let l) = lhs, case .getPromptRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transactionRequest, .transactionRequest): return {
        guard case .transactionRequest(let l) = lhs, case .transactionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationRequest, .notificationRequest): return {
        guard case .notificationRequest(let l) = lhs, case .notificationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.registerToolRequest, .registerToolRequest): return {
        guard case .registerToolRequest(let l) = lhs, case .registerToolRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setProfilePropertyRequest, .setProfilePropertyRequest): return {
        guard case .setProfilePropertyRequest(let l) = lhs, case .setProfilePropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listSessionsRequest, .listSessionsRequest): return {
        guard case .listSessionsRequest(let l) = lhs, case .listSessionsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendTextRequest, .sendTextRequest): return {
        guard case .sendTextRequest(let l) = lhs, case .sendTextRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createTabRequest, .createTabRequest): return {
        guard case .createTabRequest(let l) = lhs, case .createTabRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.splitPaneRequest, .splitPaneRequest): return {
        guard case .splitPaneRequest(let l) = lhs, case .splitPaneRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getProfilePropertyRequest, .getProfilePropertyRequest): return {
        guard case .getProfilePropertyRequest(let l) = lhs, case .getProfilePropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setPropertyRequest, .setPropertyRequest): return {
        guard case .setPropertyRequest(let l) = lhs, case .setPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getPropertyRequest, .getPropertyRequest): return {
        guard case .getPropertyRequest(let l) = lhs, case .getPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.injectRequest, .injectRequest): return {
        guard case .injectRequest(let l) = lhs, case .injectRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activateRequest, .activateRequest): return {
        guard case .activateRequest(let l) = lhs, case .activateRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.variableRequest, .variableRequest): return {
        guard case .variableRequest(let l) = lhs, case .variableRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.savedArrangementRequest, .savedArrangementRequest): return {
        guard case .savedArrangementRequest(let l) = lhs, case .savedArrangementRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.focusRequest, .focusRequest): return {
        guard case .focusRequest(let l) = lhs, case .focusRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listProfilesRequest, .listProfilesRequest): return {
        guard case .listProfilesRequest(let l) = lhs, case .listProfilesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serverOriginatedRpcResultRequest, .serverOriginatedRpcResultRequest): return {
        guard case .serverOriginatedRpcResultRequest(let l) = lhs, case .serverOriginatedRpcResultRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restartSessionRequest, .restartSessionRequest): return {
        guard case .restartSessionRequest(let l) = lhs, case .restartSessionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.menuItemRequest, .menuItemRequest): return {
        guard case .menuItemRequest(let l) = lhs, case .menuItemRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setTabLayoutRequest, .setTabLayoutRequest): return {
        guard case .setTabLayoutRequest(let l) = lhs, case .setTabLayoutRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBroadcastDomainsRequest, .getBroadcastDomainsRequest): return {
        guard case .getBroadcastDomainsRequest(let l) = lhs, case .getBroadcastDomainsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tmuxRequest, .tmuxRequest): return {
        guard case .tmuxRequest(let l) = lhs, case .tmuxRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reorderTabsRequest, .reorderTabsRequest): return {
        guard case .reorderTabsRequest(let l) = lhs, case .reorderTabsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preferencesRequest, .preferencesRequest): return {
        guard case .preferencesRequest(let l) = lhs, case .preferencesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.colorPresetRequest, .colorPresetRequest): return {
        guard case .colorPresetRequest(let l) = lhs, case .colorPresetRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.selectionRequest, .selectionRequest): return {
        guard case .selectionRequest(let l) = lhs, case .selectionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusBarComponentRequest, .statusBarComponentRequest): return {
        guard case .statusBarComponentRequest(let l) = lhs, case .statusBarComponentRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setBroadcastDomainsRequest, .setBroadcastDomainsRequest): return {
        guard case .setBroadcastDomainsRequest(let l) = lhs, case .setBroadcastDomainsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closeRequest, .closeRequest): return {
        guard case .closeRequest(let l) = lhs, case .closeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invokeFunctionRequest, .invokeFunctionRequest): return {
        guard case .invokeFunctionRequest(let l) = lhs, case .invokeFunctionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listPromptsRequest, .listPromptsRequest): return {
        guard case .listPromptsRequest(let l) = lhs, case .listPromptsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// All responses are wrapped in this message. This encoded message is the entirety of the payload
/// of messages sent over WebSocket from iTerm2 to client.
struct Iterm2_ServerOriginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// Responses to ClientOriginatedMessages of the corresponding type
  var submessage: Iterm2_ServerOriginatedMessage.OneOf_Submessage? = nil

  /// Set if request was malformed
  var error: String {
    get {
      if case .error(let v)? = submessage {return v}
      return String()
    }
    set {submessage = .error(newValue)}
  }

  var getBufferResponse: Iterm2_GetBufferResponse {
    get {
      if case .getBufferResponse(let v)? = submessage {return v}
      return Iterm2_GetBufferResponse()
    }
    set {submessage = .getBufferResponse(newValue)}
  }

  var getPromptResponse: Iterm2_GetPromptResponse {
    get {
      if case .getPromptResponse(let v)? = submessage {return v}
      return Iterm2_GetPromptResponse()
    }
    set {submessage = .getPromptResponse(newValue)}
  }

  var transactionResponse: Iterm2_TransactionResponse {
    get {
      if case .transactionResponse(let v)? = submessage {return v}
      return Iterm2_TransactionResponse()
    }
    set {submessage = .transactionResponse(newValue)}
  }

  var notificationResponse: Iterm2_NotificationResponse {
    get {
      if case .notificationResponse(let v)? = submessage {return v}
      return Iterm2_NotificationResponse()
    }
    set {submessage = .notificationResponse(newValue)}
  }

  var registerToolResponse: Iterm2_RegisterToolResponse {
    get {
      if case .registerToolResponse(let v)? = submessage {return v}
      return Iterm2_RegisterToolResponse()
    }
    set {submessage = .registerToolResponse(newValue)}
  }

  var setProfilePropertyResponse: Iterm2_SetProfilePropertyResponse {
    get {
      if case .setProfilePropertyResponse(let v)? = submessage {return v}
      return Iterm2_SetProfilePropertyResponse()
    }
    set {submessage = .setProfilePropertyResponse(newValue)}
  }

  var listSessionsResponse: Iterm2_ListSessionsResponse {
    get {
      if case .listSessionsResponse(let v)? = submessage {return v}
      return Iterm2_ListSessionsResponse()
    }
    set {submessage = .listSessionsResponse(newValue)}
  }

  var sendTextResponse: Iterm2_SendTextResponse {
    get {
      if case .sendTextResponse(let v)? = submessage {return v}
      return Iterm2_SendTextResponse()
    }
    set {submessage = .sendTextResponse(newValue)}
  }

  var createTabResponse: Iterm2_CreateTabResponse {
    get {
      if case .createTabResponse(let v)? = submessage {return v}
      return Iterm2_CreateTabResponse()
    }
    set {submessage = .createTabResponse(newValue)}
  }

  var splitPaneResponse: Iterm2_SplitPaneResponse {
    get {
      if case .splitPaneResponse(let v)? = submessage {return v}
      return Iterm2_SplitPaneResponse()
    }
    set {submessage = .splitPaneResponse(newValue)}
  }

  var getProfilePropertyResponse: Iterm2_GetProfilePropertyResponse {
    get {
      if case .getProfilePropertyResponse(let v)? = submessage {return v}
      return Iterm2_GetProfilePropertyResponse()
    }
    set {submessage = .getProfilePropertyResponse(newValue)}
  }

  var setPropertyResponse: Iterm2_SetPropertyResponse {
    get {
      if case .setPropertyResponse(let v)? = submessage {return v}
      return Iterm2_SetPropertyResponse()
    }
    set {submessage = .setPropertyResponse(newValue)}
  }

  var getPropertyResponse: Iterm2_GetPropertyResponse {
    get {
      if case .getPropertyResponse(let v)? = submessage {return v}
      return Iterm2_GetPropertyResponse()
    }
    set {submessage = .getPropertyResponse(newValue)}
  }

  var injectResponse: Iterm2_InjectResponse {
    get {
      if case .injectResponse(let v)? = submessage {return v}
      return Iterm2_InjectResponse()
    }
    set {submessage = .injectResponse(newValue)}
  }

  var activateResponse: Iterm2_ActivateResponse {
    get {
      if case .activateResponse(let v)? = submessage {return v}
      return Iterm2_ActivateResponse()
    }
    set {submessage = .activateResponse(newValue)}
  }

  var variableResponse: Iterm2_VariableResponse {
    get {
      if case .variableResponse(let v)? = submessage {return v}
      return Iterm2_VariableResponse()
    }
    set {submessage = .variableResponse(newValue)}
  }

  var savedArrangementResponse: Iterm2_SavedArrangementResponse {
    get {
      if case .savedArrangementResponse(let v)? = submessage {return v}
      return Iterm2_SavedArrangementResponse()
    }
    set {submessage = .savedArrangementResponse(newValue)}
  }

  var focusResponse: Iterm2_FocusResponse {
    get {
      if case .focusResponse(let v)? = submessage {return v}
      return Iterm2_FocusResponse()
    }
    set {submessage = .focusResponse(newValue)}
  }

  var listProfilesResponse: Iterm2_ListProfilesResponse {
    get {
      if case .listProfilesResponse(let v)? = submessage {return v}
      return Iterm2_ListProfilesResponse()
    }
    set {submessage = .listProfilesResponse(newValue)}
  }

  var serverOriginatedRpcResultResponse: Iterm2_ServerOriginatedRPCResultResponse {
    get {
      if case .serverOriginatedRpcResultResponse(let v)? = submessage {return v}
      return Iterm2_ServerOriginatedRPCResultResponse()
    }
    set {submessage = .serverOriginatedRpcResultResponse(newValue)}
  }

  var restartSessionResponse: Iterm2_RestartSessionResponse {
    get {
      if case .restartSessionResponse(let v)? = submessage {return v}
      return Iterm2_RestartSessionResponse()
    }
    set {submessage = .restartSessionResponse(newValue)}
  }

  var menuItemResponse: Iterm2_MenuItemResponse {
    get {
      if case .menuItemResponse(let v)? = submessage {return v}
      return Iterm2_MenuItemResponse()
    }
    set {submessage = .menuItemResponse(newValue)}
  }

  var setTabLayoutResponse: Iterm2_SetTabLayoutResponse {
    get {
      if case .setTabLayoutResponse(let v)? = submessage {return v}
      return Iterm2_SetTabLayoutResponse()
    }
    set {submessage = .setTabLayoutResponse(newValue)}
  }

  var getBroadcastDomainsResponse: Iterm2_GetBroadcastDomainsResponse {
    get {
      if case .getBroadcastDomainsResponse(let v)? = submessage {return v}
      return Iterm2_GetBroadcastDomainsResponse()
    }
    set {submessage = .getBroadcastDomainsResponse(newValue)}
  }

  var tmuxResponse: Iterm2_TmuxResponse {
    get {
      if case .tmuxResponse(let v)? = submessage {return v}
      return Iterm2_TmuxResponse()
    }
    set {submessage = .tmuxResponse(newValue)}
  }

  var reorderTabsResponse: Iterm2_ReorderTabsResponse {
    get {
      if case .reorderTabsResponse(let v)? = submessage {return v}
      return Iterm2_ReorderTabsResponse()
    }
    set {submessage = .reorderTabsResponse(newValue)}
  }

  var preferencesResponse: Iterm2_PreferencesResponse {
    get {
      if case .preferencesResponse(let v)? = submessage {return v}
      return Iterm2_PreferencesResponse()
    }
    set {submessage = .preferencesResponse(newValue)}
  }

  var colorPresetResponse: Iterm2_ColorPresetResponse {
    get {
      if case .colorPresetResponse(let v)? = submessage {return v}
      return Iterm2_ColorPresetResponse()
    }
    set {submessage = .colorPresetResponse(newValue)}
  }

  var selectionResponse: Iterm2_SelectionResponse {
    get {
      if case .selectionResponse(let v)? = submessage {return v}
      return Iterm2_SelectionResponse()
    }
    set {submessage = .selectionResponse(newValue)}
  }

  var statusBarComponentResponse: Iterm2_StatusBarComponentResponse {
    get {
      if case .statusBarComponentResponse(let v)? = submessage {return v}
      return Iterm2_StatusBarComponentResponse()
    }
    set {submessage = .statusBarComponentResponse(newValue)}
  }

  var setBroadcastDomainsResponse: Iterm2_SetBroadcastDomainsResponse {
    get {
      if case .setBroadcastDomainsResponse(let v)? = submessage {return v}
      return Iterm2_SetBroadcastDomainsResponse()
    }
    set {submessage = .setBroadcastDomainsResponse(newValue)}
  }

  var closeResponse: Iterm2_CloseResponse {
    get {
      if case .closeResponse(let v)? = submessage {return v}
      return Iterm2_CloseResponse()
    }
    set {submessage = .closeResponse(newValue)}
  }

  var invokeFunctionResponse: Iterm2_InvokeFunctionResponse {
    get {
      if case .invokeFunctionResponse(let v)? = submessage {return v}
      return Iterm2_InvokeFunctionResponse()
    }
    set {submessage = .invokeFunctionResponse(newValue)}
  }

  var listPromptsResponse: Iterm2_ListPromptsResponse {
    get {
      if case .listPromptsResponse(let v)? = submessage {return v}
      return Iterm2_ListPromptsResponse()
    }
    set {submessage = .listPromptsResponse(newValue)}
  }

  /// This is the only response that is sent spontaneously. The 'id' field will not be set.
  var notification: Iterm2_Notification {
    get {
      if case .notification(let v)? = submessage {return v}
      return Iterm2_Notification()
    }
    set {submessage = .notification(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Responses to ClientOriginatedMessages of the corresponding type
  enum OneOf_Submessage: Equatable {
    /// Set if request was malformed
    case error(String)
    case getBufferResponse(Iterm2_GetBufferResponse)
    case getPromptResponse(Iterm2_GetPromptResponse)
    case transactionResponse(Iterm2_TransactionResponse)
    case notificationResponse(Iterm2_NotificationResponse)
    case registerToolResponse(Iterm2_RegisterToolResponse)
    case setProfilePropertyResponse(Iterm2_SetProfilePropertyResponse)
    case listSessionsResponse(Iterm2_ListSessionsResponse)
    case sendTextResponse(Iterm2_SendTextResponse)
    case createTabResponse(Iterm2_CreateTabResponse)
    case splitPaneResponse(Iterm2_SplitPaneResponse)
    case getProfilePropertyResponse(Iterm2_GetProfilePropertyResponse)
    case setPropertyResponse(Iterm2_SetPropertyResponse)
    case getPropertyResponse(Iterm2_GetPropertyResponse)
    case injectResponse(Iterm2_InjectResponse)
    case activateResponse(Iterm2_ActivateResponse)
    case variableResponse(Iterm2_VariableResponse)
    case savedArrangementResponse(Iterm2_SavedArrangementResponse)
    case focusResponse(Iterm2_FocusResponse)
    case listProfilesResponse(Iterm2_ListProfilesResponse)
    case serverOriginatedRpcResultResponse(Iterm2_ServerOriginatedRPCResultResponse)
    case restartSessionResponse(Iterm2_RestartSessionResponse)
    case menuItemResponse(Iterm2_MenuItemResponse)
    case setTabLayoutResponse(Iterm2_SetTabLayoutResponse)
    case getBroadcastDomainsResponse(Iterm2_GetBroadcastDomainsResponse)
    case tmuxResponse(Iterm2_TmuxResponse)
    case reorderTabsResponse(Iterm2_ReorderTabsResponse)
    case preferencesResponse(Iterm2_PreferencesResponse)
    case colorPresetResponse(Iterm2_ColorPresetResponse)
    case selectionResponse(Iterm2_SelectionResponse)
    case statusBarComponentResponse(Iterm2_StatusBarComponentResponse)
    case setBroadcastDomainsResponse(Iterm2_SetBroadcastDomainsResponse)
    case closeResponse(Iterm2_CloseResponse)
    case invokeFunctionResponse(Iterm2_InvokeFunctionResponse)
    case listPromptsResponse(Iterm2_ListPromptsResponse)
    /// This is the only response that is sent spontaneously. The 'id' field will not be set.
    case notification(Iterm2_Notification)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_ServerOriginatedMessage.OneOf_Submessage, rhs: Iterm2_ServerOriginatedMessage.OneOf_Submessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBufferResponse, .getBufferResponse): return {
        guard case .getBufferResponse(let l) = lhs, case .getBufferResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getPromptResponse, .getPromptResponse): return {
        guard case .getPromptResponse(let l) = lhs, case .getPromptResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transactionResponse, .transactionResponse): return {
        guard case .transactionResponse(let l) = lhs, case .transactionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationResponse, .notificationResponse): return {
        guard case .notificationResponse(let l) = lhs, case .notificationResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.registerToolResponse, .registerToolResponse): return {
        guard case .registerToolResponse(let l) = lhs, case .registerToolResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setProfilePropertyResponse, .setProfilePropertyResponse): return {
        guard case .setProfilePropertyResponse(let l) = lhs, case .setProfilePropertyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listSessionsResponse, .listSessionsResponse): return {
        guard case .listSessionsResponse(let l) = lhs, case .listSessionsResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendTextResponse, .sendTextResponse): return {
        guard case .sendTextResponse(let l) = lhs, case .sendTextResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createTabResponse, .createTabResponse): return {
        guard case .createTabResponse(let l) = lhs, case .createTabResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.splitPaneResponse, .splitPaneResponse): return {
        guard case .splitPaneResponse(let l) = lhs, case .splitPaneResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getProfilePropertyResponse, .getProfilePropertyResponse): return {
        guard case .getProfilePropertyResponse(let l) = lhs, case .getProfilePropertyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setPropertyResponse, .setPropertyResponse): return {
        guard case .setPropertyResponse(let l) = lhs, case .setPropertyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getPropertyResponse, .getPropertyResponse): return {
        guard case .getPropertyResponse(let l) = lhs, case .getPropertyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.injectResponse, .injectResponse): return {
        guard case .injectResponse(let l) = lhs, case .injectResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activateResponse, .activateResponse): return {
        guard case .activateResponse(let l) = lhs, case .activateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.variableResponse, .variableResponse): return {
        guard case .variableResponse(let l) = lhs, case .variableResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.savedArrangementResponse, .savedArrangementResponse): return {
        guard case .savedArrangementResponse(let l) = lhs, case .savedArrangementResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.focusResponse, .focusResponse): return {
        guard case .focusResponse(let l) = lhs, case .focusResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listProfilesResponse, .listProfilesResponse): return {
        guard case .listProfilesResponse(let l) = lhs, case .listProfilesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.serverOriginatedRpcResultResponse, .serverOriginatedRpcResultResponse): return {
        guard case .serverOriginatedRpcResultResponse(let l) = lhs, case .serverOriginatedRpcResultResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restartSessionResponse, .restartSessionResponse): return {
        guard case .restartSessionResponse(let l) = lhs, case .restartSessionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.menuItemResponse, .menuItemResponse): return {
        guard case .menuItemResponse(let l) = lhs, case .menuItemResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setTabLayoutResponse, .setTabLayoutResponse): return {
        guard case .setTabLayoutResponse(let l) = lhs, case .setTabLayoutResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getBroadcastDomainsResponse, .getBroadcastDomainsResponse): return {
        guard case .getBroadcastDomainsResponse(let l) = lhs, case .getBroadcastDomainsResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tmuxResponse, .tmuxResponse): return {
        guard case .tmuxResponse(let l) = lhs, case .tmuxResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reorderTabsResponse, .reorderTabsResponse): return {
        guard case .reorderTabsResponse(let l) = lhs, case .reorderTabsResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preferencesResponse, .preferencesResponse): return {
        guard case .preferencesResponse(let l) = lhs, case .preferencesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.colorPresetResponse, .colorPresetResponse): return {
        guard case .colorPresetResponse(let l) = lhs, case .colorPresetResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.selectionResponse, .selectionResponse): return {
        guard case .selectionResponse(let l) = lhs, case .selectionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusBarComponentResponse, .statusBarComponentResponse): return {
        guard case .statusBarComponentResponse(let l) = lhs, case .statusBarComponentResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setBroadcastDomainsResponse, .setBroadcastDomainsResponse): return {
        guard case .setBroadcastDomainsResponse(let l) = lhs, case .setBroadcastDomainsResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closeResponse, .closeResponse): return {
        guard case .closeResponse(let l) = lhs, case .closeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invokeFunctionResponse, .invokeFunctionResponse): return {
        guard case .invokeFunctionResponse(let l) = lhs, case .invokeFunctionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listPromptsResponse, .listPromptsResponse): return {
        guard case .listPromptsResponse(let l) = lhs, case .listPromptsResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notification, .notification): return {
        guard case .notification(let l) = lhs, case .notification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _id: Int64? = nil
}

struct Iterm2_InvokeFunctionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var context: Iterm2_InvokeFunctionRequest.OneOf_Context? = nil

  var tab: Iterm2_InvokeFunctionRequest.Tab {
    get {
      if case .tab(let v)? = context {return v}
      return Iterm2_InvokeFunctionRequest.Tab()
    }
    set {context = .tab(newValue)}
  }

  var session: Iterm2_InvokeFunctionRequest.Session {
    get {
      if case .session(let v)? = context {return v}
      return Iterm2_InvokeFunctionRequest.Session()
    }
    set {context = .session(newValue)}
  }

  var window: Iterm2_InvokeFunctionRequest.Window {
    get {
      if case .window(let v)? = context {return v}
      return Iterm2_InvokeFunctionRequest.Window()
    }
    set {context = .window(newValue)}
  }

  var app: Iterm2_InvokeFunctionRequest.App {
    get {
      if case .app(let v)? = context {return v}
      return Iterm2_InvokeFunctionRequest.App()
    }
    set {context = .app(newValue)}
  }

  var method: Iterm2_InvokeFunctionRequest.Method {
    get {
      if case .method(let v)? = context {return v}
      return Iterm2_InvokeFunctionRequest.Method()
    }
    set {context = .method(newValue)}
  }

  var invocation: String {
    get {return _invocation ?? String()}
    set {_invocation = newValue}
  }
  /// Returns true if `invocation` has been explicitly set.
  var hasInvocation: Bool {return self._invocation != nil}
  /// Clears the value of `invocation`. Subsequent reads from it will return its default value.
  mutating func clearInvocation() {self._invocation = nil}

  /// If not given a reasonable default value will be used. Negative value means to use the default.
  var timeout: Double {
    get {return _timeout ?? -1}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Context: Equatable {
    case tab(Iterm2_InvokeFunctionRequest.Tab)
    case session(Iterm2_InvokeFunctionRequest.Session)
    case window(Iterm2_InvokeFunctionRequest.Window)
    case app(Iterm2_InvokeFunctionRequest.App)
    case method(Iterm2_InvokeFunctionRequest.Method)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_InvokeFunctionRequest.OneOf_Context, rhs: Iterm2_InvokeFunctionRequest.OneOf_Context) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tab, .tab): return {
        guard case .tab(let l) = lhs, case .tab(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.session, .session): return {
        guard case .session(let l) = lhs, case .session(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.window, .window): return {
        guard case .window(let l) = lhs, case .window(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.app, .app): return {
        guard case .app(let l) = lhs, case .app(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.method, .method): return {
        guard case .method(let l) = lhs, case .method(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Tab {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tabID: String {
      get {return _tabID ?? String()}
      set {_tabID = newValue}
    }
    /// Returns true if `tabID` has been explicitly set.
    var hasTabID: Bool {return self._tabID != nil}
    /// Clears the value of `tabID`. Subsequent reads from it will return its default value.
    mutating func clearTabID() {self._tabID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _tabID: String? = nil
  }

  struct Session {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sessionID: String {
      get {return _sessionID ?? String()}
      set {_sessionID = newValue}
    }
    /// Returns true if `sessionID` has been explicitly set.
    var hasSessionID: Bool {return self._sessionID != nil}
    /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
    mutating func clearSessionID() {self._sessionID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sessionID: String? = nil
  }

  struct Window {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var windowID: String {
      get {return _windowID ?? String()}
      set {_windowID = newValue}
    }
    /// Returns true if `windowID` has been explicitly set.
    var hasWindowID: Bool {return self._windowID != nil}
    /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
    mutating func clearWindowID() {self._windowID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _windowID: String? = nil
  }

  struct App {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Method {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The following methods are defined:
    /// window.set_title(title: String)
    /// session.set_name(name: String)
    /// session.run_tmux_command(command: String) throws  // Throws an exception if this is not a tmux session
    /// session.set_status_bar_component_unread_count(identifier: String, count: Int)
    /// session.stop_coprocess() -> Bool  // returns whether there was a coprocess to stop
    /// session.get_coprocess() -> String?  // returns the name of the command, or nil
    /// session.run_coprocess(commandLine: String, mute: Bool) -> Bool  // returns whether it attempted to start the coprocess. It'll fail only if there is already a coprocess.
    /// tab.set_title(title: String)
    /// tab.select_pane_in_direction(direction: String) throws -> String  // direction is 'left', 'right', 'above', or 'below'. If successful, it will return the ID of the newly active session. If you can't go that way, it returns null. Throws an exception if the direction is invalid.
    var receiver: String {
      get {return _receiver ?? String()}
      set {_receiver = newValue}
    }
    /// Returns true if `receiver` has been explicitly set.
    var hasReceiver: Bool {return self._receiver != nil}
    /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
    mutating func clearReceiver() {self._receiver = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _receiver: String? = nil
  }

  init() {}

  fileprivate var _invocation: String? = nil
  fileprivate var _timeout: Double? = nil
}

struct Iterm2_InvokeFunctionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var disposition: Iterm2_InvokeFunctionResponse.OneOf_Disposition? = nil

  var error: Iterm2_InvokeFunctionResponse.Error {
    get {
      if case .error(let v)? = disposition {return v}
      return Iterm2_InvokeFunctionResponse.Error()
    }
    set {disposition = .error(newValue)}
  }

  var success: Iterm2_InvokeFunctionResponse.Success {
    get {
      if case .success(let v)? = disposition {return v}
      return Iterm2_InvokeFunctionResponse.Success()
    }
    set {disposition = .success(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Disposition: Equatable {
    case error(Iterm2_InvokeFunctionResponse.Error)
    case success(Iterm2_InvokeFunctionResponse.Success)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_InvokeFunctionResponse.OneOf_Disposition, rhs: Iterm2_InvokeFunctionResponse.OneOf_Disposition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case timeout // = 1
    case failed // = 2
    case requestMalformed // = 3
    case invalidID // = 4

    init() {
      self = .timeout
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .timeout
      case 2: self = .failed
      case 3: self = .requestMalformed
      case 4: self = .invalidID
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .timeout: return 1
      case .failed: return 2
      case .requestMalformed: return 3
      case .invalidID: return 4
      }
    }

  }

  struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Iterm2_InvokeFunctionResponse.Status {
      get {return _status ?? .timeout}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    mutating func clearStatus() {self._status = nil}

    var errorReason: String {
      get {return _errorReason ?? String()}
      set {_errorReason = newValue}
    }
    /// Returns true if `errorReason` has been explicitly set.
    var hasErrorReason: Bool {return self._errorReason != nil}
    /// Clears the value of `errorReason`. Subsequent reads from it will return its default value.
    mutating func clearErrorReason() {self._errorReason = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _status: Iterm2_InvokeFunctionResponse.Status? = nil
    fileprivate var _errorReason: String? = nil
  }

  struct Success {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var jsonResult: String {
      get {return _jsonResult ?? String()}
      set {_jsonResult = newValue}
    }
    /// Returns true if `jsonResult` has been explicitly set.
    var hasJsonResult: Bool {return self._jsonResult != nil}
    /// Clears the value of `jsonResult`. Subsequent reads from it will return its default value.
    mutating func clearJsonResult() {self._jsonResult = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _jsonResult: String? = nil
  }

  init() {}
}

#if swift(>=4.2)

extension Iterm2_InvokeFunctionResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_CloseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: Iterm2_CloseRequest.OneOf_Target? = nil

  var tabs: Iterm2_CloseRequest.CloseTabs {
    get {
      if case .tabs(let v)? = target {return v}
      return Iterm2_CloseRequest.CloseTabs()
    }
    set {target = .tabs(newValue)}
  }

  var sessions: Iterm2_CloseRequest.CloseSessions {
    get {
      if case .sessions(let v)? = target {return v}
      return Iterm2_CloseRequest.CloseSessions()
    }
    set {target = .sessions(newValue)}
  }

  var windows: Iterm2_CloseRequest.CloseWindows {
    get {
      if case .windows(let v)? = target {return v}
      return Iterm2_CloseRequest.CloseWindows()
    }
    set {target = .windows(newValue)}
  }

  var force: Bool {
    get {return _force ?? false}
    set {_force = newValue}
  }
  /// Returns true if `force` has been explicitly set.
  var hasForce: Bool {return self._force != nil}
  /// Clears the value of `force`. Subsequent reads from it will return its default value.
  mutating func clearForce() {self._force = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    case tabs(Iterm2_CloseRequest.CloseTabs)
    case sessions(Iterm2_CloseRequest.CloseSessions)
    case windows(Iterm2_CloseRequest.CloseWindows)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_CloseRequest.OneOf_Target, rhs: Iterm2_CloseRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tabs, .tabs): return {
        guard case .tabs(let l) = lhs, case .tabs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessions, .sessions): return {
        guard case .sessions(let l) = lhs, case .sessions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windows, .windows): return {
        guard case .windows(let l) = lhs, case .windows(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct CloseTabs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tabIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CloseSessions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sessionIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CloseWindows {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var windowIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _force: Bool? = nil
}

struct Iterm2_CloseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statuses: [Iterm2_CloseResponse.Status] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case notFound // = 1
    case userDeclined // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .notFound
      case 2: self = .userDeclined
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .notFound: return 1
      case .userDeclined: return 2
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Iterm2_CloseResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_SetBroadcastDomainsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var broadcastDomains: [Iterm2_BroadcastDomain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_SetBroadcastDomainsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SetBroadcastDomainsResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case broadcastDomainsNotDisjoint // = 2
    case sessionsNotInSameWindow // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .broadcastDomainsNotDisjoint
      case 3: self = .sessionsNotInSameWindow
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .broadcastDomainsNotDisjoint: return 2
      case .sessionsNotInSameWindow: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_SetBroadcastDomainsResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SetBroadcastDomainsResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_StatusBarComponentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Iterm2_StatusBarComponentRequest.OneOf_Request? = nil

  var openPopover: Iterm2_StatusBarComponentRequest.OpenPopover {
    get {
      if case .openPopover(let v)? = request {return v}
      return Iterm2_StatusBarComponentRequest.OpenPopover()
    }
    set {request = .openPopover(newValue)}
  }

  /// ID of statusbar component
  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case openPopover(Iterm2_StatusBarComponentRequest.OpenPopover)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_StatusBarComponentRequest.OneOf_Request, rhs: Iterm2_StatusBarComponentRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.openPopover, .openPopover): return {
        guard case .openPopover(let l) = lhs, case .openPopover(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  struct OpenPopover {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sessionID: String {
      get {return _sessionID ?? String()}
      set {_sessionID = newValue}
    }
    /// Returns true if `sessionID` has been explicitly set.
    var hasSessionID: Bool {return self._sessionID != nil}
    /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
    mutating func clearSessionID() {self._sessionID = nil}

    /// HTML to show in a popover that opens from the component.
    var html: String {
      get {return _html ?? String()}
      set {_html = newValue}
    }
    /// Returns true if `html` has been explicitly set.
    var hasHtml: Bool {return self._html != nil}
    /// Clears the value of `html`. Subsequent reads from it will return its default value.
    mutating func clearHtml() {self._html = nil}

    /// Size in points of the content area of the popover.
    var size: Iterm2_Size {
      get {return _size ?? Iterm2_Size()}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {self._size = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sessionID: String? = nil
    fileprivate var _html: String? = nil
    fileprivate var _size: Iterm2_Size? = nil
  }

  init() {}

  fileprivate var _identifier: String? = nil
}

struct Iterm2_StatusBarComponentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_StatusBarComponentResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case requestMalformed // = 2
    case invalidIdentifier // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .requestMalformed
      case 3: self = .invalidIdentifier
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .requestMalformed: return 2
      case .invalidIdentifier: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_StatusBarComponentResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_StatusBarComponentResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_WindowedCoordRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var coordRange: Iterm2_CoordRange {
    get {return _coordRange ?? Iterm2_CoordRange()}
    set {_coordRange = newValue}
  }
  /// Returns true if `coordRange` has been explicitly set.
  var hasCoordRange: Bool {return self._coordRange != nil}
  /// Clears the value of `coordRange`. Subsequent reads from it will return its default value.
  mutating func clearCoordRange() {self._coordRange = nil}

  var columns: Iterm2_Range {
    get {return _columns ?? Iterm2_Range()}
    set {_columns = newValue}
  }
  /// Returns true if `columns` has been explicitly set.
  var hasColumns: Bool {return self._columns != nil}
  /// Clears the value of `columns`. Subsequent reads from it will return its default value.
  mutating func clearColumns() {self._columns = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coordRange: Iterm2_CoordRange? = nil
  fileprivate var _columns: Iterm2_Range? = nil
}

struct Iterm2_SubSelection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var windowedCoordRange: Iterm2_WindowedCoordRange {
    get {return _windowedCoordRange ?? Iterm2_WindowedCoordRange()}
    set {_windowedCoordRange = newValue}
  }
  /// Returns true if `windowedCoordRange` has been explicitly set.
  var hasWindowedCoordRange: Bool {return self._windowedCoordRange != nil}
  /// Clears the value of `windowedCoordRange`. Subsequent reads from it will return its default value.
  mutating func clearWindowedCoordRange() {self._windowedCoordRange = nil}

  var selectionMode: Iterm2_SelectionMode {
    get {return _selectionMode ?? .character}
    set {_selectionMode = newValue}
  }
  /// Returns true if `selectionMode` has been explicitly set.
  var hasSelectionMode: Bool {return self._selectionMode != nil}
  /// Clears the value of `selectionMode`. Subsequent reads from it will return its default value.
  mutating func clearSelectionMode() {self._selectionMode = nil}

  var connected: Bool {
    get {return _connected ?? false}
    set {_connected = newValue}
  }
  /// Returns true if `connected` has been explicitly set.
  var hasConnected: Bool {return self._connected != nil}
  /// Clears the value of `connected`. Subsequent reads from it will return its default value.
  mutating func clearConnected() {self._connected = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _windowedCoordRange: Iterm2_WindowedCoordRange? = nil
  fileprivate var _selectionMode: Iterm2_SelectionMode? = nil
  fileprivate var _connected: Bool? = nil
}

struct Iterm2_Selection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subSelections: [Iterm2_SubSelection] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_SelectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Iterm2_SelectionRequest.OneOf_Request? = nil

  var getSelectionRequest: Iterm2_SelectionRequest.GetSelectionRequest {
    get {
      if case .getSelectionRequest(let v)? = request {return v}
      return Iterm2_SelectionRequest.GetSelectionRequest()
    }
    set {request = .getSelectionRequest(newValue)}
  }

  var setSelectionRequest: Iterm2_SelectionRequest.SetSelectionRequest {
    get {
      if case .setSelectionRequest(let v)? = request {return v}
      return Iterm2_SelectionRequest.SetSelectionRequest()
    }
    set {request = .setSelectionRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case getSelectionRequest(Iterm2_SelectionRequest.GetSelectionRequest)
    case setSelectionRequest(Iterm2_SelectionRequest.SetSelectionRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_SelectionRequest.OneOf_Request, rhs: Iterm2_SelectionRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getSelectionRequest, .getSelectionRequest): return {
        guard case .getSelectionRequest(let l) = lhs, case .getSelectionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setSelectionRequest, .setSelectionRequest): return {
        guard case .setSelectionRequest(let l) = lhs, case .setSelectionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct GetSelectionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sessionID: String {
      get {return _sessionID ?? String()}
      set {_sessionID = newValue}
    }
    /// Returns true if `sessionID` has been explicitly set.
    var hasSessionID: Bool {return self._sessionID != nil}
    /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
    mutating func clearSessionID() {self._sessionID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sessionID: String? = nil
  }

  struct SetSelectionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sessionID: String {
      get {return _sessionID ?? String()}
      set {_sessionID = newValue}
    }
    /// Returns true if `sessionID` has been explicitly set.
    var hasSessionID: Bool {return self._sessionID != nil}
    /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
    mutating func clearSessionID() {self._sessionID = nil}

    var selection: Iterm2_Selection {
      get {return _selection ?? Iterm2_Selection()}
      set {_selection = newValue}
    }
    /// Returns true if `selection` has been explicitly set.
    var hasSelection: Bool {return self._selection != nil}
    /// Clears the value of `selection`. Subsequent reads from it will return its default value.
    mutating func clearSelection() {self._selection = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sessionID: String? = nil
    fileprivate var _selection: Iterm2_Selection? = nil
  }

  init() {}
}

struct Iterm2_SelectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SelectionResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var response: Iterm2_SelectionResponse.OneOf_Response? = nil

  var getSelectionResponse: Iterm2_SelectionResponse.GetSelectionResponse {
    get {
      if case .getSelectionResponse(let v)? = response {return v}
      return Iterm2_SelectionResponse.GetSelectionResponse()
    }
    set {response = .getSelectionResponse(newValue)}
  }

  var setSelectionResponse: Iterm2_SelectionResponse.SetSelectionResponse {
    get {
      if case .setSelectionResponse(let v)? = response {return v}
      return Iterm2_SelectionResponse.SetSelectionResponse()
    }
    set {response = .setSelectionResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case getSelectionResponse(Iterm2_SelectionResponse.GetSelectionResponse)
    case setSelectionResponse(Iterm2_SelectionResponse.SetSelectionResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_SelectionResponse.OneOf_Response, rhs: Iterm2_SelectionResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getSelectionResponse, .getSelectionResponse): return {
        guard case .getSelectionResponse(let l) = lhs, case .getSelectionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setSelectionResponse, .setSelectionResponse): return {
        guard case .setSelectionResponse(let l) = lhs, case .setSelectionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case invalidSession // = 1
    case invalidRange // = 2
    case requestMalformed // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidSession
      case 2: self = .invalidRange
      case 3: self = .requestMalformed
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidSession: return 1
      case .invalidRange: return 2
      case .requestMalformed: return 3
      }
    }

  }

  struct GetSelectionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var selection: Iterm2_Selection {
      get {return _selection ?? Iterm2_Selection()}
      set {_selection = newValue}
    }
    /// Returns true if `selection` has been explicitly set.
    var hasSelection: Bool {return self._selection != nil}
    /// Clears the value of `selection`. Subsequent reads from it will return its default value.
    mutating func clearSelection() {self._selection = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _selection: Iterm2_Selection? = nil
  }

  struct SetSelectionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _status: Iterm2_SelectionResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SelectionResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_ColorPresetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Iterm2_ColorPresetRequest.OneOf_Request? = nil

  var listPresets: Iterm2_ColorPresetRequest.ListPresets {
    get {
      if case .listPresets(let v)? = request {return v}
      return Iterm2_ColorPresetRequest.ListPresets()
    }
    set {request = .listPresets(newValue)}
  }

  var getPreset: Iterm2_ColorPresetRequest.GetPreset {
    get {
      if case .getPreset(let v)? = request {return v}
      return Iterm2_ColorPresetRequest.GetPreset()
    }
    set {request = .getPreset(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case listPresets(Iterm2_ColorPresetRequest.ListPresets)
    case getPreset(Iterm2_ColorPresetRequest.GetPreset)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_ColorPresetRequest.OneOf_Request, rhs: Iterm2_ColorPresetRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listPresets, .listPresets): return {
        guard case .listPresets(let l) = lhs, case .listPresets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getPreset, .getPreset): return {
        guard case .getPreset(let l) = lhs, case .getPreset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct ListPresets {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetPreset {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
  }

  init() {}
}

struct Iterm2_ColorPresetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Iterm2_ColorPresetResponse.OneOf_Response? = nil

  var listPresets: Iterm2_ColorPresetResponse.ListPresets {
    get {
      if case .listPresets(let v)? = response {return v}
      return Iterm2_ColorPresetResponse.ListPresets()
    }
    set {response = .listPresets(newValue)}
  }

  var getPreset: Iterm2_ColorPresetResponse.GetPreset {
    get {
      if case .getPreset(let v)? = response {return v}
      return Iterm2_ColorPresetResponse.GetPreset()
    }
    set {response = .getPreset(newValue)}
  }

  var status: Iterm2_ColorPresetResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case listPresets(Iterm2_ColorPresetResponse.ListPresets)
    case getPreset(Iterm2_ColorPresetResponse.GetPreset)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_ColorPresetResponse.OneOf_Response, rhs: Iterm2_ColorPresetResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listPresets, .listPresets): return {
        guard case .listPresets(let l) = lhs, case .listPresets(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getPreset, .getPreset): return {
        guard case .getPreset(let l) = lhs, case .getPreset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case presetNotFound // = 1
    case requestMalformed // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .presetNotFound
      case 2: self = .requestMalformed
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .presetNotFound: return 1
      case .requestMalformed: return 2
      }
    }

  }

  struct ListPresets {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetPreset {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var colorSettings: [Iterm2_ColorPresetResponse.GetPreset.ColorSetting] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ColorSetting {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var red: Float {
        get {return _red ?? 0}
        set {_red = newValue}
      }
      /// Returns true if `red` has been explicitly set.
      var hasRed: Bool {return self._red != nil}
      /// Clears the value of `red`. Subsequent reads from it will return its default value.
      mutating func clearRed() {self._red = nil}

      var green: Float {
        get {return _green ?? 0}
        set {_green = newValue}
      }
      /// Returns true if `green` has been explicitly set.
      var hasGreen: Bool {return self._green != nil}
      /// Clears the value of `green`. Subsequent reads from it will return its default value.
      mutating func clearGreen() {self._green = nil}

      var blue: Float {
        get {return _blue ?? 0}
        set {_blue = newValue}
      }
      /// Returns true if `blue` has been explicitly set.
      var hasBlue: Bool {return self._blue != nil}
      /// Clears the value of `blue`. Subsequent reads from it will return its default value.
      mutating func clearBlue() {self._blue = nil}

      var alpha: Float {
        get {return _alpha ?? 0}
        set {_alpha = newValue}
      }
      /// Returns true if `alpha` has been explicitly set.
      var hasAlpha: Bool {return self._alpha != nil}
      /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
      mutating func clearAlpha() {self._alpha = nil}

      var colorSpace: String {
        get {return _colorSpace ?? String()}
        set {_colorSpace = newValue}
      }
      /// Returns true if `colorSpace` has been explicitly set.
      var hasColorSpace: Bool {return self._colorSpace != nil}
      /// Clears the value of `colorSpace`. Subsequent reads from it will return its default value.
      mutating func clearColorSpace() {self._colorSpace = nil}

      var key: String {
        get {return _key ?? String()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _red: Float? = nil
      fileprivate var _green: Float? = nil
      fileprivate var _blue: Float? = nil
      fileprivate var _alpha: Float? = nil
      fileprivate var _colorSpace: String? = nil
      fileprivate var _key: String? = nil
    }

    init() {}
  }

  init() {}

  fileprivate var _status: Iterm2_ColorPresetResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_ColorPresetResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_PreferencesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requests: [Iterm2_PreferencesRequest.Request] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var request: Iterm2_PreferencesRequest.Request.OneOf_Request? = nil

    var setPreferenceRequest: Iterm2_PreferencesRequest.Request.SetPreference {
      get {
        if case .setPreferenceRequest(let v)? = request {return v}
        return Iterm2_PreferencesRequest.Request.SetPreference()
      }
      set {request = .setPreferenceRequest(newValue)}
    }

    var getPreferenceRequest: Iterm2_PreferencesRequest.Request.GetPreference {
      get {
        if case .getPreferenceRequest(let v)? = request {return v}
        return Iterm2_PreferencesRequest.Request.GetPreference()
      }
      set {request = .getPreferenceRequest(newValue)}
    }

    var setDefaultProfileRequest: Iterm2_PreferencesRequest.Request.SetDefaultProfile {
      get {
        if case .setDefaultProfileRequest(let v)? = request {return v}
        return Iterm2_PreferencesRequest.Request.SetDefaultProfile()
      }
      set {request = .setDefaultProfileRequest(newValue)}
    }

    var getDefaultProfileRequest: Iterm2_PreferencesRequest.Request.GetDefaultProfile {
      get {
        if case .getDefaultProfileRequest(let v)? = request {return v}
        return Iterm2_PreferencesRequest.Request.GetDefaultProfile()
      }
      set {request = .getDefaultProfileRequest(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Request: Equatable {
      case setPreferenceRequest(Iterm2_PreferencesRequest.Request.SetPreference)
      case getPreferenceRequest(Iterm2_PreferencesRequest.Request.GetPreference)
      case setDefaultProfileRequest(Iterm2_PreferencesRequest.Request.SetDefaultProfile)
      case getDefaultProfileRequest(Iterm2_PreferencesRequest.Request.GetDefaultProfile)

    #if !swift(>=4.1)
      static func ==(lhs: Iterm2_PreferencesRequest.Request.OneOf_Request, rhs: Iterm2_PreferencesRequest.Request.OneOf_Request) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.setPreferenceRequest, .setPreferenceRequest): return {
          guard case .setPreferenceRequest(let l) = lhs, case .setPreferenceRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.getPreferenceRequest, .getPreferenceRequest): return {
          guard case .getPreferenceRequest(let l) = lhs, case .getPreferenceRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.setDefaultProfileRequest, .setDefaultProfileRequest): return {
          guard case .setDefaultProfileRequest(let l) = lhs, case .setDefaultProfileRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.getDefaultProfileRequest, .getDefaultProfileRequest): return {
          guard case .getDefaultProfileRequest(let l) = lhs, case .getDefaultProfileRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct SetPreference {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var key: String {
        get {return _key ?? String()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      var jsonValue: String {
        get {return _jsonValue ?? String()}
        set {_jsonValue = newValue}
      }
      /// Returns true if `jsonValue` has been explicitly set.
      var hasJsonValue: Bool {return self._jsonValue != nil}
      /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
      mutating func clearJsonValue() {self._jsonValue = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _key: String? = nil
      fileprivate var _jsonValue: String? = nil
    }

    struct GetPreference {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var key: String {
        get {return _key ?? String()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _key: String? = nil
    }

    struct SetDefaultProfile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var guid: String {
        get {return _guid ?? String()}
        set {_guid = newValue}
      }
      /// Returns true if `guid` has been explicitly set.
      var hasGuid: Bool {return self._guid != nil}
      /// Clears the value of `guid`. Subsequent reads from it will return its default value.
      mutating func clearGuid() {self._guid = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _guid: String? = nil
    }

    struct GetDefaultProfile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

struct Iterm2_PreferencesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var results: [Iterm2_PreferencesResponse.Result] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var result: Iterm2_PreferencesResponse.Result.OneOf_Result? = nil

    var unrecognizedRequest: Iterm2_PreferencesResponse.Result.UnrecognizedResult {
      get {
        if case .unrecognizedRequest(let v)? = result {return v}
        return Iterm2_PreferencesResponse.Result.UnrecognizedResult()
      }
      set {result = .unrecognizedRequest(newValue)}
    }

    var setPreferenceResult: Iterm2_PreferencesResponse.Result.SetPreferenceResult {
      get {
        if case .setPreferenceResult(let v)? = result {return v}
        return Iterm2_PreferencesResponse.Result.SetPreferenceResult()
      }
      set {result = .setPreferenceResult(newValue)}
    }

    var getPreferenceResult: Iterm2_PreferencesResponse.Result.GetPreferenceResult {
      get {
        if case .getPreferenceResult(let v)? = result {return v}
        return Iterm2_PreferencesResponse.Result.GetPreferenceResult()
      }
      set {result = .getPreferenceResult(newValue)}
    }

    var setDefaultProfileResult: Iterm2_PreferencesResponse.Result.SetDefaultProfileResult {
      get {
        if case .setDefaultProfileResult(let v)? = result {return v}
        return Iterm2_PreferencesResponse.Result.SetDefaultProfileResult()
      }
      set {result = .setDefaultProfileResult(newValue)}
    }

    var getDefaultProfileResult: Iterm2_PreferencesResponse.Result.GetDefaultProfileResult {
      get {
        if case .getDefaultProfileResult(let v)? = result {return v}
        return Iterm2_PreferencesResponse.Result.GetDefaultProfileResult()
      }
      set {result = .getDefaultProfileResult(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Result: Equatable {
      case unrecognizedRequest(Iterm2_PreferencesResponse.Result.UnrecognizedResult)
      case setPreferenceResult(Iterm2_PreferencesResponse.Result.SetPreferenceResult)
      case getPreferenceResult(Iterm2_PreferencesResponse.Result.GetPreferenceResult)
      case setDefaultProfileResult(Iterm2_PreferencesResponse.Result.SetDefaultProfileResult)
      case getDefaultProfileResult(Iterm2_PreferencesResponse.Result.GetDefaultProfileResult)

    #if !swift(>=4.1)
      static func ==(lhs: Iterm2_PreferencesResponse.Result.OneOf_Result, rhs: Iterm2_PreferencesResponse.Result.OneOf_Result) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.unrecognizedRequest, .unrecognizedRequest): return {
          guard case .unrecognizedRequest(let l) = lhs, case .unrecognizedRequest(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.setPreferenceResult, .setPreferenceResult): return {
          guard case .setPreferenceResult(let l) = lhs, case .setPreferenceResult(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.getPreferenceResult, .getPreferenceResult): return {
          guard case .getPreferenceResult(let l) = lhs, case .getPreferenceResult(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.setDefaultProfileResult, .setDefaultProfileResult): return {
          guard case .setDefaultProfileResult(let l) = lhs, case .setDefaultProfileResult(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.getDefaultProfileResult, .getDefaultProfileResult): return {
          guard case .getDefaultProfileResult(let l) = lhs, case .getDefaultProfileResult(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct SetPreferenceResult {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var status: Iterm2_PreferencesResponse.Result.SetPreferenceResult.Status {
        get {return _status ?? .ok}
        set {_status = newValue}
      }
      /// Returns true if `status` has been explicitly set.
      var hasStatus: Bool {return self._status != nil}
      /// Clears the value of `status`. Subsequent reads from it will return its default value.
      mutating func clearStatus() {self._status = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Status: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case ok // = 0
        case badJson // = 1

        /// Not legal for a plist
        case invalidValue // = 2

        init() {
          self = .ok
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .ok
          case 1: self = .badJson
          case 2: self = .invalidValue
          default: return nil
          }
        }

        var rawValue: Int {
          switch self {
          case .ok: return 0
          case .badJson: return 1
          case .invalidValue: return 2
          }
        }

      }

      init() {}

      fileprivate var _status: Iterm2_PreferencesResponse.Result.SetPreferenceResult.Status? = nil
    }

    struct GetPreferenceResult {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Will be unset if no value assigned. Will always be set if there is a default value.
      var jsonValue: String {
        get {return _jsonValue ?? String()}
        set {_jsonValue = newValue}
      }
      /// Returns true if `jsonValue` has been explicitly set.
      var hasJsonValue: Bool {return self._jsonValue != nil}
      /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
      mutating func clearJsonValue() {self._jsonValue = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _jsonValue: String? = nil
    }

    struct SetDefaultProfileResult {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var status: Iterm2_PreferencesResponse.Result.SetDefaultProfileResult.Status {
        get {return _status ?? .ok}
        set {_status = newValue}
      }
      /// Returns true if `status` has been explicitly set.
      var hasStatus: Bool {return self._status != nil}
      /// Clears the value of `status`. Subsequent reads from it will return its default value.
      mutating func clearStatus() {self._status = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Status: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case ok // = 0
        case badGuid // = 1

        init() {
          self = .ok
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .ok
          case 1: self = .badGuid
          default: return nil
          }
        }

        var rawValue: Int {
          switch self {
          case .ok: return 0
          case .badGuid: return 1
          }
        }

      }

      init() {}

      fileprivate var _status: Iterm2_PreferencesResponse.Result.SetDefaultProfileResult.Status? = nil
    }

    struct UnrecognizedResult {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct GetDefaultProfileResult {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var guid: String {
        get {return _guid ?? String()}
        set {_guid = newValue}
      }
      /// Returns true if `guid` has been explicitly set.
      var hasGuid: Bool {return self._guid != nil}
      /// Clears the value of `guid`. Subsequent reads from it will return its default value.
      mutating func clearGuid() {self._guid = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _guid: String? = nil
    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Iterm2_PreferencesResponse.Result.SetPreferenceResult.Status: CaseIterable {
  // Support synthesized by the compiler.
}

extension Iterm2_PreferencesResponse.Result.SetDefaultProfileResult.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_ReorderTabsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assignments: [Iterm2_ReorderTabsRequest.Assignment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Assignment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var windowID: String {
      get {return _windowID ?? String()}
      set {_windowID = newValue}
    }
    /// Returns true if `windowID` has been explicitly set.
    var hasWindowID: Bool {return self._windowID != nil}
    /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
    mutating func clearWindowID() {self._windowID = nil}

    var tabIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _windowID: String? = nil
  }

  init() {}
}

struct Iterm2_ReorderTabsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_ReorderTabsResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0

    /// e.g., duplicate tab id
    case invalidAssignment // = 1
    case invalidWindowID // = 2
    case invalidTabID // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidAssignment
      case 2: self = .invalidWindowID
      case 3: self = .invalidTabID
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidAssignment: return 1
      case .invalidWindowID: return 2
      case .invalidTabID: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_ReorderTabsResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_ReorderTabsResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_TmuxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Iterm2_TmuxRequest.OneOf_Payload? = nil

  var listConnections: Iterm2_TmuxRequest.ListConnections {
    get {
      if case .listConnections(let v)? = payload {return v}
      return Iterm2_TmuxRequest.ListConnections()
    }
    set {payload = .listConnections(newValue)}
  }

  var sendCommand: Iterm2_TmuxRequest.SendCommand {
    get {
      if case .sendCommand(let v)? = payload {return v}
      return Iterm2_TmuxRequest.SendCommand()
    }
    set {payload = .sendCommand(newValue)}
  }

  var setWindowVisible: Iterm2_TmuxRequest.SetWindowVisible {
    get {
      if case .setWindowVisible(let v)? = payload {return v}
      return Iterm2_TmuxRequest.SetWindowVisible()
    }
    set {payload = .setWindowVisible(newValue)}
  }

  var createWindow: Iterm2_TmuxRequest.CreateWindow {
    get {
      if case .createWindow(let v)? = payload {return v}
      return Iterm2_TmuxRequest.CreateWindow()
    }
    set {payload = .createWindow(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    case listConnections(Iterm2_TmuxRequest.ListConnections)
    case sendCommand(Iterm2_TmuxRequest.SendCommand)
    case setWindowVisible(Iterm2_TmuxRequest.SetWindowVisible)
    case createWindow(Iterm2_TmuxRequest.CreateWindow)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_TmuxRequest.OneOf_Payload, rhs: Iterm2_TmuxRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listConnections, .listConnections): return {
        guard case .listConnections(let l) = lhs, case .listConnections(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendCommand, .sendCommand): return {
        guard case .sendCommand(let l) = lhs, case .sendCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setWindowVisible, .setWindowVisible): return {
        guard case .setWindowVisible(let l) = lhs, case .setWindowVisible(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createWindow, .createWindow): return {
        guard case .createWindow(let l) = lhs, case .createWindow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct ListConnections {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SendCommand {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var connectionID: String {
      get {return _connectionID ?? String()}
      set {_connectionID = newValue}
    }
    /// Returns true if `connectionID` has been explicitly set.
    var hasConnectionID: Bool {return self._connectionID != nil}
    /// Clears the value of `connectionID`. Subsequent reads from it will return its default value.
    mutating func clearConnectionID() {self._connectionID = nil}

    var command: String {
      get {return _command ?? String()}
      set {_command = newValue}
    }
    /// Returns true if `command` has been explicitly set.
    var hasCommand: Bool {return self._command != nil}
    /// Clears the value of `command`. Subsequent reads from it will return its default value.
    mutating func clearCommand() {self._command = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _connectionID: String? = nil
    fileprivate var _command: String? = nil
  }

  struct SetWindowVisible {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var connectionID: String {
      get {return _connectionID ?? String()}
      set {_connectionID = newValue}
    }
    /// Returns true if `connectionID` has been explicitly set.
    var hasConnectionID: Bool {return self._connectionID != nil}
    /// Clears the value of `connectionID`. Subsequent reads from it will return its default value.
    mutating func clearConnectionID() {self._connectionID = nil}

    var windowID: String {
      get {return _windowID ?? String()}
      set {_windowID = newValue}
    }
    /// Returns true if `windowID` has been explicitly set.
    var hasWindowID: Bool {return self._windowID != nil}
    /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
    mutating func clearWindowID() {self._windowID = nil}

    var visible: Bool {
      get {return _visible ?? false}
      set {_visible = newValue}
    }
    /// Returns true if `visible` has been explicitly set.
    var hasVisible: Bool {return self._visible != nil}
    /// Clears the value of `visible`. Subsequent reads from it will return its default value.
    mutating func clearVisible() {self._visible = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _connectionID: String? = nil
    fileprivate var _windowID: String? = nil
    fileprivate var _visible: Bool? = nil
  }

  struct CreateWindow {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var connectionID: String {
      get {return _connectionID ?? String()}
      set {_connectionID = newValue}
    }
    /// Returns true if `connectionID` has been explicitly set.
    var hasConnectionID: Bool {return self._connectionID != nil}
    /// Clears the value of `connectionID`. Subsequent reads from it will return its default value.
    mutating func clearConnectionID() {self._connectionID = nil}

    var affinity: String {
      get {return _affinity ?? String()}
      set {_affinity = newValue}
    }
    /// Returns true if `affinity` has been explicitly set.
    var hasAffinity: Bool {return self._affinity != nil}
    /// Clears the value of `affinity`. Subsequent reads from it will return its default value.
    mutating func clearAffinity() {self._affinity = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _connectionID: String? = nil
    fileprivate var _affinity: String? = nil
  }

  init() {}
}

struct Iterm2_TmuxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Iterm2_TmuxResponse.OneOf_Payload? = nil

  var listConnections: Iterm2_TmuxResponse.ListConnections {
    get {
      if case .listConnections(let v)? = payload {return v}
      return Iterm2_TmuxResponse.ListConnections()
    }
    set {payload = .listConnections(newValue)}
  }

  var sendCommand: Iterm2_TmuxResponse.SendCommand {
    get {
      if case .sendCommand(let v)? = payload {return v}
      return Iterm2_TmuxResponse.SendCommand()
    }
    set {payload = .sendCommand(newValue)}
  }

  var setWindowVisible: Iterm2_TmuxResponse.SetWindowVisible {
    get {
      if case .setWindowVisible(let v)? = payload {return v}
      return Iterm2_TmuxResponse.SetWindowVisible()
    }
    set {payload = .setWindowVisible(newValue)}
  }

  var createWindow: Iterm2_TmuxResponse.CreateWindow {
    get {
      if case .createWindow(let v)? = payload {return v}
      return Iterm2_TmuxResponse.CreateWindow()
    }
    set {payload = .createWindow(newValue)}
  }

  var status: Iterm2_TmuxResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    case listConnections(Iterm2_TmuxResponse.ListConnections)
    case sendCommand(Iterm2_TmuxResponse.SendCommand)
    case setWindowVisible(Iterm2_TmuxResponse.SetWindowVisible)
    case createWindow(Iterm2_TmuxResponse.CreateWindow)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_TmuxResponse.OneOf_Payload, rhs: Iterm2_TmuxResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listConnections, .listConnections): return {
        guard case .listConnections(let l) = lhs, case .listConnections(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sendCommand, .sendCommand): return {
        guard case .sendCommand(let l) = lhs, case .sendCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setWindowVisible, .setWindowVisible): return {
        guard case .setWindowVisible(let l) = lhs, case .setWindowVisible(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createWindow, .createWindow): return {
        guard case .createWindow(let l) = lhs, case .createWindow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case invalidRequest // = 1
    case invalidConnectionID // = 2
    case invalidWindowID // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidRequest
      case 2: self = .invalidConnectionID
      case 3: self = .invalidWindowID
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidRequest: return 1
      case .invalidConnectionID: return 2
      case .invalidWindowID: return 3
      }
    }

  }

  struct ListConnections {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var connections: [Iterm2_TmuxResponse.ListConnections.Connection] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Connection {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var connectionID: String {
        get {return _connectionID ?? String()}
        set {_connectionID = newValue}
      }
      /// Returns true if `connectionID` has been explicitly set.
      var hasConnectionID: Bool {return self._connectionID != nil}
      /// Clears the value of `connectionID`. Subsequent reads from it will return its default value.
      mutating func clearConnectionID() {self._connectionID = nil}

      var owningSessionID: String {
        get {return _owningSessionID ?? String()}
        set {_owningSessionID = newValue}
      }
      /// Returns true if `owningSessionID` has been explicitly set.
      var hasOwningSessionID: Bool {return self._owningSessionID != nil}
      /// Clears the value of `owningSessionID`. Subsequent reads from it will return its default value.
      mutating func clearOwningSessionID() {self._owningSessionID = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _connectionID: String? = nil
      fileprivate var _owningSessionID: String? = nil
    }

    init() {}
  }

  struct SendCommand {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If not set, an error occurred.
    var output: String {
      get {return _output ?? String()}
      set {_output = newValue}
    }
    /// Returns true if `output` has been explicitly set.
    var hasOutput: Bool {return self._output != nil}
    /// Clears the value of `output`. Subsequent reads from it will return its default value.
    mutating func clearOutput() {self._output = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _output: String? = nil
  }

  struct SetWindowVisible {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct CreateWindow {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This is an iTerm2 tab ID.
    var tabID: String {
      get {return _tabID ?? String()}
      set {_tabID = newValue}
    }
    /// Returns true if `tabID` has been explicitly set.
    var hasTabID: Bool {return self._tabID != nil}
    /// Clears the value of `tabID`. Subsequent reads from it will return its default value.
    mutating func clearTabID() {self._tabID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _tabID: String? = nil
  }

  init() {}

  fileprivate var _status: Iterm2_TmuxResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_TmuxResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_GetBroadcastDomainsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_BroadcastDomain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_GetBroadcastDomainsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var broadcastDomains: [Iterm2_BroadcastDomain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_SetTabLayoutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tree structure must exactly match the actual tree structure, including the `vertical`
  /// setting. Only the grid_sizes may change. They must still add up to the same value in every
  /// dimension.
  var root: Iterm2_SplitTreeNode {
    get {return _root ?? Iterm2_SplitTreeNode()}
    set {_root = newValue}
  }
  /// Returns true if `root` has been explicitly set.
  var hasRoot: Bool {return self._root != nil}
  /// Clears the value of `root`. Subsequent reads from it will return its default value.
  mutating func clearRoot() {self._root = nil}

  var tabID: String {
    get {return _tabID ?? String()}
    set {_tabID = newValue}
  }
  /// Returns true if `tabID` has been explicitly set.
  var hasTabID: Bool {return self._tabID != nil}
  /// Clears the value of `tabID`. Subsequent reads from it will return its default value.
  mutating func clearTabID() {self._tabID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _root: Iterm2_SplitTreeNode? = nil
  fileprivate var _tabID: String? = nil
}

struct Iterm2_SetTabLayoutResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SetTabLayoutResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case badTabID // = 1
    case wrongTree // = 2
    case invalidSize // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .badTabID
      case 2: self = .wrongTree
      case 3: self = .invalidSize
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .badTabID: return 1
      case .wrongTree: return 2
      case .invalidSize: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_SetTabLayoutResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SetTabLayoutResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Invoke or ask for info about a menu item
struct Iterm2_MenuItemRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the menu item.
  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  /// If set do not actually invoke it. Just return its state.
  var queryOnly: Bool {
    get {return _queryOnly ?? false}
    set {_queryOnly = newValue}
  }
  /// Returns true if `queryOnly` has been explicitly set.
  var hasQueryOnly: Bool {return self._queryOnly != nil}
  /// Clears the value of `queryOnly`. Subsequent reads from it will return its default value.
  mutating func clearQueryOnly() {self._queryOnly = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identifier: String? = nil
  fileprivate var _queryOnly: Bool? = nil
}

struct Iterm2_MenuItemResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_MenuItemResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var checked: Bool {
    get {return _checked ?? false}
    set {_checked = newValue}
  }
  /// Returns true if `checked` has been explicitly set.
  var hasChecked: Bool {return self._checked != nil}
  /// Clears the value of `checked`. Subsequent reads from it will return its default value.
  mutating func clearChecked() {self._checked = nil}

  var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case badIdentifier // = 1
    case disabled // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .badIdentifier
      case 2: self = .disabled
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .badIdentifier: return 1
      case .disabled: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_MenuItemResponse.Status? = nil
  fileprivate var _checked: Bool? = nil
  fileprivate var _enabled: Bool? = nil
}

#if swift(>=4.2)

extension Iterm2_MenuItemResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_RestartSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "all" not allowed.
  var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  mutating func clearSessionID() {self._sessionID = nil}

  /// If set, then still-running sessions will fail to restart with SESSION_NOT_RESTARTABLE.
  /// If not set, then a still-running session gets killed and restarted.
  var onlyIfExited: Bool {
    get {return _onlyIfExited ?? false}
    set {_onlyIfExited = newValue}
  }
  /// Returns true if `onlyIfExited` has been explicitly set.
  var hasOnlyIfExited: Bool {return self._onlyIfExited != nil}
  /// Clears the value of `onlyIfExited`. Subsequent reads from it will return its default value.
  mutating func clearOnlyIfExited() {self._onlyIfExited = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionID: String? = nil
  fileprivate var _onlyIfExited: Bool? = nil
}

struct Iterm2_RestartSessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_RestartSessionResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1

    /// Some sessions, such as tmux integration sessions, are not restartable.
    /// Also, when `only_if_exited` is set in the request and the session is still running then this
    /// status will be returned.
    case sessionNotRestartable // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .sessionNotRestartable
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .sessionNotRestartable: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_RestartSessionResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_RestartSessionResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// This is the result of an iTerm2-to-script RPC call.
struct Iterm2_ServerOriginatedRPCResultRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String {
    get {return _requestID ?? String()}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  mutating func clearRequestID() {self._requestID = nil}

  var result: Iterm2_ServerOriginatedRPCResultRequest.OneOf_Result? = nil

  /// Exceptions should be dictionaries with a key of "reason" having a string value describing
  /// what went wrong.
  var jsonException: String {
    get {
      if case .jsonException(let v)? = result {return v}
      return String()
    }
    set {result = .jsonException(newValue)}
  }

  var jsonValue: String {
    get {
      if case .jsonValue(let v)? = result {return v}
      return String()
    }
    set {result = .jsonValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    /// Exceptions should be dictionaries with a key of "reason" having a string value describing
    /// what went wrong.
    case jsonException(String)
    case jsonValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_ServerOriginatedRPCResultRequest.OneOf_Result, rhs: Iterm2_ServerOriginatedRPCResultRequest.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.jsonException, .jsonException): return {
        guard case .jsonException(let l) = lhs, case .jsonException(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.jsonValue, .jsonValue): return {
        guard case .jsonValue(let l) = lhs, case .jsonValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _requestID: String? = nil
}

/// This simply acknowledges receipt of ServerOriginatedRPCResultRequest.
struct Iterm2_ServerOriginatedRPCResultResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Requests a list of all profiles.
struct Iterm2_ListProfilesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The profile properties to respond with. See SetProfilePropertyRequest for a list of values.
  /// If empty, all properties will be returned.
  var properties: [String] = []

  /// If empty, all profiles will be returned. Otherwise, only profiles with one of the listed
  /// GUIDs will be returned.
  var guids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_ListProfilesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var profiles: [Iterm2_ListProfilesResponse.Profile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Profile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var properties: [Iterm2_ProfileProperty] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Iterm2_FocusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_FocusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of notifications that completely describe the state of every tab and window and
  /// the application itself.
  var notifications: [Iterm2_FocusChangedNotification] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_SavedArrangementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Not used for LIST
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var action: Iterm2_SavedArrangementRequest.Action {
    get {return _action ?? .restore}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  /// If given and the action is SAVE then only the tabs in the identified window are saved.
  /// If given and the action is RESTORE then the arrangement will be restored as tabs in the identified window.
  /// Not used for LIST
  var windowID: String {
    get {return _windowID ?? String()}
    set {_windowID = newValue}
  }
  /// Returns true if `windowID` has been explicitly set.
  var hasWindowID: Bool {return self._windowID != nil}
  /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
  mutating func clearWindowID() {self._windowID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Restore an existing arrangement with the given name
    case restore // = 0

    /// Save windows to a new arrangement with the given name
    case save // = 1

    /// List arrangements
    case list // = 2

    init() {
      self = .restore
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .restore
      case 1: self = .save
      case 2: self = .list
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .restore: return 0
      case .save: return 1
      case .list: return 2
      }
    }

  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _action: Iterm2_SavedArrangementRequest.Action? = nil
  fileprivate var _windowID: String? = nil
}

#if swift(>=4.2)

extension Iterm2_SavedArrangementRequest.Action: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_SavedArrangementResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SavedArrangementResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var names: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0

    /// Tried to restore, but name doesn't exist
    case arrangementNotFound // = 1

    /// Bad window ID provided
    case windowNotFound // = 2
    case requestMalformed // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .arrangementNotFound
      case 2: self = .windowNotFound
      case 3: self = .requestMalformed
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .arrangementNotFound: return 1
      case .windowNotFound: return 2
      case .requestMalformed: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_SavedArrangementResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SavedArrangementResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_VariableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: Iterm2_VariableRequest.OneOf_Scope? = nil

  /// "all" is allowed only if no gets (only sets allowed)
  var sessionID: String {
    get {
      if case .sessionID(let v)? = scope {return v}
      return String()
    }
    set {scope = .sessionID(newValue)}
  }

  /// "all" is allowed only if no gets (only sets allowed)
  var tabID: String {
    get {
      if case .tabID(let v)? = scope {return v}
      return String()
    }
    set {scope = .tabID(newValue)}
  }

  var app: Bool {
    get {
      if case .app(let v)? = scope {return v}
      return false
    }
    set {scope = .app(newValue)}
  }

  /// "all" is allowed only if no gets (only sets allowed)
  var windowID: String {
    get {
      if case .windowID(let v)? = scope {return v}
      return String()
    }
    set {scope = .windowID(newValue)}
  }

  var set: [Iterm2_VariableRequest.Set] = []

  /// Set to special value "*" to get all in a JSON dictionary
  var get: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Scope: Equatable {
    /// "all" is allowed only if no gets (only sets allowed)
    case sessionID(String)
    /// "all" is allowed only if no gets (only sets allowed)
    case tabID(String)
    case app(Bool)
    /// "all" is allowed only if no gets (only sets allowed)
    case windowID(String)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_VariableRequest.OneOf_Scope, rhs: Iterm2_VariableRequest.OneOf_Scope) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tabID, .tabID): return {
        guard case .tabID(let l) = lhs, case .tabID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.app, .app): return {
        guard case .app(let l) = lhs, case .app(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowID, .windowID): return {
        guard case .windowID(let l) = lhs, case .windowID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    /// JSON encoded
    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _value: String? = nil
  }

  init() {}
}

struct Iterm2_VariableResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_VariableResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// 1:1 with get field in request.  JSON encoded, with null for unset variables.
  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1

    /// Names you set must begin with "user."
    case invalidName // = 2

    /// None of the scope oneof fields was set
    case missingScope // = 3
    case tabNotFound // = 4
    case multiGetDisallowed // = 5
    case windowNotFound // = 6

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .invalidName
      case 3: self = .missingScope
      case 4: self = .tabNotFound
      case 5: self = .multiGetDisallowed
      case 6: self = .windowNotFound
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .invalidName: return 2
      case .missingScope: return 3
      case .tabNotFound: return 4
      case .multiGetDisallowed: return 5
      case .windowNotFound: return 6
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_VariableResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_VariableResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_ActivateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// To activate the app without changing anything else omit the identifier.
  var identifier: Iterm2_ActivateRequest.OneOf_Identifier? = nil

  var windowID: String {
    get {
      if case .windowID(let v)? = identifier {return v}
      return String()
    }
    set {identifier = .windowID(newValue)}
  }

  var tabID: String {
    get {
      if case .tabID(let v)? = identifier {return v}
      return String()
    }
    set {identifier = .tabID(newValue)}
  }

  var sessionID: String {
    get {
      if case .sessionID(let v)? = identifier {return v}
      return String()
    }
    set {identifier = .sessionID(newValue)}
  }

  var orderWindowFront: Bool {
    get {return _orderWindowFront ?? false}
    set {_orderWindowFront = newValue}
  }
  /// Returns true if `orderWindowFront` has been explicitly set.
  var hasOrderWindowFront: Bool {return self._orderWindowFront != nil}
  /// Clears the value of `orderWindowFront`. Subsequent reads from it will return its default value.
  mutating func clearOrderWindowFront() {self._orderWindowFront = nil}

  /// This may be enabled if tab_id or session_id is set.
  var selectTab: Bool {
    get {return _selectTab ?? false}
    set {_selectTab = newValue}
  }
  /// Returns true if `selectTab` has been explicitly set.
  var hasSelectTab: Bool {return self._selectTab != nil}
  /// Clears the value of `selectTab`. Subsequent reads from it will return its default value.
  mutating func clearSelectTab() {self._selectTab = nil}

  /// This may be enabled if session_id is set.
  var selectSession: Bool {
    get {return _selectSession ?? false}
    set {_selectSession = newValue}
  }
  /// Returns true if `selectSession` has been explicitly set.
  var hasSelectSession: Bool {return self._selectSession != nil}
  /// Clears the value of `selectSession`. Subsequent reads from it will return its default value.
  mutating func clearSelectSession() {self._selectSession = nil}

  var activateApp: Iterm2_ActivateRequest.App {
    get {return _activateApp ?? Iterm2_ActivateRequest.App()}
    set {_activateApp = newValue}
  }
  /// Returns true if `activateApp` has been explicitly set.
  var hasActivateApp: Bool {return self._activateApp != nil}
  /// Clears the value of `activateApp`. Subsequent reads from it will return its default value.
  mutating func clearActivateApp() {self._activateApp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// To activate the app without changing anything else omit the identifier.
  enum OneOf_Identifier: Equatable {
    case windowID(String)
    case tabID(String)
    case sessionID(String)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_ActivateRequest.OneOf_Identifier, rhs: Iterm2_ActivateRequest.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.windowID, .windowID): return {
        guard case .windowID(let l) = lhs, case .windowID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tabID, .tabID): return {
        guard case .tabID(let l) = lhs, case .tabID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Activate the app?
  struct App {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var raiseAllWindows: Bool {
      get {return _raiseAllWindows ?? false}
      set {_raiseAllWindows = newValue}
    }
    /// Returns true if `raiseAllWindows` has been explicitly set.
    var hasRaiseAllWindows: Bool {return self._raiseAllWindows != nil}
    /// Clears the value of `raiseAllWindows`. Subsequent reads from it will return its default value.
    mutating func clearRaiseAllWindows() {self._raiseAllWindows = nil}

    var ignoringOtherApps: Bool {
      get {return _ignoringOtherApps ?? false}
      set {_ignoringOtherApps = newValue}
    }
    /// Returns true if `ignoringOtherApps` has been explicitly set.
    var hasIgnoringOtherApps: Bool {return self._ignoringOtherApps != nil}
    /// Clears the value of `ignoringOtherApps`. Subsequent reads from it will return its default value.
    mutating func clearIgnoringOtherApps() {self._ignoringOtherApps = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _raiseAllWindows: Bool? = nil
    fileprivate var _ignoringOtherApps: Bool? = nil
  }

  init() {}

  fileprivate var _orderWindowFront: Bool? = nil
  fileprivate var _selectTab: Bool? = nil
  fileprivate var _selectSession: Bool? = nil
  fileprivate var _activateApp: Iterm2_ActivateRequest.App? = nil
}

struct Iterm2_ActivateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_ActivateResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case badIdentifier // = 1
    case invalidOption // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .badIdentifier
      case 2: self = .invalidOption
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .badIdentifier: return 1
      case .invalidOption: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_ActivateResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_ActivateResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Injects bytes as input to the terminal, as though the running program had produced them.
struct Iterm2_InjectRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: [String] = []

  var data: Data {
    get {return _data ?? Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: Data? = nil
}

struct Iterm2_InjectResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One status per session_id in the request
  var status: [Iterm2_InjectResponse.Status] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Iterm2_InjectResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_GetPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The kind of ID that's set determines the kind of object you're querying.
  var identifier: Iterm2_GetPropertyRequest.OneOf_Identifier? = nil

  var windowID: String {
    get {
      if case .windowID(let v)? = identifier {return v}
      return String()
    }
    set {identifier = .windowID(newValue)}
  }

  /// Does not accept "all". Accepts "active".
  var sessionID: String {
    get {
      if case .sessionID(let v)? = identifier {return v}
      return String()
    }
    set {identifier = .sessionID(newValue)}
  }

  /// For sessions:
  /// "grid_size" -> { "width": number, "height": number }
  /// "buried" -> boolean
  /// "number_of_lines" -> { "overflow": number, "grid": number, "history": number }
  ///
  /// For windows:
  /// "frame" -> { "origin": { "x": number, "y": number }, "size": { "width": number, "height": number } }
  /// "fullscreen" -> boolean
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of ID that's set determines the kind of object you're querying.
  enum OneOf_Identifier: Equatable {
    case windowID(String)
    /// Does not accept "all". Accepts "active".
    case sessionID(String)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_GetPropertyRequest.OneOf_Identifier, rhs: Iterm2_GetPropertyRequest.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.windowID, .windowID): return {
        guard case .windowID(let l) = lhs, case .windowID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _name: String? = nil
}

struct Iterm2_GetPropertyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name           Example value
  /// -------------  ---------------
  /// frame          { "origin": { "x": 0, "y": 0 }, "size": { "width": 1024, "height": 768 }}
  /// fullscreen     true, false
  ///
  /// For sessions:
  /// grid_size      { "width": 80, "height": 25 }
  /// buried         true
  var status: Iterm2_GetPropertyResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var jsonValue: String {
    get {return _jsonValue ?? String()}
    set {_jsonValue = newValue}
  }
  /// Returns true if `jsonValue` has been explicitly set.
  var hasJsonValue: Bool {return self._jsonValue != nil}
  /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
  mutating func clearJsonValue() {self._jsonValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case unrecognizedName // = 1
    case invalidTarget // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .unrecognizedName
      case 2: self = .invalidTarget
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .unrecognizedName: return 1
      case .invalidTarget: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_GetPropertyResponse.Status? = nil
  fileprivate var _jsonValue: String? = nil
}

#if swift(>=4.2)

extension Iterm2_GetPropertyResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_SetPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Eventually you'll be able to set properties on other things besides The kind of ID that's set
  /// determines the kind of object you're updating.
  var identifier: Iterm2_SetPropertyRequest.OneOf_Identifier? = nil

  var windowID: String {
    get {
      if case .windowID(let v)? = identifier {return v}
      return String()
    }
    set {identifier = .windowID(newValue)}
  }

  /// Accepts "all" and "active"
  var sessionID: String {
    get {
      if case .sessionID(let v)? = identifier {return v}
      return String()
    }
    set {identifier = .sessionID(newValue)}
  }

  /// For windows:
  /// Name           Example JSON
  /// -------------  ---------------
  /// frame          { "origin": { "x": 0, "y": 0 }, "size": { "width": 1024, "height": 768 }}
  /// fullscreen     true, false
  ///
  /// For sessions:
  /// grid_size      { "width": 80, "height": 25 }
  /// buried         true
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var jsonValue: String {
    get {return _jsonValue ?? String()}
    set {_jsonValue = newValue}
  }
  /// Returns true if `jsonValue` has been explicitly set.
  var hasJsonValue: Bool {return self._jsonValue != nil}
  /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
  mutating func clearJsonValue() {self._jsonValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Eventually you'll be able to set properties on other things besides The kind of ID that's set
  /// determines the kind of object you're updating.
  enum OneOf_Identifier: Equatable {
    case windowID(String)
    /// Accepts "all" and "active"
    case sessionID(String)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_SetPropertyRequest.OneOf_Identifier, rhs: Iterm2_SetPropertyRequest.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.windowID, .windowID): return {
        guard case .windowID(let l) = lhs, case .windowID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _jsonValue: String? = nil
}

struct Iterm2_SetPropertyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SetPropertyResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case unrecognizedName // = 1

    /// e.g., bad JSON value
    case invalidValue // = 2

    /// e.g., bogus window_id
    case invalidTarget // = 3

    /// Operation can't be performed immediately. Will be tried later. For example, resizing a session during instant replay.
    case deferred // = 4

    /// Can't be done. For example, resizing a session in a full-screen window.
    case impossible // = 5

    /// Did our best and failed. For example, sometimes toggling full-screen fails if another window is also toggling. Maybe try again?
    case failed // = 6

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .unrecognizedName
      case 2: self = .invalidValue
      case 3: self = .invalidTarget
      case 4: self = .deferred
      case 5: self = .impossible
      case 6: self = .failed
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .unrecognizedName: return 1
      case .invalidValue: return 2
      case .invalidTarget: return 3
      case .deferred: return 4
      case .impossible: return 5
      case .failed: return 6
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_SetPropertyResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SetPropertyResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Registers a toolbelt tool that displays a webview with a URL of your choice.
struct Iterm2_RegisterToolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This name is displayed to the user.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// The tool's identifier should be unique. Prefix it with your app bundle. For example:
  /// com.example.mytool
  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  /// The first time a tool is registered iTerm2 automatically adds it to the
  /// set of visible tools. To show it on subsequent re-registrations, set this
  /// to true. If the toolbelt itself is hidden, it will not be opened.
  var revealIfAlreadyRegistered: Bool {
    get {return _revealIfAlreadyRegistered ?? false}
    set {_revealIfAlreadyRegistered = newValue}
  }
  /// Returns true if `revealIfAlreadyRegistered` has been explicitly set.
  var hasRevealIfAlreadyRegistered: Bool {return self._revealIfAlreadyRegistered != nil}
  /// Clears the value of `revealIfAlreadyRegistered`. Subsequent reads from it will return its default value.
  mutating func clearRevealIfAlreadyRegistered() {self._revealIfAlreadyRegistered = nil}

  var toolType: Iterm2_RegisterToolRequest.ToolType {
    get {return _toolType ?? .webViewTool}
    set {_toolType = newValue}
  }
  /// Returns true if `toolType` has been explicitly set.
  var hasToolType: Bool {return self._toolType != nil}
  /// Clears the value of `toolType`. Subsequent reads from it will return its default value.
  mutating func clearToolType() {self._toolType = nil}

  /// For web view tools: The URL loaded at startup
  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ToolType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case webViewTool // = 1

    init() {
      self = .webViewTool
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .webViewTool
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .webViewTool: return 1
      }
    }

  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _identifier: String? = nil
  fileprivate var _revealIfAlreadyRegistered: Bool? = nil
  fileprivate var _toolType: Iterm2_RegisterToolRequest.ToolType? = nil
  fileprivate var _url: String? = nil
}

#if swift(>=4.2)

extension Iterm2_RegisterToolRequest.ToolType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Describes an RPC from iTerm2 to script. I don't want to invent my own type
/// system so this is dynamically typed, which matches Python well enough.
struct Iterm2_RPCRegistrationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var arguments: [Iterm2_RPCRegistrationRequest.RPCArgumentSignature] = []

  var defaults: [Iterm2_RPCRegistrationRequest.RPCArgument] = []

  /// If not specified, iTerm2 decides based on its built-in default.
  var timeout: Float {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  var role: Iterm2_RPCRegistrationRequest.Role {
    get {return _role ?? .generic}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  mutating func clearRole() {self._role = nil}

  var roleSpecificAttributes: Iterm2_RPCRegistrationRequest.OneOf_RoleSpecificAttributes? = nil

  var sessionTitleAttributes: Iterm2_RPCRegistrationRequest.SessionTitleAttributes {
    get {
      if case .sessionTitleAttributes(let v)? = roleSpecificAttributes {return v}
      return Iterm2_RPCRegistrationRequest.SessionTitleAttributes()
    }
    set {roleSpecificAttributes = .sessionTitleAttributes(newValue)}
  }

  var statusBarComponentAttributes: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes {
    get {
      if case .statusBarComponentAttributes(let v)? = roleSpecificAttributes {return v}
      return Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes()
    }
    set {roleSpecificAttributes = .statusBarComponentAttributes(newValue)}
  }

  var contextMenuAttributes: Iterm2_RPCRegistrationRequest.ContextMenuAttributes {
    get {
      if case .contextMenuAttributes(let v)? = roleSpecificAttributes {return v}
      return Iterm2_RPCRegistrationRequest.ContextMenuAttributes()
    }
    set {roleSpecificAttributes = .contextMenuAttributes(newValue)}
  }

  var displayName: String {
    get {return _displayName ?? String()}
    set {_displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  var hasDisplayName: Bool {return self._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  mutating func clearDisplayName() {self._displayName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_RoleSpecificAttributes: Equatable {
    case sessionTitleAttributes(Iterm2_RPCRegistrationRequest.SessionTitleAttributes)
    case statusBarComponentAttributes(Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes)
    case contextMenuAttributes(Iterm2_RPCRegistrationRequest.ContextMenuAttributes)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_RPCRegistrationRequest.OneOf_RoleSpecificAttributes, rhs: Iterm2_RPCRegistrationRequest.OneOf_RoleSpecificAttributes) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionTitleAttributes, .sessionTitleAttributes): return {
        guard case .sessionTitleAttributes(let l) = lhs, case .sessionTitleAttributes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusBarComponentAttributes, .statusBarComponentAttributes): return {
        guard case .statusBarComponentAttributes(let l) = lhs, case .statusBarComponentAttributes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contextMenuAttributes, .contextMenuAttributes): return {
        guard case .contextMenuAttributes(let l) = lhs, case .contextMenuAttributes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum Role: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case generic // = 1
    case sessionTitle // = 2
    case statusBarComponent // = 3
    case contextMenu // = 4

    init() {
      self = .generic
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .generic
      case 2: self = .sessionTitle
      case 3: self = .statusBarComponent
      case 4: self = .contextMenu
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .generic: return 1
      case .sessionTitle: return 2
      case .statusBarComponent: return 3
      case .contextMenu: return 4
      }
    }

  }

  struct RPCArgumentSignature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
  }

  struct RPCArgument {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var path: String {
      get {return _path ?? String()}
      set {_path = newValue}
    }
    /// Returns true if `path` has been explicitly set.
    var hasPath: Bool {return self._path != nil}
    /// Clears the value of `path`. Subsequent reads from it will return its default value.
    mutating func clearPath() {self._path = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _path: String? = nil
  }

  struct SessionTitleAttributes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Used by SESSION_TITLE to control name in Preferences menu
    var displayName: String {
      get {return _displayName ?? String()}
      set {_displayName = newValue}
    }
    /// Returns true if `displayName` has been explicitly set.
    var hasDisplayName: Bool {return self._displayName != nil}
    /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
    mutating func clearDisplayName() {self._displayName = nil}

    /// Identifies this title provider uniquely. Must not conflict with other title providers.
    /// Use a backwards domain name identifying yourself and the feature, like "com.example.featurename"
    var uniqueIdentifier: String {
      get {return _uniqueIdentifier ?? String()}
      set {_uniqueIdentifier = newValue}
    }
    /// Returns true if `uniqueIdentifier` has been explicitly set.
    var hasUniqueIdentifier: Bool {return self._uniqueIdentifier != nil}
    /// Clears the value of `uniqueIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearUniqueIdentifier() {self._uniqueIdentifier = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _displayName: String? = nil
    fileprivate var _uniqueIdentifier: String? = nil
  }

  struct StatusBarComponentAttributes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Used by STATUS_BAR_COMPONENT
    var shortDescription: String {
      get {return _shortDescription ?? String()}
      set {_shortDescription = newValue}
    }
    /// Returns true if `shortDescription` has been explicitly set.
    var hasShortDescription: Bool {return self._shortDescription != nil}
    /// Clears the value of `shortDescription`. Subsequent reads from it will return its default value.
    mutating func clearShortDescription() {self._shortDescription = nil}

    var detailedDescription: String {
      get {return _detailedDescription ?? String()}
      set {_detailedDescription = newValue}
    }
    /// Returns true if `detailedDescription` has been explicitly set.
    var hasDetailedDescription: Bool {return self._detailedDescription != nil}
    /// Clears the value of `detailedDescription`. Subsequent reads from it will return its default value.
    mutating func clearDetailedDescription() {self._detailedDescription = nil}

    var knobs: [Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob] = []

    var exemplar: String {
      get {return _exemplar ?? String()}
      set {_exemplar = newValue}
    }
    /// Returns true if `exemplar` has been explicitly set.
    var hasExemplar: Bool {return self._exemplar != nil}
    /// Clears the value of `exemplar`. Subsequent reads from it will return its default value.
    mutating func clearExemplar() {self._exemplar = nil}

    var updateCadence: Float {
      get {return _updateCadence ?? 0}
      set {_updateCadence = newValue}
    }
    /// Returns true if `updateCadence` has been explicitly set.
    var hasUpdateCadence: Bool {return self._updateCadence != nil}
    /// Clears the value of `updateCadence`. Subsequent reads from it will return its default value.
    mutating func clearUpdateCadence() {self._updateCadence = nil}

    /// Identifies this component uniquely. Must not conflict with other components.
    /// Use a backwards domain name identifying yourself and the feature, like "com.example.featurename"
    var uniqueIdentifier: String {
      get {return _uniqueIdentifier ?? String()}
      set {_uniqueIdentifier = newValue}
    }
    /// Returns true if `uniqueIdentifier` has been explicitly set.
    var hasUniqueIdentifier: Bool {return self._uniqueIdentifier != nil}
    /// Clears the value of `uniqueIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearUniqueIdentifier() {self._uniqueIdentifier = nil}

    var icons: [Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Icon] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Knob {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      var hasName: Bool {return self._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      mutating func clearName() {self._name = nil}

      var type: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob.TypeEnum {
        get {return _type ?? .checkbox}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var placeholder: String {
        get {return _placeholder ?? String()}
        set {_placeholder = newValue}
      }
      /// Returns true if `placeholder` has been explicitly set.
      var hasPlaceholder: Bool {return self._placeholder != nil}
      /// Clears the value of `placeholder`. Subsequent reads from it will return its default value.
      mutating func clearPlaceholder() {self._placeholder = nil}

      var jsonDefaultValue: String {
        get {return _jsonDefaultValue ?? String()}
        set {_jsonDefaultValue = newValue}
      }
      /// Returns true if `jsonDefaultValue` has been explicitly set.
      var hasJsonDefaultValue: Bool {return self._jsonDefaultValue != nil}
      /// Clears the value of `jsonDefaultValue`. Subsequent reads from it will return its default value.
      mutating func clearJsonDefaultValue() {self._jsonDefaultValue = nil}

      var key: String {
        get {return _key ?? String()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case checkbox // = 1
        case string // = 2
        case positiveFloatingPoint // = 3
        case color // = 4

        init() {
          self = .checkbox
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 1: self = .checkbox
          case 2: self = .string
          case 3: self = .positiveFloatingPoint
          case 4: self = .color
          default: return nil
          }
        }

        var rawValue: Int {
          switch self {
          case .checkbox: return 1
          case .string: return 2
          case .positiveFloatingPoint: return 3
          case .color: return 4
          }
        }

      }

      init() {}

      fileprivate var _name: String? = nil
      fileprivate var _type: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob.TypeEnum? = nil
      fileprivate var _placeholder: String? = nil
      fileprivate var _jsonDefaultValue: String? = nil
      fileprivate var _key: String? = nil
    }

    struct Icon {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var data: Data {
        get {return _data ?? Data()}
        set {_data = newValue}
      }
      /// Returns true if `data` has been explicitly set.
      var hasData: Bool {return self._data != nil}
      /// Clears the value of `data`. Subsequent reads from it will return its default value.
      mutating func clearData() {self._data = nil}

      var scale: Float {
        get {return _scale ?? 0}
        set {_scale = newValue}
      }
      /// Returns true if `scale` has been explicitly set.
      var hasScale: Bool {return self._scale != nil}
      /// Clears the value of `scale`. Subsequent reads from it will return its default value.
      mutating func clearScale() {self._scale = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _data: Data? = nil
      fileprivate var _scale: Float? = nil
    }

    init() {}

    fileprivate var _shortDescription: String? = nil
    fileprivate var _detailedDescription: String? = nil
    fileprivate var _exemplar: String? = nil
    fileprivate var _updateCadence: Float? = nil
    fileprivate var _uniqueIdentifier: String? = nil
  }

  struct ContextMenuAttributes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var displayName: String {
      get {return _displayName ?? String()}
      set {_displayName = newValue}
    }
    /// Returns true if `displayName` has been explicitly set.
    var hasDisplayName: Bool {return self._displayName != nil}
    /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
    mutating func clearDisplayName() {self._displayName = nil}

    var uniqueIdentifier: String {
      get {return _uniqueIdentifier ?? String()}
      set {_uniqueIdentifier = newValue}
    }
    /// Returns true if `uniqueIdentifier` has been explicitly set.
    var hasUniqueIdentifier: Bool {return self._uniqueIdentifier != nil}
    /// Clears the value of `uniqueIdentifier`. Subsequent reads from it will return its default value.
    mutating func clearUniqueIdentifier() {self._uniqueIdentifier = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _displayName: String? = nil
    fileprivate var _uniqueIdentifier: String? = nil
  }

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _timeout: Float? = nil
  fileprivate var _role: Iterm2_RPCRegistrationRequest.Role? = nil
  fileprivate var _displayName: String? = nil
}

#if swift(>=4.2)

extension Iterm2_RPCRegistrationRequest.Role: CaseIterable {
  // Support synthesized by the compiler.
}

extension Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_RegisterToolResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_RegisterToolResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case requestMalformed // = 1
    case permissionDenied // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .requestMalformed
      case 2: self = .permissionDenied
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .requestMalformed: return 1
      case .permissionDenied: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_RegisterToolResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_RegisterToolResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_KeystrokePattern {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The keystroke matches the pattern if it has all the required and none of the forbidden modifiers.
  var requiredModifiers: [Iterm2_Modifiers] = []

  var forbiddenModifiers: [Iterm2_Modifiers] = []

  /// The pattern matches if the keystroke has any of these keycodes:
  var keycodes: [Int32] = []

  /// The pattern matches if the keystroke equals of any of these characters:
  var characters: [String] = []

  /// The pattern matches if the keystroke equals any of these characters ignoring modifiers.
  /// This is Apple parlance for "ignoring the shift key plus various other undocumented things"
  var charactersIgnoringModifiers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_KeystrokeMonitorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// KeystrokeFilterRequest was split from this to make a more sensible API.
  var patternsToIgnore: [Iterm2_KeystrokePattern] = []

  /// If false, then only key-down events are sent. If true, key-down, key-up, and flags-changed events are sent.
  var advanced: Bool {
    get {return _advanced ?? false}
    set {_advanced = newValue}
  }
  /// Returns true if `advanced` has been explicitly set.
  var hasAdvanced: Bool {return self._advanced != nil}
  /// Clears the value of `advanced`. Subsequent reads from it will return its default value.
  mutating func clearAdvanced() {self._advanced = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _advanced: Bool? = nil
}

struct Iterm2_KeystrokeFilterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If a keystroke matches any of these patterns then they will not be handled by the application.
  /// A notification will be posted and the script can handle it as it pleases.
  var patternsToIgnore: [Iterm2_KeystrokePattern] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_VariableMonitorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var scope: Iterm2_VariableScope {
    get {return _scope ?? .session}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {self._scope = nil}

  /// Session, Window, or Tab identifier.
  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _scope: Iterm2_VariableScope? = nil
  fileprivate var _identifier: String? = nil
}

struct Iterm2_ProfileChangeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var guid: String {
    get {return _guid ?? String()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  mutating func clearGuid() {self._guid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _guid: String? = nil
}

struct Iterm2_PromptMonitorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var modes: [Iterm2_PromptMonitorMode] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_NotificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See documentation on session IDs. NOTIFY_ON_NEW_SESSION, NOTIFY_ON_TERMINATE_SESSION, and
  /// NOTIFY_ON_LAYOUT_CHANGE do not use the session ID and are posted on all such events.
  ///
  /// NOTE: This is not used for NOTIFY_ON_VARIABLE_CHANGE.
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  /// Set to true to subscribe, false to unsubscribe.
  var subscribe: Bool {
    get {return _subscribe ?? false}
    set {_subscribe = newValue}
  }
  /// Returns true if `subscribe` has been explicitly set.
  var hasSubscribe: Bool {return self._subscribe != nil}
  /// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
  mutating func clearSubscribe() {self._subscribe = nil}

  /// When to be notified (or notification to unsubscribe from)
  var notificationType: Iterm2_NotificationType {
    get {return _notificationType ?? .notifyOnKeystroke}
    set {_notificationType = newValue}
  }
  /// Returns true if `notificationType` has been explicitly set.
  var hasNotificationType: Bool {return self._notificationType != nil}
  /// Clears the value of `notificationType`. Subsequent reads from it will return its default value.
  mutating func clearNotificationType() {self._notificationType = nil}

  var arguments: Iterm2_NotificationRequest.OneOf_Arguments? = nil

  /// For NOTIFY_ON_SERVER_ORIGINATED_RPC
  var rpcRegistrationRequest: Iterm2_RPCRegistrationRequest {
    get {
      if case .rpcRegistrationRequest(let v)? = arguments {return v}
      return Iterm2_RPCRegistrationRequest()
    }
    set {arguments = .rpcRegistrationRequest(newValue)}
  }

  var keystrokeMonitorRequest: Iterm2_KeystrokeMonitorRequest {
    get {
      if case .keystrokeMonitorRequest(let v)? = arguments {return v}
      return Iterm2_KeystrokeMonitorRequest()
    }
    set {arguments = .keystrokeMonitorRequest(newValue)}
  }

  var variableMonitorRequest: Iterm2_VariableMonitorRequest {
    get {
      if case .variableMonitorRequest(let v)? = arguments {return v}
      return Iterm2_VariableMonitorRequest()
    }
    set {arguments = .variableMonitorRequest(newValue)}
  }

  var profileChangeRequest: Iterm2_ProfileChangeRequest {
    get {
      if case .profileChangeRequest(let v)? = arguments {return v}
      return Iterm2_ProfileChangeRequest()
    }
    set {arguments = .profileChangeRequest(newValue)}
  }

  var keystrokeFilterRequest: Iterm2_KeystrokeFilterRequest {
    get {
      if case .keystrokeFilterRequest(let v)? = arguments {return v}
      return Iterm2_KeystrokeFilterRequest()
    }
    set {arguments = .keystrokeFilterRequest(newValue)}
  }

  var promptMonitorRequest: Iterm2_PromptMonitorRequest {
    get {
      if case .promptMonitorRequest(let v)? = arguments {return v}
      return Iterm2_PromptMonitorRequest()
    }
    set {arguments = .promptMonitorRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Arguments: Equatable {
    /// For NOTIFY_ON_SERVER_ORIGINATED_RPC
    case rpcRegistrationRequest(Iterm2_RPCRegistrationRequest)
    case keystrokeMonitorRequest(Iterm2_KeystrokeMonitorRequest)
    case variableMonitorRequest(Iterm2_VariableMonitorRequest)
    case profileChangeRequest(Iterm2_ProfileChangeRequest)
    case keystrokeFilterRequest(Iterm2_KeystrokeFilterRequest)
    case promptMonitorRequest(Iterm2_PromptMonitorRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_NotificationRequest.OneOf_Arguments, rhs: Iterm2_NotificationRequest.OneOf_Arguments) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rpcRegistrationRequest, .rpcRegistrationRequest): return {
        guard case .rpcRegistrationRequest(let l) = lhs, case .rpcRegistrationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keystrokeMonitorRequest, .keystrokeMonitorRequest): return {
        guard case .keystrokeMonitorRequest(let l) = lhs, case .keystrokeMonitorRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.variableMonitorRequest, .variableMonitorRequest): return {
        guard case .variableMonitorRequest(let l) = lhs, case .variableMonitorRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profileChangeRequest, .profileChangeRequest): return {
        guard case .profileChangeRequest(let l) = lhs, case .profileChangeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keystrokeFilterRequest, .keystrokeFilterRequest): return {
        guard case .keystrokeFilterRequest(let l) = lhs, case .keystrokeFilterRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.promptMonitorRequest, .promptMonitorRequest): return {
        guard case .promptMonitorRequest(let l) = lhs, case .promptMonitorRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _subscribe: Bool? = nil
  fileprivate var _notificationType: Iterm2_NotificationType? = nil
}

struct Iterm2_NotificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_NotificationResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case requestMalformed // = 2
    case notSubscribed // = 3
    case alreadySubscribed // = 4
    case duplicateServerOriginatedRpc // = 5
    case invalidIdentifier // = 6

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .requestMalformed
      case 3: self = .notSubscribed
      case 4: self = .alreadySubscribed
      case 5: self = .duplicateServerOriginatedRpc
      case 6: self = .invalidIdentifier
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .requestMalformed: return 2
      case .notSubscribed: return 3
      case .alreadySubscribed: return 4
      case .duplicateServerOriginatedRpc: return 5
      case .invalidIdentifier: return 6
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_NotificationResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_NotificationResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keystrokeNotification: Iterm2_KeystrokeNotification {
    get {return _storage._keystrokeNotification ?? Iterm2_KeystrokeNotification()}
    set {_uniqueStorage()._keystrokeNotification = newValue}
  }
  /// Returns true if `keystrokeNotification` has been explicitly set.
  var hasKeystrokeNotification: Bool {return _storage._keystrokeNotification != nil}
  /// Clears the value of `keystrokeNotification`. Subsequent reads from it will return its default value.
  mutating func clearKeystrokeNotification() {_uniqueStorage()._keystrokeNotification = nil}

  var screenUpdateNotification: Iterm2_ScreenUpdateNotification {
    get {return _storage._screenUpdateNotification ?? Iterm2_ScreenUpdateNotification()}
    set {_uniqueStorage()._screenUpdateNotification = newValue}
  }
  /// Returns true if `screenUpdateNotification` has been explicitly set.
  var hasScreenUpdateNotification: Bool {return _storage._screenUpdateNotification != nil}
  /// Clears the value of `screenUpdateNotification`. Subsequent reads from it will return its default value.
  mutating func clearScreenUpdateNotification() {_uniqueStorage()._screenUpdateNotification = nil}

  var promptNotification: Iterm2_PromptNotification {
    get {return _storage._promptNotification ?? Iterm2_PromptNotification()}
    set {_uniqueStorage()._promptNotification = newValue}
  }
  /// Returns true if `promptNotification` has been explicitly set.
  var hasPromptNotification: Bool {return _storage._promptNotification != nil}
  /// Clears the value of `promptNotification`. Subsequent reads from it will return its default value.
  mutating func clearPromptNotification() {_uniqueStorage()._promptNotification = nil}

  var locationChangeNotification: Iterm2_LocationChangeNotification {
    get {return _storage._locationChangeNotification ?? Iterm2_LocationChangeNotification()}
    set {_uniqueStorage()._locationChangeNotification = newValue}
  }
  /// Returns true if `locationChangeNotification` has been explicitly set.
  var hasLocationChangeNotification: Bool {return _storage._locationChangeNotification != nil}
  /// Clears the value of `locationChangeNotification`. Subsequent reads from it will return its default value.
  mutating func clearLocationChangeNotification() {_uniqueStorage()._locationChangeNotification = nil}

  var customEscapeSequenceNotification: Iterm2_CustomEscapeSequenceNotification {
    get {return _storage._customEscapeSequenceNotification ?? Iterm2_CustomEscapeSequenceNotification()}
    set {_uniqueStorage()._customEscapeSequenceNotification = newValue}
  }
  /// Returns true if `customEscapeSequenceNotification` has been explicitly set.
  var hasCustomEscapeSequenceNotification: Bool {return _storage._customEscapeSequenceNotification != nil}
  /// Clears the value of `customEscapeSequenceNotification`. Subsequent reads from it will return its default value.
  mutating func clearCustomEscapeSequenceNotification() {_uniqueStorage()._customEscapeSequenceNotification = nil}

  var newSessionNotification: Iterm2_NewSessionNotification {
    get {return _storage._newSessionNotification ?? Iterm2_NewSessionNotification()}
    set {_uniqueStorage()._newSessionNotification = newValue}
  }
  /// Returns true if `newSessionNotification` has been explicitly set.
  var hasNewSessionNotification: Bool {return _storage._newSessionNotification != nil}
  /// Clears the value of `newSessionNotification`. Subsequent reads from it will return its default value.
  mutating func clearNewSessionNotification() {_uniqueStorage()._newSessionNotification = nil}

  var terminateSessionNotification: Iterm2_TerminateSessionNotification {
    get {return _storage._terminateSessionNotification ?? Iterm2_TerminateSessionNotification()}
    set {_uniqueStorage()._terminateSessionNotification = newValue}
  }
  /// Returns true if `terminateSessionNotification` has been explicitly set.
  var hasTerminateSessionNotification: Bool {return _storage._terminateSessionNotification != nil}
  /// Clears the value of `terminateSessionNotification`. Subsequent reads from it will return its default value.
  mutating func clearTerminateSessionNotification() {_uniqueStorage()._terminateSessionNotification = nil}

  var layoutChangedNotification: Iterm2_LayoutChangedNotification {
    get {return _storage._layoutChangedNotification ?? Iterm2_LayoutChangedNotification()}
    set {_uniqueStorage()._layoutChangedNotification = newValue}
  }
  /// Returns true if `layoutChangedNotification` has been explicitly set.
  var hasLayoutChangedNotification: Bool {return _storage._layoutChangedNotification != nil}
  /// Clears the value of `layoutChangedNotification`. Subsequent reads from it will return its default value.
  mutating func clearLayoutChangedNotification() {_uniqueStorage()._layoutChangedNotification = nil}

  var focusChangedNotification: Iterm2_FocusChangedNotification {
    get {return _storage._focusChangedNotification ?? Iterm2_FocusChangedNotification()}
    set {_uniqueStorage()._focusChangedNotification = newValue}
  }
  /// Returns true if `focusChangedNotification` has been explicitly set.
  var hasFocusChangedNotification: Bool {return _storage._focusChangedNotification != nil}
  /// Clears the value of `focusChangedNotification`. Subsequent reads from it will return its default value.
  mutating func clearFocusChangedNotification() {_uniqueStorage()._focusChangedNotification = nil}

  var serverOriginatedRpcNotification: Iterm2_ServerOriginatedRPCNotification {
    get {return _storage._serverOriginatedRpcNotification ?? Iterm2_ServerOriginatedRPCNotification()}
    set {_uniqueStorage()._serverOriginatedRpcNotification = newValue}
  }
  /// Returns true if `serverOriginatedRpcNotification` has been explicitly set.
  var hasServerOriginatedRpcNotification: Bool {return _storage._serverOriginatedRpcNotification != nil}
  /// Clears the value of `serverOriginatedRpcNotification`. Subsequent reads from it will return its default value.
  mutating func clearServerOriginatedRpcNotification() {_uniqueStorage()._serverOriginatedRpcNotification = nil}

  var broadcastDomainsChanged: Iterm2_BroadcastDomainsChangedNotification {
    get {return _storage._broadcastDomainsChanged ?? Iterm2_BroadcastDomainsChangedNotification()}
    set {_uniqueStorage()._broadcastDomainsChanged = newValue}
  }
  /// Returns true if `broadcastDomainsChanged` has been explicitly set.
  var hasBroadcastDomainsChanged: Bool {return _storage._broadcastDomainsChanged != nil}
  /// Clears the value of `broadcastDomainsChanged`. Subsequent reads from it will return its default value.
  mutating func clearBroadcastDomainsChanged() {_uniqueStorage()._broadcastDomainsChanged = nil}

  var variableChangedNotification: Iterm2_VariableChangedNotification {
    get {return _storage._variableChangedNotification ?? Iterm2_VariableChangedNotification()}
    set {_uniqueStorage()._variableChangedNotification = newValue}
  }
  /// Returns true if `variableChangedNotification` has been explicitly set.
  var hasVariableChangedNotification: Bool {return _storage._variableChangedNotification != nil}
  /// Clears the value of `variableChangedNotification`. Subsequent reads from it will return its default value.
  mutating func clearVariableChangedNotification() {_uniqueStorage()._variableChangedNotification = nil}

  var profileChangedNotification: Iterm2_ProfileChangedNotification {
    get {return _storage._profileChangedNotification ?? Iterm2_ProfileChangedNotification()}
    set {_uniqueStorage()._profileChangedNotification = newValue}
  }
  /// Returns true if `profileChangedNotification` has been explicitly set.
  var hasProfileChangedNotification: Bool {return _storage._profileChangedNotification != nil}
  /// Clears the value of `profileChangedNotification`. Subsequent reads from it will return its default value.
  mutating func clearProfileChangedNotification() {_uniqueStorage()._profileChangedNotification = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Iterm2_ProfileChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var guid: String {
    get {return _guid ?? String()}
    set {_guid = newValue}
  }
  /// Returns true if `guid` has been explicitly set.
  var hasGuid: Bool {return self._guid != nil}
  /// Clears the value of `guid`. Subsequent reads from it will return its default value.
  mutating func clearGuid() {self._guid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _guid: String? = nil
}

struct Iterm2_VariableChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: Iterm2_VariableScope {
    get {return _scope ?? .session}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {self._scope = nil}

  /// unset if app scope, otherwise is session, window, or tab ID
  var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  mutating func clearIdentifier() {self._identifier = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Will be "null" if unset.
  var jsonNewValue: String {
    get {return _jsonNewValue ?? String()}
    set {_jsonNewValue = newValue}
  }
  /// Returns true if `jsonNewValue` has been explicitly set.
  var hasJsonNewValue: Bool {return self._jsonNewValue != nil}
  /// Clears the value of `jsonNewValue`. Subsequent reads from it will return its default value.
  mutating func clearJsonNewValue() {self._jsonNewValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scope: Iterm2_VariableScope? = nil
  fileprivate var _identifier: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _jsonNewValue: String? = nil
}

struct Iterm2_BroadcastDomainsChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var broadcastDomains: [Iterm2_BroadcastDomain] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_ServerOriginatedRPC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var arguments: [Iterm2_ServerOriginatedRPC.RPCArgument] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RPCArgument {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var jsonValue: String {
      get {return _jsonValue ?? String()}
      set {_jsonValue = newValue}
    }
    /// Returns true if `jsonValue` has been explicitly set.
    var hasJsonValue: Bool {return self._jsonValue != nil}
    /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
    mutating func clearJsonValue() {self._jsonValue = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _jsonValue: String? = nil
  }

  init() {}

  fileprivate var _name: String? = nil
}

/// This is an iTerm2-to-script RPC call. The script must have registered for
/// an RPC matching the signature of `rpc`.
struct Iterm2_ServerOriginatedRPCNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String {
    get {return _requestID ?? String()}
    set {_requestID = newValue}
  }
  /// Returns true if `requestID` has been explicitly set.
  var hasRequestID: Bool {return self._requestID != nil}
  /// Clears the value of `requestID`. Subsequent reads from it will return its default value.
  mutating func clearRequestID() {self._requestID = nil}

  var rpc: Iterm2_ServerOriginatedRPC {
    get {return _rpc ?? Iterm2_ServerOriginatedRPC()}
    set {_rpc = newValue}
  }
  /// Returns true if `rpc` has been explicitly set.
  var hasRpc: Bool {return self._rpc != nil}
  /// Clears the value of `rpc`. Subsequent reads from it will return its default value.
  mutating func clearRpc() {self._rpc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _requestID: String? = nil
  fileprivate var _rpc: Iterm2_ServerOriginatedRPC? = nil
}

struct Iterm2_KeystrokeNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var characters: String {
    get {return _characters ?? String()}
    set {_characters = newValue}
  }
  /// Returns true if `characters` has been explicitly set.
  var hasCharacters: Bool {return self._characters != nil}
  /// Clears the value of `characters`. Subsequent reads from it will return its default value.
  mutating func clearCharacters() {self._characters = nil}

  var charactersIgnoringModifiers: String {
    get {return _charactersIgnoringModifiers ?? String()}
    set {_charactersIgnoringModifiers = newValue}
  }
  /// Returns true if `charactersIgnoringModifiers` has been explicitly set.
  var hasCharactersIgnoringModifiers: Bool {return self._charactersIgnoringModifiers != nil}
  /// Clears the value of `charactersIgnoringModifiers`. Subsequent reads from it will return its default value.
  mutating func clearCharactersIgnoringModifiers() {self._charactersIgnoringModifiers = nil}

  var modifiers: [Iterm2_Modifiers] = []

  var keyCode: Int32 {
    get {return _keyCode ?? 0}
    set {_keyCode = newValue}
  }
  /// Returns true if `keyCode` has been explicitly set.
  var hasKeyCode: Bool {return self._keyCode != nil}
  /// Clears the value of `keyCode`. Subsequent reads from it will return its default value.
  mutating func clearKeyCode() {self._keyCode = nil}

  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var action: Iterm2_KeystrokeNotification.Action {
    get {return _action ?? .keyDown}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// These are used for non-modifier keys.
    case keyDown // = 0

    /// requires advanced=true in request
    case keyUp // = 1

    /// This is used when only a modifier changes.
    case flagsChanged // = 2

    init() {
      self = .keyDown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .keyDown
      case 1: self = .keyUp
      case 2: self = .flagsChanged
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .keyDown: return 0
      case .keyUp: return 1
      case .flagsChanged: return 2
      }
    }

  }

  init() {}

  fileprivate var _characters: String? = nil
  fileprivate var _charactersIgnoringModifiers: String? = nil
  fileprivate var _keyCode: Int32? = nil
  fileprivate var _session: String? = nil
  fileprivate var _action: Iterm2_KeystrokeNotification.Action? = nil
}

#if swift(>=4.2)

extension Iterm2_KeystrokeNotification.Action: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_ScreenUpdateNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
}

struct Iterm2_PromptNotificationPrompt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var placeholder: String {
    get {return _placeholder ?? String()}
    set {_placeholder = newValue}
  }
  /// Returns true if `placeholder` has been explicitly set.
  var hasPlaceholder: Bool {return self._placeholder != nil}
  /// Clears the value of `placeholder`. Subsequent reads from it will return its default value.
  mutating func clearPlaceholder() {self._placeholder = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _placeholder: String? = nil
}

struct Iterm2_PromptNotificationCommandStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: String {
    get {return _command ?? String()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {self._command = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _command: String? = nil
}

struct Iterm2_PromptNotificationCommandEnd {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Int32 {
    get {return _status ?? 0}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: Int32? = nil
}

struct Iterm2_PromptNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var event: Iterm2_PromptNotification.OneOf_Event? = nil

  var prompt: Iterm2_PromptNotificationPrompt {
    get {
      if case .prompt(let v)? = event {return v}
      return Iterm2_PromptNotificationPrompt()
    }
    set {event = .prompt(newValue)}
  }

  var commandStart: Iterm2_PromptNotificationCommandStart {
    get {
      if case .commandStart(let v)? = event {return v}
      return Iterm2_PromptNotificationCommandStart()
    }
    set {event = .commandStart(newValue)}
  }

  var commandEnd: Iterm2_PromptNotificationCommandEnd {
    get {
      if case .commandEnd(let v)? = event {return v}
      return Iterm2_PromptNotificationCommandEnd()
    }
    set {event = .commandEnd(newValue)}
  }

  var uniquePromptID: String {
    get {return _uniquePromptID ?? String()}
    set {_uniquePromptID = newValue}
  }
  /// Returns true if `uniquePromptID` has been explicitly set.
  var hasUniquePromptID: Bool {return self._uniquePromptID != nil}
  /// Clears the value of `uniquePromptID`. Subsequent reads from it will return its default value.
  mutating func clearUniquePromptID() {self._uniquePromptID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable {
    case prompt(Iterm2_PromptNotificationPrompt)
    case commandStart(Iterm2_PromptNotificationCommandStart)
    case commandEnd(Iterm2_PromptNotificationCommandEnd)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_PromptNotification.OneOf_Event, rhs: Iterm2_PromptNotification.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.prompt, .prompt): return {
        guard case .prompt(let l) = lhs, case .prompt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commandStart, .commandStart): return {
        guard case .commandStart(let l) = lhs, case .commandStart(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commandEnd, .commandEnd): return {
        guard case .commandEnd(let l) = lhs, case .commandEnd(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _uniquePromptID: String? = nil
}

struct Iterm2_LocationChangeNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hostName: String {
    get {return _hostName ?? String()}
    set {_hostName = newValue}
  }
  /// Returns true if `hostName` has been explicitly set.
  var hasHostName: Bool {return self._hostName != nil}
  /// Clears the value of `hostName`. Subsequent reads from it will return its default value.
  mutating func clearHostName() {self._hostName = nil}

  var userName: String {
    get {return _userName ?? String()}
    set {_userName = newValue}
  }
  /// Returns true if `userName` has been explicitly set.
  var hasUserName: Bool {return self._userName != nil}
  /// Clears the value of `userName`. Subsequent reads from it will return its default value.
  mutating func clearUserName() {self._userName = nil}

  var directory: String {
    get {return _directory ?? String()}
    set {_directory = newValue}
  }
  /// Returns true if `directory` has been explicitly set.
  var hasDirectory: Bool {return self._directory != nil}
  /// Clears the value of `directory`. Subsequent reads from it will return its default value.
  mutating func clearDirectory() {self._directory = nil}

  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hostName: String? = nil
  fileprivate var _userName: String? = nil
  fileprivate var _directory: String? = nil
  fileprivate var _session: String? = nil
}

/// OSC 1337 ; Custom=id=<identity>:<payload> ST
struct Iterm2_CustomEscapeSequenceNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var senderIdentity: String {
    get {return _senderIdentity ?? String()}
    set {_senderIdentity = newValue}
  }
  /// Returns true if `senderIdentity` has been explicitly set.
  var hasSenderIdentity: Bool {return self._senderIdentity != nil}
  /// Clears the value of `senderIdentity`. Subsequent reads from it will return its default value.
  mutating func clearSenderIdentity() {self._senderIdentity = nil}

  var payload: String {
    get {return _payload ?? String()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _senderIdentity: String? = nil
  fileprivate var _payload: String? = nil
}

/// Sent when a new session is created or a closure is undone.
struct Iterm2_NewSessionNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  mutating func clearSessionID() {self._sessionID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionID: String? = nil
}

/// Note this is sent when the app becomes/resigns active, the key window changes, the selected tab
/// of a window changes, or the active pane of a tab changes. Note that you may receive duplicate
/// notifications at times. Ignore those that do not signify a change.
struct Iterm2_FocusChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Iterm2_FocusChangedNotification.OneOf_Event? = nil

  /// true: application became active. false: application resigned active.
  var applicationActive: Bool {
    get {
      if case .applicationActive(let v)? = event {return v}
      return false
    }
    set {event = .applicationActive(newValue)}
  }

  /// If set, gives info about a change to window focus.
  var window: Iterm2_FocusChangedNotification.Window {
    get {
      if case .window(let v)? = event {return v}
      return Iterm2_FocusChangedNotification.Window()
    }
    set {event = .window(newValue)}
  }

  /// If set, selected tab changed to the one identified herein.
  var selectedTab: String {
    get {
      if case .selectedTab(let v)? = event {return v}
      return String()
    }
    set {event = .selectedTab(newValue)}
  }

  /// If set, the given session became active in its tab.
  var session: String {
    get {
      if case .session(let v)? = event {return v}
      return String()
    }
    set {event = .session(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable {
    /// true: application became active. false: application resigned active.
    case applicationActive(Bool)
    /// If set, gives info about a change to window focus.
    case window(Iterm2_FocusChangedNotification.Window)
    /// If set, selected tab changed to the one identified herein.
    case selectedTab(String)
    /// If set, the given session became active in its tab.
    case session(String)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_FocusChangedNotification.OneOf_Event, rhs: Iterm2_FocusChangedNotification.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.applicationActive, .applicationActive): return {
        guard case .applicationActive(let l) = lhs, case .applicationActive(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.window, .window): return {
        guard case .window(let l) = lhs, case .window(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.selectedTab, .selectedTab): return {
        guard case .selectedTab(let l) = lhs, case .selectedTab(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.session, .session): return {
        guard case .session(let l) = lhs, case .session(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Window {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Describes how to interpret window_id.
    var windowStatus: Iterm2_FocusChangedNotification.Window.WindowStatus {
      get {return _windowStatus ?? .terminalWindowBecameKey}
      set {_windowStatus = newValue}
    }
    /// Returns true if `windowStatus` has been explicitly set.
    var hasWindowStatus: Bool {return self._windowStatus != nil}
    /// Clears the value of `windowStatus`. Subsequent reads from it will return its default value.
    mutating func clearWindowStatus() {self._windowStatus = nil}

    /// The affected window_id
    var windowID: String {
      get {return _windowID ?? String()}
      set {_windowID = newValue}
    }
    /// Returns true if `windowID` has been explicitly set.
    var hasWindowID: Bool {return self._windowID != nil}
    /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
    mutating func clearWindowID() {self._windowID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum WindowStatus: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// `window_id` became key
      case terminalWindowBecameKey // = 0

      /// `window_id` is not key, but is the current terminal window. Some other non-terminal window is key.
      case terminalWindowIsCurrent // = 1

      /// `window_id` is no longer key.
      case terminalWindowResignedKey // = 2

      init() {
        self = .terminalWindowBecameKey
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .terminalWindowBecameKey
        case 1: self = .terminalWindowIsCurrent
        case 2: self = .terminalWindowResignedKey
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .terminalWindowBecameKey: return 0
        case .terminalWindowIsCurrent: return 1
        case .terminalWindowResignedKey: return 2
        }
      }

    }

    init() {}

    fileprivate var _windowStatus: Iterm2_FocusChangedNotification.Window.WindowStatus? = nil
    fileprivate var _windowID: String? = nil
  }

  init() {}
}

#if swift(>=4.2)

extension Iterm2_FocusChangedNotification.Window.WindowStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_TerminateSessionNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  mutating func clearSessionID() {self._sessionID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionID: String? = nil
}

struct Iterm2_LayoutChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listSessionsResponse: Iterm2_ListSessionsResponse {
    get {return _listSessionsResponse ?? Iterm2_ListSessionsResponse()}
    set {_listSessionsResponse = newValue}
  }
  /// Returns true if `listSessionsResponse` has been explicitly set.
  var hasListSessionsResponse: Bool {return self._listSessionsResponse != nil}
  /// Clears the value of `listSessionsResponse`. Subsequent reads from it will return its default value.
  mutating func clearListSessionsResponse() {self._listSessionsResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _listSessionsResponse: Iterm2_ListSessionsResponse? = nil
}

/// Requests the contents of a range of lines.
struct Iterm2_GetBufferRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See documentation on session IDs. "all" not accepted.
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  /// Which lines to return?
  var lineRange: Iterm2_LineRange {
    get {return _lineRange ?? Iterm2_LineRange()}
    set {_lineRange = newValue}
  }
  /// Returns true if `lineRange` has been explicitly set.
  var hasLineRange: Bool {return self._lineRange != nil}
  /// Clears the value of `lineRange`. Subsequent reads from it will return its default value.
  mutating func clearLineRange() {self._lineRange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _lineRange: Iterm2_LineRange? = nil
}

/// Contains the contents of a range of lines.
struct Iterm2_GetBufferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_GetBufferResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Which lines were returned
  var range: Iterm2_Range {
    get {return _range ?? Iterm2_Range()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  mutating func clearRange() {self._range = nil}

  /// Those lines' contents.
  var contents: [Iterm2_LineContents] = []

  var cursor: Iterm2_Coord {
    get {return _cursor ?? Iterm2_Coord()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  mutating func clearCursor() {self._cursor = nil}

  /// The number of lines (including lines lost from the head of scrollback history) that precede
  /// the screen. Subtract this from cursor.y to get the cursor's position on the screen when it
  /// is scrolled to the bottom.
  var numLinesAboveScreen: Int64 {
    get {return _numLinesAboveScreen ?? 0}
    set {_numLinesAboveScreen = newValue}
  }
  /// Returns true if `numLinesAboveScreen` has been explicitly set.
  var hasNumLinesAboveScreen: Bool {return self._numLinesAboveScreen != nil}
  /// Clears the value of `numLinesAboveScreen`. Subsequent reads from it will return its default value.
  mutating func clearNumLinesAboveScreen() {self._numLinesAboveScreen = nil}

  /// The returned range
  var windowedCoordRange: Iterm2_WindowedCoordRange {
    get {return _windowedCoordRange ?? Iterm2_WindowedCoordRange()}
    set {_windowedCoordRange = newValue}
  }
  /// Returns true if `windowedCoordRange` has been explicitly set.
  var hasWindowedCoordRange: Bool {return self._windowedCoordRange != nil}
  /// Clears the value of `windowedCoordRange`. Subsequent reads from it will return its default value.
  mutating func clearWindowedCoordRange() {self._windowedCoordRange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case invalidLineRange // = 2
    case requestMalformed // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .invalidLineRange
      case 3: self = .requestMalformed
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .invalidLineRange: return 2
      case .requestMalformed: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_GetBufferResponse.Status? = nil
  fileprivate var _range: Iterm2_Range? = nil
  fileprivate var _cursor: Iterm2_Coord? = nil
  fileprivate var _numLinesAboveScreen: Int64? = nil
  fileprivate var _windowedCoordRange: Iterm2_WindowedCoordRange? = nil
}

#if swift(>=4.2)

extension Iterm2_GetBufferResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Requests metadata about the current shell prompt.
struct Iterm2_GetPromptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See documentation on session IDs. "all" not accepted.
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  /// If given return this ID instead of the last one.
  var uniquePromptID: String {
    get {return _uniquePromptID ?? String()}
    set {_uniquePromptID = newValue}
  }
  /// Returns true if `uniquePromptID` has been explicitly set.
  var hasUniquePromptID: Bool {return self._uniquePromptID != nil}
  /// Clears the value of `uniquePromptID`. Subsequent reads from it will return its default value.
  mutating func clearUniquePromptID() {self._uniquePromptID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _uniquePromptID: String? = nil
}

/// Responds with metadata about the current shell prompt, if possible.
struct Iterm2_GetPromptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_GetPromptResponse.Status {
    get {return _storage._status ?? .ok}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var promptRange: Iterm2_CoordRange {
    get {return _storage._promptRange ?? Iterm2_CoordRange()}
    set {_uniqueStorage()._promptRange = newValue}
  }
  /// Returns true if `promptRange` has been explicitly set.
  var hasPromptRange: Bool {return _storage._promptRange != nil}
  /// Clears the value of `promptRange`. Subsequent reads from it will return its default value.
  mutating func clearPromptRange() {_uniqueStorage()._promptRange = nil}

  var commandRange: Iterm2_CoordRange {
    get {return _storage._commandRange ?? Iterm2_CoordRange()}
    set {_uniqueStorage()._commandRange = newValue}
  }
  /// Returns true if `commandRange` has been explicitly set.
  var hasCommandRange: Bool {return _storage._commandRange != nil}
  /// Clears the value of `commandRange`. Subsequent reads from it will return its default value.
  mutating func clearCommandRange() {_uniqueStorage()._commandRange = nil}

  var outputRange: Iterm2_CoordRange {
    get {return _storage._outputRange ?? Iterm2_CoordRange()}
    set {_uniqueStorage()._outputRange = newValue}
  }
  /// Returns true if `outputRange` has been explicitly set.
  var hasOutputRange: Bool {return _storage._outputRange != nil}
  /// Clears the value of `outputRange`. Subsequent reads from it will return its default value.
  mutating func clearOutputRange() {_uniqueStorage()._outputRange = nil}

  var workingDirectory: String {
    get {return _storage._workingDirectory ?? String()}
    set {_uniqueStorage()._workingDirectory = newValue}
  }
  /// Returns true if `workingDirectory` has been explicitly set.
  var hasWorkingDirectory: Bool {return _storage._workingDirectory != nil}
  /// Clears the value of `workingDirectory`. Subsequent reads from it will return its default value.
  mutating func clearWorkingDirectory() {_uniqueStorage()._workingDirectory = nil}

  var command: String {
    get {return _storage._command ?? String()}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return _storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {_uniqueStorage()._command = nil}

  var promptState: Iterm2_GetPromptResponse.State {
    get {return _storage._promptState ?? .editing}
    set {_uniqueStorage()._promptState = newValue}
  }
  /// Returns true if `promptState` has been explicitly set.
  var hasPromptState: Bool {return _storage._promptState != nil}
  /// Clears the value of `promptState`. Subsequent reads from it will return its default value.
  mutating func clearPromptState() {_uniqueStorage()._promptState = nil}

  /// Exit status. Equivalent to shell's $? variable. Only set if state is FINISHED.
  var exitStatus: UInt32 {
    get {return _storage._exitStatus ?? 0}
    set {_uniqueStorage()._exitStatus = newValue}
  }
  /// Returns true if `exitStatus` has been explicitly set.
  var hasExitStatus: Bool {return _storage._exitStatus != nil}
  /// Clears the value of `exitStatus`. Subsequent reads from it will return its default value.
  mutating func clearExitStatus() {_uniqueStorage()._exitStatus = nil}

  var uniquePromptID: String {
    get {return _storage._uniquePromptID ?? String()}
    set {_uniqueStorage()._uniquePromptID = newValue}
  }
  /// Returns true if `uniquePromptID` has been explicitly set.
  var hasUniquePromptID: Bool {return _storage._uniquePromptID != nil}
  /// Clears the value of `uniquePromptID`. Subsequent reads from it will return its default value.
  mutating func clearUniquePromptID() {_uniqueStorage()._uniquePromptID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case requestMalformed // = 2
    case promptUnavailable // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .requestMalformed
      case 3: self = .promptUnavailable
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .requestMalformed: return 2
      case .promptUnavailable: return 3
      }
    }

  }

  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Command hasn't been started yet
    case editing // = 0

    /// Command is currently running
    case running // = 1

    /// Command has finished.
    case finished // = 2

    init() {
      self = .editing
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .editing
      case 1: self = .running
      case 2: self = .finished
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .editing: return 0
      case .running: return 1
      case .finished: return 2
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Iterm2_GetPromptResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

extension Iterm2_GetPromptResponse.State: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_ListPromptsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must name a specific session. "all" not allowed.
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  /// If unspecified, start at oldest.
  var firstUniqueID: String {
    get {return _firstUniqueID ?? String()}
    set {_firstUniqueID = newValue}
  }
  /// Returns true if `firstUniqueID` has been explicitly set.
  var hasFirstUniqueID: Bool {return self._firstUniqueID != nil}
  /// Clears the value of `firstUniqueID`. Subsequent reads from it will return its default value.
  mutating func clearFirstUniqueID() {self._firstUniqueID = nil}

  /// If unspecified, end at newest.
  var lastUniqueID: String {
    get {return _lastUniqueID ?? String()}
    set {_lastUniqueID = newValue}
  }
  /// Returns true if `lastUniqueID` has been explicitly set.
  var hasLastUniqueID: Bool {return self._lastUniqueID != nil}
  /// Clears the value of `lastUniqueID`. Subsequent reads from it will return its default value.
  mutating func clearLastUniqueID() {self._lastUniqueID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _firstUniqueID: String? = nil
  fileprivate var _lastUniqueID: String? = nil
}

struct Iterm2_ListPromptsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_ListPromptsResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Chronological list of prompt IDs, suitable for GetPromptRequest.unique_prompt_id.
  var uniquePromptID: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_ListPromptsResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_ListPromptsResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_GetProfilePropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See documentation on session IDs
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  /// If not set, all properties will be returned
  var keys: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
}

struct Iterm2_ProfileProperty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var jsonValue: String {
    get {return _jsonValue ?? String()}
    set {_jsonValue = newValue}
  }
  /// Returns true if `jsonValue` has been explicitly set.
  var hasJsonValue: Bool {return self._jsonValue != nil}
  /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
  mutating func clearJsonValue() {self._jsonValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _jsonValue: String? = nil
}

struct Iterm2_GetProfilePropertyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_GetProfilePropertyResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var properties: [Iterm2_ProfileProperty] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case requestMalformed // = 2
    case error // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .requestMalformed
      case 3: self = .error
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .requestMalformed: return 2
      case .error: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_GetProfilePropertyResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_GetProfilePropertyResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Sets a value in a session's copy of the profile without modifying the underlying profile.
struct Iterm2_SetProfilePropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: Iterm2_SetProfilePropertyRequest.OneOf_Target? = nil

  /// See documentation on session IDs
  var session: String {
    get {
      if case .session(let v)? = target {return v}
      return String()
    }
    set {target = .session(newValue)}
  }

  var guidList: Iterm2_SetProfilePropertyRequest.GuidList {
    get {
      if case .guidList(let v)? = target {return v}
      return Iterm2_SetProfilePropertyRequest.GuidList()
    }
    set {target = .guidList(newValue)}
  }

  /// deprecated
  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  /// deprecated
  var jsonValue: String {
    get {return _jsonValue ?? String()}
    set {_jsonValue = newValue}
  }
  /// Returns true if `jsonValue` has been explicitly set.
  var hasJsonValue: Bool {return self._jsonValue != nil}
  /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
  mutating func clearJsonValue() {self._jsonValue = nil}

  var assignments: [Iterm2_SetProfilePropertyRequest.Assignment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable {
    /// See documentation on session IDs
    case session(String)
    case guidList(Iterm2_SetProfilePropertyRequest.GuidList)

  #if !swift(>=4.1)
    static func ==(lhs: Iterm2_SetProfilePropertyRequest.OneOf_Target, rhs: Iterm2_SetProfilePropertyRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.session, .session): return {
        guard case .session(let l) = lhs, case .session(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guidList, .guidList): return {
        guard case .guidList(let l) = lhs, case .guidList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct GuidList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guids: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Assignment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String {
      get {return _key ?? String()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var jsonValue: String {
      get {return _jsonValue ?? String()}
      set {_jsonValue = newValue}
    }
    /// Returns true if `jsonValue` has been explicitly set.
    var hasJsonValue: Bool {return self._jsonValue != nil}
    /// Clears the value of `jsonValue`. Subsequent reads from it will return its default value.
    mutating func clearJsonValue() {self._jsonValue = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: String? = nil
    fileprivate var _jsonValue: String? = nil
  }

  init() {}

  fileprivate var _key: String? = nil
  fileprivate var _jsonValue: String? = nil
}

struct Iterm2_SetProfilePropertyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SetProfilePropertyResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case requestMalformed // = 2
    case badGuid // = 3

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .requestMalformed
      case 3: self = .badGuid
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .requestMalformed: return 2
      case .badGuid: return 3
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_SetProfilePropertyResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SetProfilePropertyResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_TransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set to true to begin a new transaction or false to end the current
  /// transaction. The app's main loop will not advance while in a
  /// transaction. This effectively freezes time. Keep transactions short.
  var begin: Bool {
    get {return _begin ?? false}
    set {_begin = newValue}
  }
  /// Returns true if `begin` has been explicitly set.
  var hasBegin: Bool {return self._begin != nil}
  /// Clears the value of `begin`. Subsequent reads from it will return its default value.
  mutating func clearBegin() {self._begin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _begin: Bool? = nil
}

struct Iterm2_TransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_TransactionResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case noTransaction // = 1
    case alreadyInTransaction // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .noTransaction
      case 2: self = .alreadyInTransaction
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .noTransaction: return 1
      case .alreadyInTransaction: return 2
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_TransactionResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_TransactionResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Describes a range of lines.
struct Iterm2_LineRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only one of these fields should be set:
  /// ---------------------------------------
  /// Return just the current contents of the screen.
  var screenContentsOnly: Bool {
    get {return _screenContentsOnly ?? false}
    set {_screenContentsOnly = newValue}
  }
  /// Returns true if `screenContentsOnly` has been explicitly set.
  var hasScreenContentsOnly: Bool {return self._screenContentsOnly != nil}
  /// Clears the value of `screenContentsOnly`. Subsequent reads from it will return its default value.
  mutating func clearScreenContentsOnly() {self._screenContentsOnly = nil}

  /// Return the last `trailing lines` of the buffer, which could go back into
  /// scrollback history.
  var trailingLines: Int32 {
    get {return _trailingLines ?? 0}
    set {_trailingLines = newValue}
  }
  /// Returns true if `trailingLines` has been explicitly set.
  var hasTrailingLines: Bool {return self._trailingLines != nil}
  /// Clears the value of `trailingLines`. Subsequent reads from it will return its default value.
  mutating func clearTrailingLines() {self._trailingLines = nil}

  var windowedCoordRange: Iterm2_WindowedCoordRange {
    get {return _windowedCoordRange ?? Iterm2_WindowedCoordRange()}
    set {_windowedCoordRange = newValue}
  }
  /// Returns true if `windowedCoordRange` has been explicitly set.
  var hasWindowedCoordRange: Bool {return self._windowedCoordRange != nil}
  /// Clears the value of `windowedCoordRange`. Subsequent reads from it will return its default value.
  mutating func clearWindowedCoordRange() {self._windowedCoordRange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _screenContentsOnly: Bool? = nil
  fileprivate var _trailingLines: Int32? = nil
  fileprivate var _windowedCoordRange: Iterm2_WindowedCoordRange? = nil
}

/// Describes a range of values.
struct Iterm2_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: Int64 {
    get {return _location ?? 0}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var length: Int64 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: Int64? = nil
  fileprivate var _length: Int64? = nil
}

/// Describes a range of cells.
/// |..xxxxx|
/// |xxxx...|
/// In the example above, the range of x's is: {start: {x:2, y:0}, end: {x:4, y:1}}
/// The end coordinate is the first cell *after* the end of the range described (so an empty range
/// has start == end)
struct Iterm2_CoordRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: Iterm2_Coord {
    get {return _start ?? Iterm2_Coord()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var end: Iterm2_Coord {
    get {return _end ?? Iterm2_Coord()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: Iterm2_Coord? = nil
  fileprivate var _end: Iterm2_Coord? = nil
}

/// Describes a cell's location.
struct Iterm2_Coord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Int32 {
    get {return _x ?? 0}
    set {_x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  var hasX: Bool {return self._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  mutating func clearX() {self._x = nil}

  /// y=0 describes the first line. When the scrollback buffer is full and history is lost, the first
  /// lines become unavailable, but the numbering is stable (so the Nth line is always the Nth line,
  /// even if it's not the Nth *visible* line).
  var y: Int64 {
    get {return _y ?? 0}
    set {_y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  var hasY: Bool {return self._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  mutating func clearY() {self._y = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _x: Int32? = nil
  fileprivate var _y: Int64? = nil
}

/// Describes the content of a line.
struct Iterm2_LineContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// Some cells do not contain one code point. Use this to map code points in
  /// `text` to a screen position. If the line has no uninitialized cells at its end, then the
  /// sum of `repeats` equals the width of the display.
  ///
  /// For example, consider a line of text that appears on your display like:
  ///   xyz compañía
  ///
  /// The corresponding value of `text` would be:
  ///   xyzcompan~i'a
  /// Note: ~ and ' are combining marks, but are shown uncombined for illustrative purposes.
  ///
  /// Each code point in "xyz" as well as each of the non-accented letters in compañía takes one
  /// cell.
  ///
  /// The blank following 'z' is an uninitialized cell that has no code points,
  /// so the z and the c in `text` are adjacent. It's unusual for these to occur in the middle
  /// of a line, but it is possible.
  ///
  /// The ñ is composed of the letter n and a combining tilde (U+0303) (indicated in our example
  /// as ~), while í is composed of the letter i and a combining acute accent (U+0301) (indicated in
  /// our example as ').
  ///
  /// To map code points in `text` to screen positions, `code_points_per_cell`
  /// provides the number of code points in each cell. In our example you would
  /// get:
  ///
  ///   num_code_points=1, repeats=3     // x, y, z
  ///   num_code_points=0, repeats=1     // uninitialized cell
  ///   num_code_points=1, repeats=5     // c, o, m, p, a
  ///   num_code_points=2, repeats=2     // n + combining tilde, i + combining acute accent
  ///   num_code_points=1, repeats=1     // a
  ///
  /// Lines usually end with a series of uninitialized cells. These are not included.
  ///
  /// Here is psuedocode to interpret code_points_per_cell:
  ///
  ///   text_index_to_screen_coord = {}
  ///   screen_coord_to_text_index = {}
  ///   text_index = 0
  ///   screen_coord = 0
  ///   for cpps in code_points_per_cell:
  ///     repeat cpps.repeats times:
  ///       text_index_to_screen_coord[text_index] = screen_coord
  ///       screen_coord_to_text_index[screen_coord] = text_index
  ///       text_index += cpps.num_code_points
  ///       screen_coord += 1
  ///
  /// Cells with images are omitted.
  var codePointsPerCell: [Iterm2_CodePointsPerCell] = []

  var continuation: Iterm2_LineContents.Continuation {
    get {return _continuation ?? .hardEol}
    set {_continuation = newValue}
  }
  /// Returns true if `continuation` has been explicitly set.
  var hasContinuation: Bool {return self._continuation != nil}
  /// Clears the value of `continuation`. Subsequent reads from it will return its default value.
  mutating func clearContinuation() {self._continuation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// How does this line end?
  enum Continuation: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// This line is not wrapped.
    case hardEol // = 1

    /// The next line is a continuation of this line.
    case softEol // = 2

    init() {
      self = .hardEol
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .hardEol
      case 2: self = .softEol
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .hardEol: return 1
      case .softEol: return 2
      }
    }

  }

  init() {}

  fileprivate var _text: String? = nil
  fileprivate var _continuation: Iterm2_LineContents.Continuation? = nil
}

#if swift(>=4.2)

extension Iterm2_LineContents.Continuation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_CodePointsPerCell {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of code points per cell
  var numCodePoints: Int32 {
    get {return _numCodePoints ?? 1}
    set {_numCodePoints = newValue}
  }
  /// Returns true if `numCodePoints` has been explicitly set.
  var hasNumCodePoints: Bool {return self._numCodePoints != nil}
  /// Clears the value of `numCodePoints`. Subsequent reads from it will return its default value.
  mutating func clearNumCodePoints() {self._numCodePoints = nil}

  /// Number of adjacent cells with this number of code points (always one or more).
  var repeats: Int32 {
    get {return _repeats ?? 0}
    set {_repeats = newValue}
  }
  /// Returns true if `repeats` has been explicitly set.
  var hasRepeats: Bool {return self._repeats != nil}
  /// Clears the value of `repeats`. Subsequent reads from it will return its default value.
  mutating func clearRepeats() {self._repeats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _numCodePoints: Int32? = nil
  fileprivate var _repeats: Int32? = nil
}

struct Iterm2_ListSessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Iterm2_SendTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See documentation on session IDs
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  /// The text to send. As usual for proto buffers, this should be UTF-8
  /// encoded. It will be converted to the session's encoding before being sent.
  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// If set, input will not be broadcast when broadcasting is on.
  var suppressBroadcast: Bool {
    get {return _suppressBroadcast ?? false}
    set {_suppressBroadcast = newValue}
  }
  /// Returns true if `suppressBroadcast` has been explicitly set.
  var hasSuppressBroadcast: Bool {return self._suppressBroadcast != nil}
  /// Clears the value of `suppressBroadcast`. Subsequent reads from it will return its default value.
  mutating func clearSuppressBroadcast() {self._suppressBroadcast = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _text: String? = nil
  fileprivate var _suppressBroadcast: Bool? = nil
}

struct Iterm2_SendTextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SendTextResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_SendTextResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SendTextResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_Size {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Int32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: Int32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _width: Int32? = nil
  fileprivate var _height: Int32? = nil
}

struct Iterm2_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Int32 {
    get {return _x ?? 0}
    set {_x = newValue}
  }
  /// Returns true if `x` has been explicitly set.
  var hasX: Bool {return self._x != nil}
  /// Clears the value of `x`. Subsequent reads from it will return its default value.
  mutating func clearX() {self._x = nil}

  var y: Int32 {
    get {return _y ?? 0}
    set {_y = newValue}
  }
  /// Returns true if `y` has been explicitly set.
  var hasY: Bool {return self._y != nil}
  /// Clears the value of `y`. Subsequent reads from it will return its default value.
  mutating func clearY() {self._y = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _x: Int32? = nil
  fileprivate var _y: Int32? = nil
}

struct Iterm2_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: Iterm2_Point {
    get {return _origin ?? Iterm2_Point()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: Iterm2_Size {
    get {return _size ?? Iterm2_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: Iterm2_Point? = nil
  fileprivate var _size: Iterm2_Size? = nil
}

struct Iterm2_SessionSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uniqueIdentifier: String {
    get {return _uniqueIdentifier ?? String()}
    set {_uniqueIdentifier = newValue}
  }
  /// Returns true if `uniqueIdentifier` has been explicitly set.
  var hasUniqueIdentifier: Bool {return self._uniqueIdentifier != nil}
  /// Clears the value of `uniqueIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearUniqueIdentifier() {self._uniqueIdentifier = nil}

  /// will not be set for buried sessions
  var frame: Iterm2_Frame {
    get {return _frame ?? Iterm2_Frame()}
    set {_frame = newValue}
  }
  /// Returns true if `frame` has been explicitly set.
  var hasFrame: Bool {return self._frame != nil}
  /// Clears the value of `frame`. Subsequent reads from it will return its default value.
  mutating func clearFrame() {self._frame = nil}

  /// will not be set for buried sessions
  var gridSize: Iterm2_Size {
    get {return _gridSize ?? Iterm2_Size()}
    set {_gridSize = newValue}
  }
  /// Returns true if `gridSize` has been explicitly set.
  var hasGridSize: Bool {return self._gridSize != nil}
  /// Clears the value of `gridSize`. Subsequent reads from it will return its default value.
  mutating func clearGridSize() {self._gridSize = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uniqueIdentifier: String? = nil
  fileprivate var _frame: Iterm2_Frame? = nil
  fileprivate var _gridSize: Iterm2_Size? = nil
  fileprivate var _title: String? = nil
}

struct Iterm2_SplitTreeNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Direction of split pane divider
  var vertical: Bool {
    get {return _vertical ?? false}
    set {_vertical = newValue}
  }
  /// Returns true if `vertical` has been explicitly set.
  var hasVertical: Bool {return self._vertical != nil}
  /// Clears the value of `vertical`. Subsequent reads from it will return its default value.
  mutating func clearVertical() {self._vertical = nil}

  /// Links to children
  var links: [Iterm2_SplitTreeNode.SplitTreeLink] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SplitTreeLink {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var child: Iterm2_SplitTreeNode.SplitTreeLink.OneOf_Child? = nil

    var session: Iterm2_SessionSummary {
      get {
        if case .session(let v)? = child {return v}
        return Iterm2_SessionSummary()
      }
      set {child = .session(newValue)}
    }

    var node: Iterm2_SplitTreeNode {
      get {
        if case .node(let v)? = child {return v}
        return Iterm2_SplitTreeNode()
      }
      set {child = .node(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Child: Equatable {
      case session(Iterm2_SessionSummary)
      case node(Iterm2_SplitTreeNode)

    #if !swift(>=4.1)
      static func ==(lhs: Iterm2_SplitTreeNode.SplitTreeLink.OneOf_Child, rhs: Iterm2_SplitTreeNode.SplitTreeLink.OneOf_Child) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.session, .session): return {
          guard case .session(let l) = lhs, case .session(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.node, .node): return {
          guard case .node(let l) = lhs, case .node(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}

  fileprivate var _vertical: Bool? = nil
}

struct Iterm2_ListSessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var windows: [Iterm2_ListSessionsResponse.Window] = []

  var buriedSessions: [Iterm2_SessionSummary] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Window {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tabs: [Iterm2_ListSessionsResponse.Tab] = []

    var windowID: String {
      get {return _windowID ?? String()}
      set {_windowID = newValue}
    }
    /// Returns true if `windowID` has been explicitly set.
    var hasWindowID: Bool {return self._windowID != nil}
    /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
    mutating func clearWindowID() {self._windowID = nil}

    var frame: Iterm2_Frame {
      get {return _frame ?? Iterm2_Frame()}
      set {_frame = newValue}
    }
    /// Returns true if `frame` has been explicitly set.
    var hasFrame: Bool {return self._frame != nil}
    /// Clears the value of `frame`. Subsequent reads from it will return its default value.
    mutating func clearFrame() {self._frame = nil}

    var number: Int32 {
      get {return _number ?? 0}
      set {_number = newValue}
    }
    /// Returns true if `number` has been explicitly set.
    var hasNumber: Bool {return self._number != nil}
    /// Clears the value of `number`. Subsequent reads from it will return its default value.
    mutating func clearNumber() {self._number = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _windowID: String? = nil
    fileprivate var _frame: Iterm2_Frame? = nil
    fileprivate var _number: Int32? = nil
  }

  struct Tab {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var root: Iterm2_SplitTreeNode {
      get {return _root ?? Iterm2_SplitTreeNode()}
      set {_root = newValue}
    }
    /// Returns true if `root` has been explicitly set.
    var hasRoot: Bool {return self._root != nil}
    /// Clears the value of `root`. Subsequent reads from it will return its default value.
    mutating func clearRoot() {self._root = nil}

    var tabID: String {
      get {return _tabID ?? String()}
      set {_tabID = newValue}
    }
    /// Returns true if `tabID` has been explicitly set.
    var hasTabID: Bool {return self._tabID != nil}
    /// Clears the value of `tabID`. Subsequent reads from it will return its default value.
    mutating func clearTabID() {self._tabID = nil}

    var tmuxWindowID: String {
      get {return _tmuxWindowID ?? String()}
      set {_tmuxWindowID = newValue}
    }
    /// Returns true if `tmuxWindowID` has been explicitly set.
    var hasTmuxWindowID: Bool {return self._tmuxWindowID != nil}
    /// Clears the value of `tmuxWindowID`. Subsequent reads from it will return its default value.
    mutating func clearTmuxWindowID() {self._tmuxWindowID = nil}

    var tmuxConnectionID: String {
      get {return _tmuxConnectionID ?? String()}
      set {_tmuxConnectionID = newValue}
    }
    /// Returns true if `tmuxConnectionID` has been explicitly set.
    var hasTmuxConnectionID: Bool {return self._tmuxConnectionID != nil}
    /// Clears the value of `tmuxConnectionID`. Subsequent reads from it will return its default value.
    mutating func clearTmuxConnectionID() {self._tmuxConnectionID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _root: Iterm2_SplitTreeNode? = nil
    fileprivate var _tabID: String? = nil
    fileprivate var _tmuxWindowID: String? = nil
    fileprivate var _tmuxConnectionID: String? = nil
  }

  init() {}
}

struct Iterm2_CreateTabRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Leave unset to use the default profile.
  var profileName: String {
    get {return _profileName ?? String()}
    set {_profileName = newValue}
  }
  /// Returns true if `profileName` has been explicitly set.
  var hasProfileName: Bool {return self._profileName != nil}
  /// Clears the value of `profileName`. Subsequent reads from it will return its default value.
  mutating func clearProfileName() {self._profileName = nil}

  /// Leave unset to create the tab in a new window.
  var windowID: String {
    get {return _windowID ?? String()}
    set {_windowID = newValue}
  }
  /// Returns true if `windowID` has been explicitly set.
  var hasWindowID: Bool {return self._windowID != nil}
  /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
  mutating func clearWindowID() {self._windowID = nil}

  /// Valid to set only if window_id is set. Gives the desired index of the new tab.
  var tabIndex: UInt32 {
    get {return _tabIndex ?? 0}
    set {_tabIndex = newValue}
  }
  /// Returns true if `tabIndex` has been explicitly set.
  var hasTabIndex: Bool {return self._tabIndex != nil}
  /// Clears the value of `tabIndex`. Subsequent reads from it will return its default value.
  mutating func clearTabIndex() {self._tabIndex = nil}

  /// If not set, the profile's command will be used. Use custom_profile_properties instead.
  var command: String {
    get {return _command ?? String()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {self._command = nil}

  /// Modifies the profile to customize its behavior just for this session.
  var customProfileProperties: [Iterm2_ProfileProperty] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _profileName: String? = nil
  fileprivate var _windowID: String? = nil
  fileprivate var _tabIndex: UInt32? = nil
  fileprivate var _command: String? = nil
}

struct Iterm2_CreateTabResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_CreateTabResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var windowID: String {
    get {return _windowID ?? String()}
    set {_windowID = newValue}
  }
  /// Returns true if `windowID` has been explicitly set.
  var hasWindowID: Bool {return self._windowID != nil}
  /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
  mutating func clearWindowID() {self._windowID = nil}

  var tabID: Int32 {
    get {return _tabID ?? 0}
    set {_tabID = newValue}
  }
  /// Returns true if `tabID` has been explicitly set.
  var hasTabID: Bool {return self._tabID != nil}
  /// Clears the value of `tabID`. Subsequent reads from it will return its default value.
  mutating func clearTabID() {self._tabID = nil}

  var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  mutating func clearSessionID() {self._sessionID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case invalidProfileName // = 1
    case invalidWindowID // = 2

    /// The tab is still created, just not with the desired index.
    case invalidTabIndex // = 3

    /// A $$VAR$$ substitution was not provided by the user.
    case missingSubstitution // = 4

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .invalidProfileName
      case 2: self = .invalidWindowID
      case 3: self = .invalidTabIndex
      case 4: self = .missingSubstitution
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .invalidProfileName: return 1
      case .invalidWindowID: return 2
      case .invalidTabIndex: return 3
      case .missingSubstitution: return 4
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_CreateTabResponse.Status? = nil
  fileprivate var _windowID: String? = nil
  fileprivate var _tabID: Int32? = nil
  fileprivate var _sessionID: String? = nil
}

#if swift(>=4.2)

extension Iterm2_CreateTabResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_SplitPaneRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See documentation on session IDs
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var splitDirection: Iterm2_SplitPaneRequest.SplitDirection {
    get {return _splitDirection ?? .vertical}
    set {_splitDirection = newValue}
  }
  /// Returns true if `splitDirection` has been explicitly set.
  var hasSplitDirection: Bool {return self._splitDirection != nil}
  /// Clears the value of `splitDirection`. Subsequent reads from it will return its default value.
  mutating func clearSplitDirection() {self._splitDirection = nil}

  /// If true, new session is above/left of the session being split. Otherwise, it goes below/right.
  var before: Bool {
    get {return _before ?? false}
    set {_before = newValue}
  }
  /// Returns true if `before` has been explicitly set.
  var hasBefore: Bool {return self._before != nil}
  /// Clears the value of `before`. Subsequent reads from it will return its default value.
  mutating func clearBefore() {self._before = nil}

  /// Leave unset to use the default profile.
  var profileName: String {
    get {return _profileName ?? String()}
    set {_profileName = newValue}
  }
  /// Returns true if `profileName` has been explicitly set.
  var hasProfileName: Bool {return self._profileName != nil}
  /// Clears the value of `profileName`. Subsequent reads from it will return its default value.
  mutating func clearProfileName() {self._profileName = nil}

  /// Modifies the profile to customize its behavior just for this session.
  var customProfileProperties: [Iterm2_ProfileProperty] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum SplitDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case vertical // = 0
    case horizontal // = 1

    init() {
      self = .vertical
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .vertical
      case 1: self = .horizontal
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .vertical: return 0
      case .horizontal: return 1
      }
    }

  }

  init() {}

  fileprivate var _session: String? = nil
  fileprivate var _splitDirection: Iterm2_SplitPaneRequest.SplitDirection? = nil
  fileprivate var _before: Bool? = nil
  fileprivate var _profileName: String? = nil
}

#if swift(>=4.2)

extension Iterm2_SplitPaneRequest.SplitDirection: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Iterm2_SplitPaneResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Iterm2_SplitPaneResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// TODO(gln): this will not be set for tmux integration because the split happens only if/when the
  /// tmux server acts on the request.
  /// See documentation on session IDs.
  /// If more than one session was split, there will be multiple session_id's.
  var sessionID: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case sessionNotFound // = 1
    case invalidProfileName // = 2

    /// This can happen if the session to be split is too small. If splitting multiple sessions and
    /// one or more cannot be split, the status will be set to CANNOT_SPLIT, even if some did succeed
    /// (in which case there will be one or more session_id's).
    case cannotSplit // = 3

    /// Couldn't decode JSON
    case malformedCustomProfileProperty // = 4

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .sessionNotFound
      case 2: self = .invalidProfileName
      case 3: self = .cannotSplit
      case 4: self = .malformedCustomProfileProperty
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .sessionNotFound: return 1
      case .invalidProfileName: return 2
      case .cannotSplit: return 3
      case .malformedCustomProfileProperty: return 4
      }
    }

  }

  init() {}

  fileprivate var _status: Iterm2_SplitPaneResponse.Status? = nil
}

#if swift(>=4.2)

extension Iterm2_SplitPaneResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "iterm2"

extension Iterm2_SelectionMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHARACTER"),
    1: .same(proto: "WORD"),
    2: .same(proto: "LINE"),
    3: .same(proto: "SMART"),
    4: .same(proto: "BOX"),
    5: .same(proto: "WHOLE_LINE"),
  ]
}

extension Iterm2_NotificationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NOTIFY_ON_KEYSTROKE"),
    2: .same(proto: "NOTIFY_ON_SCREEN_UPDATE"),
    3: .same(proto: "NOTIFY_ON_PROMPT"),
    4: .same(proto: "NOTIFY_ON_LOCATION_CHANGE"),
    5: .same(proto: "NOTIFY_ON_CUSTOM_ESCAPE_SEQUENCE"),
    6: .same(proto: "NOTIFY_ON_NEW_SESSION"),
    7: .same(proto: "NOTIFY_ON_TERMINATE_SESSION"),
    8: .same(proto: "NOTIFY_ON_LAYOUT_CHANGE"),
    9: .same(proto: "NOTIFY_ON_FOCUS_CHANGE"),
    10: .same(proto: "NOTIFY_ON_SERVER_ORIGINATED_RPC"),
    11: .same(proto: "NOTIFY_ON_BROADCAST_CHANGE"),
    12: .same(proto: "NOTIFY_ON_VARIABLE_CHANGE"),
    13: .same(proto: "NOTIFY_ON_PROFILE_CHANGE"),
    14: .same(proto: "KEYSTROKE_FILTER"),
  ]
}

extension Iterm2_Modifiers: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CONTROL"),
    2: .same(proto: "OPTION"),
    3: .same(proto: "COMMAND"),
    4: .same(proto: "SHIFT"),
    5: .same(proto: "FUNCTION"),
    6: .same(proto: "NUMPAD"),
  ]
}

extension Iterm2_VariableScope: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SESSION"),
    2: .same(proto: "TAB"),
    3: .same(proto: "WINDOW"),
    4: .same(proto: "APP"),
  ]
}

extension Iterm2_PromptMonitorMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PROMPT"),
    2: .same(proto: "COMMAND_START"),
    3: .same(proto: "COMMAND_END"),
  ]
}

extension Iterm2_ClientOriginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientOriginatedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    100: .standard(proto: "get_buffer_request"),
    101: .standard(proto: "get_prompt_request"),
    102: .standard(proto: "transaction_request"),
    103: .standard(proto: "notification_request"),
    104: .standard(proto: "register_tool_request"),
    105: .standard(proto: "set_profile_property_request"),
    106: .standard(proto: "list_sessions_request"),
    107: .standard(proto: "send_text_request"),
    108: .standard(proto: "create_tab_request"),
    109: .standard(proto: "split_pane_request"),
    110: .standard(proto: "get_profile_property_request"),
    111: .standard(proto: "set_property_request"),
    112: .standard(proto: "get_property_request"),
    113: .standard(proto: "inject_request"),
    114: .standard(proto: "activate_request"),
    115: .standard(proto: "variable_request"),
    116: .standard(proto: "saved_arrangement_request"),
    117: .standard(proto: "focus_request"),
    118: .standard(proto: "list_profiles_request"),
    119: .standard(proto: "server_originated_rpc_result_request"),
    120: .standard(proto: "restart_session_request"),
    121: .standard(proto: "menu_item_request"),
    122: .standard(proto: "set_tab_layout_request"),
    123: .standard(proto: "get_broadcast_domains_request"),
    124: .standard(proto: "tmux_request"),
    125: .standard(proto: "reorder_tabs_request"),
    126: .standard(proto: "preferences_request"),
    127: .standard(proto: "color_preset_request"),
    128: .standard(proto: "selection_request"),
    129: .standard(proto: "status_bar_component_request"),
    130: .standard(proto: "set_broadcast_domains_request"),
    131: .standard(proto: "close_request"),
    132: .standard(proto: "invoke_function_request"),
    133: .standard(proto: "list_prompts_request"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64? = nil
    var _submessage: Iterm2_ClientOriginatedMessage.OneOf_Submessage?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _submessage = source._submessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 100: try {
          var v: Iterm2_GetBufferRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .getBufferRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .getBufferRequest(v)
          }
        }()
        case 101: try {
          var v: Iterm2_GetPromptRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .getPromptRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .getPromptRequest(v)
          }
        }()
        case 102: try {
          var v: Iterm2_TransactionRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .transactionRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .transactionRequest(v)
          }
        }()
        case 103: try {
          var v: Iterm2_NotificationRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .notificationRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .notificationRequest(v)
          }
        }()
        case 104: try {
          var v: Iterm2_RegisterToolRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .registerToolRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .registerToolRequest(v)
          }
        }()
        case 105: try {
          var v: Iterm2_SetProfilePropertyRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .setProfilePropertyRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .setProfilePropertyRequest(v)
          }
        }()
        case 106: try {
          var v: Iterm2_ListSessionsRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .listSessionsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .listSessionsRequest(v)
          }
        }()
        case 107: try {
          var v: Iterm2_SendTextRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .sendTextRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .sendTextRequest(v)
          }
        }()
        case 108: try {
          var v: Iterm2_CreateTabRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .createTabRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .createTabRequest(v)
          }
        }()
        case 109: try {
          var v: Iterm2_SplitPaneRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .splitPaneRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .splitPaneRequest(v)
          }
        }()
        case 110: try {
          var v: Iterm2_GetProfilePropertyRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .getProfilePropertyRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .getProfilePropertyRequest(v)
          }
        }()
        case 111: try {
          var v: Iterm2_SetPropertyRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .setPropertyRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .setPropertyRequest(v)
          }
        }()
        case 112: try {
          var v: Iterm2_GetPropertyRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .getPropertyRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .getPropertyRequest(v)
          }
        }()
        case 113: try {
          var v: Iterm2_InjectRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .injectRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .injectRequest(v)
          }
        }()
        case 114: try {
          var v: Iterm2_ActivateRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .activateRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .activateRequest(v)
          }
        }()
        case 115: try {
          var v: Iterm2_VariableRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .variableRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .variableRequest(v)
          }
        }()
        case 116: try {
          var v: Iterm2_SavedArrangementRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .savedArrangementRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .savedArrangementRequest(v)
          }
        }()
        case 117: try {
          var v: Iterm2_FocusRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .focusRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .focusRequest(v)
          }
        }()
        case 118: try {
          var v: Iterm2_ListProfilesRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .listProfilesRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .listProfilesRequest(v)
          }
        }()
        case 119: try {
          var v: Iterm2_ServerOriginatedRPCResultRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .serverOriginatedRpcResultRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .serverOriginatedRpcResultRequest(v)
          }
        }()
        case 120: try {
          var v: Iterm2_RestartSessionRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .restartSessionRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .restartSessionRequest(v)
          }
        }()
        case 121: try {
          var v: Iterm2_MenuItemRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .menuItemRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .menuItemRequest(v)
          }
        }()
        case 122: try {
          var v: Iterm2_SetTabLayoutRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .setTabLayoutRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .setTabLayoutRequest(v)
          }
        }()
        case 123: try {
          var v: Iterm2_GetBroadcastDomainsRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .getBroadcastDomainsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .getBroadcastDomainsRequest(v)
          }
        }()
        case 124: try {
          var v: Iterm2_TmuxRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .tmuxRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .tmuxRequest(v)
          }
        }()
        case 125: try {
          var v: Iterm2_ReorderTabsRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .reorderTabsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .reorderTabsRequest(v)
          }
        }()
        case 126: try {
          var v: Iterm2_PreferencesRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .preferencesRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .preferencesRequest(v)
          }
        }()
        case 127: try {
          var v: Iterm2_ColorPresetRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .colorPresetRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .colorPresetRequest(v)
          }
        }()
        case 128: try {
          var v: Iterm2_SelectionRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .selectionRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .selectionRequest(v)
          }
        }()
        case 129: try {
          var v: Iterm2_StatusBarComponentRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .statusBarComponentRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .statusBarComponentRequest(v)
          }
        }()
        case 130: try {
          var v: Iterm2_SetBroadcastDomainsRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .setBroadcastDomainsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .setBroadcastDomainsRequest(v)
          }
        }()
        case 131: try {
          var v: Iterm2_CloseRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .closeRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .closeRequest(v)
          }
        }()
        case 132: try {
          var v: Iterm2_InvokeFunctionRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .invokeFunctionRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .invokeFunctionRequest(v)
          }
        }()
        case 133: try {
          var v: Iterm2_ListPromptsRequest?
          var hadOneofValue = false
          if let current = _storage._submessage {
            hadOneofValue = true
            if case .listPromptsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._submessage = .listPromptsRequest(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._submessage {
      case .getBufferRequest?: try {
        guard case .getBufferRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      }()
      case .getPromptRequest?: try {
        guard case .getPromptRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      }()
      case .transactionRequest?: try {
        guard case .transactionRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      }()
      case .notificationRequest?: try {
        guard case .notificationRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      }()
      case .registerToolRequest?: try {
        guard case .registerToolRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      }()
      case .setProfilePropertyRequest?: try {
        guard case .setProfilePropertyRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      }()
      case .listSessionsRequest?: try {
        guard case .listSessionsRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      }()
      case .sendTextRequest?: try {
        guard case .sendTextRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
      }()
      case .createTabRequest?: try {
        guard case .createTabRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
      }()
      case .splitPaneRequest?: try {
        guard case .splitPaneRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
      }()
      case .getProfilePropertyRequest?: try {
        guard case .getProfilePropertyRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
      }()
      case .setPropertyRequest?: try {
        guard case .setPropertyRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
      }()
      case .getPropertyRequest?: try {
        guard case .getPropertyRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
      }()
      case .injectRequest?: try {
        guard case .injectRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
      }()
      case .activateRequest?: try {
        guard case .activateRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
      }()
      case .variableRequest?: try {
        guard case .variableRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
      }()
      case .savedArrangementRequest?: try {
        guard case .savedArrangementRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
      }()
      case .focusRequest?: try {
        guard case .focusRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
      }()
      case .listProfilesRequest?: try {
        guard case .listProfilesRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
      }()
      case .serverOriginatedRpcResultRequest?: try {
        guard case .serverOriginatedRpcResultRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
      }()
      case .restartSessionRequest?: try {
        guard case .restartSessionRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
      }()
      case .menuItemRequest?: try {
        guard case .menuItemRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
      }()
      case .setTabLayoutRequest?: try {
        guard case .setTabLayoutRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
      }()
      case .getBroadcastDomainsRequest?: try {
        guard case .getBroadcastDomainsRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
      }()
      case .tmuxRequest?: try {
        guard case .tmuxRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
      }()
      case .reorderTabsRequest?: try {
        guard case .reorderTabsRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
      }()
      case .preferencesRequest?: try {
        guard case .preferencesRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
      }()
      case .colorPresetRequest?: try {
        guard case .colorPresetRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
      }()
      case .selectionRequest?: try {
        guard case .selectionRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
      }()
      case .statusBarComponentRequest?: try {
        guard case .statusBarComponentRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
      }()
      case .setBroadcastDomainsRequest?: try {
        guard case .setBroadcastDomainsRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
      }()
      case .closeRequest?: try {
        guard case .closeRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
      }()
      case .invokeFunctionRequest?: try {
        guard case .invokeFunctionRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
      }()
      case .listPromptsRequest?: try {
        guard case .listPromptsRequest(let v)? = _storage._submessage else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ClientOriginatedMessage, rhs: Iterm2_ClientOriginatedMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._submessage != rhs_storage._submessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ServerOriginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerOriginatedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    100: .standard(proto: "get_buffer_response"),
    101: .standard(proto: "get_prompt_response"),
    102: .standard(proto: "transaction_response"),
    103: .standard(proto: "notification_response"),
    104: .standard(proto: "register_tool_response"),
    105: .standard(proto: "set_profile_property_response"),
    106: .standard(proto: "list_sessions_response"),
    107: .standard(proto: "send_text_response"),
    108: .standard(proto: "create_tab_response"),
    109: .standard(proto: "split_pane_response"),
    110: .standard(proto: "get_profile_property_response"),
    111: .standard(proto: "set_property_response"),
    112: .standard(proto: "get_property_response"),
    113: .standard(proto: "inject_response"),
    114: .standard(proto: "activate_response"),
    115: .standard(proto: "variable_response"),
    116: .standard(proto: "saved_arrangement_response"),
    117: .standard(proto: "focus_response"),
    118: .standard(proto: "list_profiles_response"),
    119: .standard(proto: "server_originated_rpc_result_response"),
    120: .standard(proto: "restart_session_response"),
    121: .standard(proto: "menu_item_response"),
    122: .standard(proto: "set_tab_layout_response"),
    123: .standard(proto: "get_broadcast_domains_response"),
    124: .standard(proto: "tmux_response"),
    125: .standard(proto: "reorder_tabs_response"),
    126: .standard(proto: "preferences_response"),
    127: .standard(proto: "color_preset_response"),
    128: .standard(proto: "selection_response"),
    129: .standard(proto: "status_bar_component_response"),
    130: .standard(proto: "set_broadcast_domains_response"),
    131: .standard(proto: "close_response"),
    132: .standard(proto: "invoke_function_response"),
    133: .standard(proto: "list_prompts_response"),
    1000: .same(proto: "notification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.submessage != nil {try decoder.handleConflictingOneOf()}
          self.submessage = .error(v)
        }
      }()
      case 100: try {
        var v: Iterm2_GetBufferResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getBufferResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getBufferResponse(v)
        }
      }()
      case 101: try {
        var v: Iterm2_GetPromptResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getPromptResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getPromptResponse(v)
        }
      }()
      case 102: try {
        var v: Iterm2_TransactionResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .transactionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .transactionResponse(v)
        }
      }()
      case 103: try {
        var v: Iterm2_NotificationResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .notificationResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .notificationResponse(v)
        }
      }()
      case 104: try {
        var v: Iterm2_RegisterToolResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .registerToolResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .registerToolResponse(v)
        }
      }()
      case 105: try {
        var v: Iterm2_SetProfilePropertyResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .setProfilePropertyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .setProfilePropertyResponse(v)
        }
      }()
      case 106: try {
        var v: Iterm2_ListSessionsResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .listSessionsResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .listSessionsResponse(v)
        }
      }()
      case 107: try {
        var v: Iterm2_SendTextResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .sendTextResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .sendTextResponse(v)
        }
      }()
      case 108: try {
        var v: Iterm2_CreateTabResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .createTabResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .createTabResponse(v)
        }
      }()
      case 109: try {
        var v: Iterm2_SplitPaneResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .splitPaneResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .splitPaneResponse(v)
        }
      }()
      case 110: try {
        var v: Iterm2_GetProfilePropertyResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getProfilePropertyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getProfilePropertyResponse(v)
        }
      }()
      case 111: try {
        var v: Iterm2_SetPropertyResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .setPropertyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .setPropertyResponse(v)
        }
      }()
      case 112: try {
        var v: Iterm2_GetPropertyResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getPropertyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getPropertyResponse(v)
        }
      }()
      case 113: try {
        var v: Iterm2_InjectResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .injectResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .injectResponse(v)
        }
      }()
      case 114: try {
        var v: Iterm2_ActivateResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .activateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .activateResponse(v)
        }
      }()
      case 115: try {
        var v: Iterm2_VariableResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .variableResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .variableResponse(v)
        }
      }()
      case 116: try {
        var v: Iterm2_SavedArrangementResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .savedArrangementResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .savedArrangementResponse(v)
        }
      }()
      case 117: try {
        var v: Iterm2_FocusResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .focusResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .focusResponse(v)
        }
      }()
      case 118: try {
        var v: Iterm2_ListProfilesResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .listProfilesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .listProfilesResponse(v)
        }
      }()
      case 119: try {
        var v: Iterm2_ServerOriginatedRPCResultResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .serverOriginatedRpcResultResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .serverOriginatedRpcResultResponse(v)
        }
      }()
      case 120: try {
        var v: Iterm2_RestartSessionResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .restartSessionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .restartSessionResponse(v)
        }
      }()
      case 121: try {
        var v: Iterm2_MenuItemResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .menuItemResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .menuItemResponse(v)
        }
      }()
      case 122: try {
        var v: Iterm2_SetTabLayoutResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .setTabLayoutResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .setTabLayoutResponse(v)
        }
      }()
      case 123: try {
        var v: Iterm2_GetBroadcastDomainsResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getBroadcastDomainsResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getBroadcastDomainsResponse(v)
        }
      }()
      case 124: try {
        var v: Iterm2_TmuxResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .tmuxResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .tmuxResponse(v)
        }
      }()
      case 125: try {
        var v: Iterm2_ReorderTabsResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .reorderTabsResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .reorderTabsResponse(v)
        }
      }()
      case 126: try {
        var v: Iterm2_PreferencesResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .preferencesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .preferencesResponse(v)
        }
      }()
      case 127: try {
        var v: Iterm2_ColorPresetResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .colorPresetResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .colorPresetResponse(v)
        }
      }()
      case 128: try {
        var v: Iterm2_SelectionResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .selectionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .selectionResponse(v)
        }
      }()
      case 129: try {
        var v: Iterm2_StatusBarComponentResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .statusBarComponentResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .statusBarComponentResponse(v)
        }
      }()
      case 130: try {
        var v: Iterm2_SetBroadcastDomainsResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .setBroadcastDomainsResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .setBroadcastDomainsResponse(v)
        }
      }()
      case 131: try {
        var v: Iterm2_CloseResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .closeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .closeResponse(v)
        }
      }()
      case 132: try {
        var v: Iterm2_InvokeFunctionResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .invokeFunctionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .invokeFunctionResponse(v)
        }
      }()
      case 133: try {
        var v: Iterm2_ListPromptsResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .listPromptsResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .listPromptsResponse(v)
        }
      }()
      case 1000: try {
        var v: Iterm2_Notification?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .notification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .notification(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.submessage {
    case .error?: try {
      guard case .error(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .getBufferResponse?: try {
      guard case .getBufferResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .getPromptResponse?: try {
      guard case .getPromptResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .transactionResponse?: try {
      guard case .transactionResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .notificationResponse?: try {
      guard case .notificationResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .registerToolResponse?: try {
      guard case .registerToolResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .setProfilePropertyResponse?: try {
      guard case .setProfilePropertyResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .listSessionsResponse?: try {
      guard case .listSessionsResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .sendTextResponse?: try {
      guard case .sendTextResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .createTabResponse?: try {
      guard case .createTabResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .splitPaneResponse?: try {
      guard case .splitPaneResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .getProfilePropertyResponse?: try {
      guard case .getProfilePropertyResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .setPropertyResponse?: try {
      guard case .setPropertyResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .getPropertyResponse?: try {
      guard case .getPropertyResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .injectResponse?: try {
      guard case .injectResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .activateResponse?: try {
      guard case .activateResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case .variableResponse?: try {
      guard case .variableResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
    }()
    case .savedArrangementResponse?: try {
      guard case .savedArrangementResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
    }()
    case .focusResponse?: try {
      guard case .focusResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
    }()
    case .listProfilesResponse?: try {
      guard case .listProfilesResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
    }()
    case .serverOriginatedRpcResultResponse?: try {
      guard case .serverOriginatedRpcResultResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
    }()
    case .restartSessionResponse?: try {
      guard case .restartSessionResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
    }()
    case .menuItemResponse?: try {
      guard case .menuItemResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
    }()
    case .setTabLayoutResponse?: try {
      guard case .setTabLayoutResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
    }()
    case .getBroadcastDomainsResponse?: try {
      guard case .getBroadcastDomainsResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
    }()
    case .tmuxResponse?: try {
      guard case .tmuxResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
    }()
    case .reorderTabsResponse?: try {
      guard case .reorderTabsResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
    }()
    case .preferencesResponse?: try {
      guard case .preferencesResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
    }()
    case .colorPresetResponse?: try {
      guard case .colorPresetResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
    }()
    case .selectionResponse?: try {
      guard case .selectionResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
    }()
    case .statusBarComponentResponse?: try {
      guard case .statusBarComponentResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
    }()
    case .setBroadcastDomainsResponse?: try {
      guard case .setBroadcastDomainsResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
    }()
    case .closeResponse?: try {
      guard case .closeResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
    }()
    case .invokeFunctionResponse?: try {
      guard case .invokeFunctionResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
    }()
    case .listPromptsResponse?: try {
      guard case .listPromptsResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
    }()
    case .notification?: try {
      guard case .notification(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ServerOriginatedMessage, rhs: Iterm2_ServerOriginatedMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.submessage != rhs.submessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvokeFunctionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tab"),
    2: .same(proto: "session"),
    3: .same(proto: "window"),
    4: .same(proto: "app"),
    7: .same(proto: "method"),
    5: .same(proto: "invocation"),
    6: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_InvokeFunctionRequest.Tab?
        var hadOneofValue = false
        if let current = self.context {
          hadOneofValue = true
          if case .tab(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.context = .tab(v)
        }
      }()
      case 2: try {
        var v: Iterm2_InvokeFunctionRequest.Session?
        var hadOneofValue = false
        if let current = self.context {
          hadOneofValue = true
          if case .session(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.context = .session(v)
        }
      }()
      case 3: try {
        var v: Iterm2_InvokeFunctionRequest.Window?
        var hadOneofValue = false
        if let current = self.context {
          hadOneofValue = true
          if case .window(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.context = .window(v)
        }
      }()
      case 4: try {
        var v: Iterm2_InvokeFunctionRequest.App?
        var hadOneofValue = false
        if let current = self.context {
          hadOneofValue = true
          if case .app(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.context = .app(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._invocation) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self._timeout) }()
      case 7: try {
        var v: Iterm2_InvokeFunctionRequest.Method?
        var hadOneofValue = false
        if let current = self.context {
          hadOneofValue = true
          if case .method(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.context = .method(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.context {
    case .tab?: try {
      guard case .tab(let v)? = self.context else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .session?: try {
      guard case .session(let v)? = self.context else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .window?: try {
      guard case .window(let v)? = self.context else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .app?: try {
      guard case .app(let v)? = self.context else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    if let v = self._invocation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._timeout {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }
    if case .method(let v)? = self.context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionRequest, rhs: Iterm2_InvokeFunctionRequest) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs._invocation != rhs._invocation {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionRequest.Tab: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_InvokeFunctionRequest.protoMessageName + ".Tab"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tab_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tabID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tabID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionRequest.Tab, rhs: Iterm2_InvokeFunctionRequest.Tab) -> Bool {
    if lhs._tabID != rhs._tabID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionRequest.Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_InvokeFunctionRequest.protoMessageName + ".Session"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionRequest.Session, rhs: Iterm2_InvokeFunctionRequest.Session) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionRequest.Window: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_InvokeFunctionRequest.protoMessageName + ".Window"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionRequest.Window, rhs: Iterm2_InvokeFunctionRequest.Window) -> Bool {
    if lhs._windowID != rhs._windowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionRequest.App: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_InvokeFunctionRequest.protoMessageName + ".App"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionRequest.App, rhs: Iterm2_InvokeFunctionRequest.App) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionRequest.Method: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_InvokeFunctionRequest.protoMessageName + ".Method"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._receiver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._receiver {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionRequest.Method, rhs: Iterm2_InvokeFunctionRequest.Method) -> Bool {
    if lhs._receiver != rhs._receiver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvokeFunctionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_InvokeFunctionResponse.Error?
        var hadOneofValue = false
        if let current = self.disposition {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.disposition = .error(v)
        }
      }()
      case 2: try {
        var v: Iterm2_InvokeFunctionResponse.Success?
        var hadOneofValue = false
        if let current = self.disposition {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.disposition = .success(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.disposition {
    case .error?: try {
      guard case .error(let v)? = self.disposition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.disposition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionResponse, rhs: Iterm2_InvokeFunctionResponse) -> Bool {
    if lhs.disposition != rhs.disposition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TIMEOUT"),
    2: .same(proto: "FAILED"),
    3: .same(proto: "REQUEST_MALFORMED"),
    4: .same(proto: "INVALID_ID"),
  ]
}

extension Iterm2_InvokeFunctionResponse.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_InvokeFunctionResponse.protoMessageName + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "error_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._errorReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._errorReason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionResponse.Error, rhs: Iterm2_InvokeFunctionResponse.Error) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._errorReason != rhs._errorReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InvokeFunctionResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_InvokeFunctionResponse.protoMessageName + ".Success"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._jsonResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jsonResult {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InvokeFunctionResponse.Success, rhs: Iterm2_InvokeFunctionResponse.Success) -> Bool {
    if lhs._jsonResult != rhs._jsonResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CloseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tabs"),
    2: .same(proto: "sessions"),
    3: .same(proto: "windows"),
    4: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_CloseRequest.CloseTabs?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .tabs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .tabs(v)
        }
      }()
      case 2: try {
        var v: Iterm2_CloseRequest.CloseSessions?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .sessions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .sessions(v)
        }
      }()
      case 3: try {
        var v: Iterm2_CloseRequest.CloseWindows?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .windows(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .windows(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._force) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.target {
    case .tabs?: try {
      guard case .tabs(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sessions?: try {
      guard case .sessions(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .windows?: try {
      guard case .windows(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if let v = self._force {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CloseRequest, rhs: Iterm2_CloseRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs._force != rhs._force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CloseRequest.CloseTabs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_CloseRequest.protoMessageName + ".CloseTabs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tab_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tabIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tabIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tabIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CloseRequest.CloseTabs, rhs: Iterm2_CloseRequest.CloseTabs) -> Bool {
    if lhs.tabIds != rhs.tabIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CloseRequest.CloseSessions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_CloseRequest.protoMessageName + ".CloseSessions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.sessionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sessionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CloseRequest.CloseSessions, rhs: Iterm2_CloseRequest.CloseSessions) -> Bool {
    if lhs.sessionIds != rhs.sessionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CloseRequest.CloseWindows: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_CloseRequest.protoMessageName + ".CloseWindows"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.windowIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.windowIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.windowIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CloseRequest.CloseWindows, rhs: Iterm2_CloseRequest.CloseWindows) -> Bool {
    if lhs.windowIds != rhs.windowIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CloseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.statuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statuses.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.statuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CloseResponse, rhs: Iterm2_CloseResponse) -> Bool {
    if lhs.statuses != rhs.statuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CloseResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NOT_FOUND"),
    2: .same(proto: "USER_DECLINED"),
  ]
}

extension Iterm2_SetBroadcastDomainsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetBroadcastDomainsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "broadcast_domains"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.broadcastDomains) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.broadcastDomains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.broadcastDomains, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetBroadcastDomainsRequest, rhs: Iterm2_SetBroadcastDomainsRequest) -> Bool {
    if lhs.broadcastDomains != rhs.broadcastDomains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetBroadcastDomainsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetBroadcastDomainsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetBroadcastDomainsResponse, rhs: Iterm2_SetBroadcastDomainsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetBroadcastDomainsResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "BROADCAST_DOMAINS_NOT_DISJOINT"),
    3: .same(proto: "SESSIONS_NOT_IN_SAME_WINDOW"),
  ]
}

extension Iterm2_StatusBarComponentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusBarComponentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_popover"),
    2: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_StatusBarComponentRequest.OpenPopover?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .openPopover(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .openPopover(v)
        }
      }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .openPopover(let v)? = self.request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_StatusBarComponentRequest, rhs: Iterm2_StatusBarComponentRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_StatusBarComponentRequest.OpenPopover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_StatusBarComponentRequest.protoMessageName + ".OpenPopover"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "html"),
    3: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._html) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._html {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_StatusBarComponentRequest.OpenPopover, rhs: Iterm2_StatusBarComponentRequest.OpenPopover) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._html != rhs._html {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_StatusBarComponentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusBarComponentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_StatusBarComponentResponse, rhs: Iterm2_StatusBarComponentResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_StatusBarComponentResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "REQUEST_MALFORMED"),
    3: .same(proto: "INVALID_IDENTIFIER"),
  ]
}

extension Iterm2_WindowedCoordRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WindowedCoordRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coord_range"),
    2: .same(proto: "columns"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordRange) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._columns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._coordRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._columns {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_WindowedCoordRange, rhs: Iterm2_WindowedCoordRange) -> Bool {
    if lhs._coordRange != rhs._coordRange {return false}
    if lhs._columns != rhs._columns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SubSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubSelection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "windowed_coord_range"),
    2: .standard(proto: "selection_mode"),
    3: .same(proto: "connected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._windowedCoordRange) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._selectionMode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._connected) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._windowedCoordRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._selectionMode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._connected {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SubSelection, rhs: Iterm2_SubSelection) -> Bool {
    if lhs._windowedCoordRange != rhs._windowedCoordRange {return false}
    if lhs._selectionMode != rhs._selectionMode {return false}
    if lhs._connected != rhs._connected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_Selection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Selection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sub_selections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subSelections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subSelections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subSelections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_Selection, rhs: Iterm2_Selection) -> Bool {
    if lhs.subSelections != rhs.subSelections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SelectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_selection_request"),
    2: .standard(proto: "set_selection_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_SelectionRequest.GetSelectionRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getSelectionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getSelectionRequest(v)
        }
      }()
      case 2: try {
        var v: Iterm2_SelectionRequest.SetSelectionRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .setSelectionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .setSelectionRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .getSelectionRequest?: try {
      guard case .getSelectionRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .setSelectionRequest?: try {
      guard case .setSelectionRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SelectionRequest, rhs: Iterm2_SelectionRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SelectionRequest.GetSelectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_SelectionRequest.protoMessageName + ".GetSelectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SelectionRequest.GetSelectionRequest, rhs: Iterm2_SelectionRequest.GetSelectionRequest) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SelectionRequest.SetSelectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_SelectionRequest.protoMessageName + ".SetSelectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "selection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._selection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SelectionRequest.SetSelectionRequest, rhs: Iterm2_SelectionRequest.SetSelectionRequest) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._selection != rhs._selection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SelectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelectionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "get_selection_response"),
    3: .standard(proto: "set_selection_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try {
        var v: Iterm2_SelectionResponse.GetSelectionResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getSelectionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getSelectionResponse(v)
        }
      }()
      case 3: try {
        var v: Iterm2_SelectionResponse.SetSelectionResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .setSelectionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .setSelectionResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.response {
    case .getSelectionResponse?: try {
      guard case .getSelectionResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setSelectionResponse?: try {
      guard case .setSelectionResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SelectionResponse, rhs: Iterm2_SelectionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SelectionResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_SESSION"),
    2: .same(proto: "INVALID_RANGE"),
    3: .same(proto: "REQUEST_MALFORMED"),
  ]
}

extension Iterm2_SelectionResponse.GetSelectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_SelectionResponse.protoMessageName + ".GetSelectionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "selection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._selection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SelectionResponse.GetSelectionResponse, rhs: Iterm2_SelectionResponse.GetSelectionResponse) -> Bool {
    if lhs._selection != rhs._selection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SelectionResponse.SetSelectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_SelectionResponse.protoMessageName + ".SetSelectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SelectionResponse.SetSelectionResponse, rhs: Iterm2_SelectionResponse.SetSelectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ColorPresetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColorPresetRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_presets"),
    2: .standard(proto: "get_preset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_ColorPresetRequest.ListPresets?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .listPresets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .listPresets(v)
        }
      }()
      case 2: try {
        var v: Iterm2_ColorPresetRequest.GetPreset?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getPreset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getPreset(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .listPresets?: try {
      guard case .listPresets(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getPreset?: try {
      guard case .getPreset(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ColorPresetRequest, rhs: Iterm2_ColorPresetRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ColorPresetRequest.ListPresets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ColorPresetRequest.protoMessageName + ".ListPresets"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ColorPresetRequest.ListPresets, rhs: Iterm2_ColorPresetRequest.ListPresets) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ColorPresetRequest.GetPreset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ColorPresetRequest.protoMessageName + ".GetPreset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ColorPresetRequest.GetPreset, rhs: Iterm2_ColorPresetRequest.GetPreset) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ColorPresetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ColorPresetResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_presets"),
    2: .standard(proto: "get_preset"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_ColorPresetResponse.ListPresets?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .listPresets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .listPresets(v)
        }
      }()
      case 2: try {
        var v: Iterm2_ColorPresetResponse.GetPreset?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getPreset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getPreset(v)
        }
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.response {
    case .listPresets?: try {
      guard case .listPresets(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getPreset?: try {
      guard case .getPreset(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ColorPresetResponse, rhs: Iterm2_ColorPresetResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ColorPresetResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "PRESET_NOT_FOUND"),
    2: .same(proto: "REQUEST_MALFORMED"),
  ]
}

extension Iterm2_ColorPresetResponse.ListPresets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ColorPresetResponse.protoMessageName + ".ListPresets"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitRepeatedStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ColorPresetResponse.ListPresets, rhs: Iterm2_ColorPresetResponse.ListPresets) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ColorPresetResponse.GetPreset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ColorPresetResponse.protoMessageName + ".GetPreset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "color_settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.colorSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.colorSettings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.colorSettings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ColorPresetResponse.GetPreset, rhs: Iterm2_ColorPresetResponse.GetPreset) -> Bool {
    if lhs.colorSettings != rhs.colorSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ColorPresetResponse.GetPreset.ColorSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ColorPresetResponse.GetPreset.protoMessageName + ".ColorSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "red"),
    2: .same(proto: "green"),
    3: .same(proto: "blue"),
    4: .same(proto: "alpha"),
    5: .standard(proto: "color_space"),
    6: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._red) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._green) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._blue) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._alpha) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._colorSpace) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._red {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }
    if let v = self._green {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    if let v = self._blue {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }
    if let v = self._alpha {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    }
    if let v = self._colorSpace {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ColorPresetResponse.GetPreset.ColorSetting, rhs: Iterm2_ColorPresetResponse.GetPreset.ColorSetting) -> Bool {
    if lhs._red != rhs._red {return false}
    if lhs._green != rhs._green {return false}
    if lhs._blue != rhs._blue {return false}
    if lhs._alpha != rhs._alpha {return false}
    if lhs._colorSpace != rhs._colorSpace {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreferencesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesRequest, rhs: Iterm2_PreferencesRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesRequest.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesRequest.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_preference_request"),
    2: .standard(proto: "get_preference_request"),
    3: .standard(proto: "set_default_profile_request"),
    4: .standard(proto: "get_default_profile_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_PreferencesRequest.Request.SetPreference?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .setPreferenceRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .setPreferenceRequest(v)
        }
      }()
      case 2: try {
        var v: Iterm2_PreferencesRequest.Request.GetPreference?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getPreferenceRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getPreferenceRequest(v)
        }
      }()
      case 3: try {
        var v: Iterm2_PreferencesRequest.Request.SetDefaultProfile?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .setDefaultProfileRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .setDefaultProfileRequest(v)
        }
      }()
      case 4: try {
        var v: Iterm2_PreferencesRequest.Request.GetDefaultProfile?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getDefaultProfileRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getDefaultProfileRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .setPreferenceRequest?: try {
      guard case .setPreferenceRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getPreferenceRequest?: try {
      guard case .getPreferenceRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setDefaultProfileRequest?: try {
      guard case .setDefaultProfileRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getDefaultProfileRequest?: try {
      guard case .getDefaultProfileRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesRequest.Request, rhs: Iterm2_PreferencesRequest.Request) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesRequest.Request.SetPreference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesRequest.Request.protoMessageName + ".SetPreference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesRequest.Request.SetPreference, rhs: Iterm2_PreferencesRequest.Request.SetPreference) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesRequest.Request.GetPreference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesRequest.Request.protoMessageName + ".GetPreference"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesRequest.Request.GetPreference, rhs: Iterm2_PreferencesRequest.Request.GetPreference) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesRequest.Request.SetDefaultProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesRequest.Request.protoMessageName + ".SetDefaultProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._guid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._guid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesRequest.Request.SetDefaultProfile, rhs: Iterm2_PreferencesRequest.Request.SetDefaultProfile) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesRequest.Request.GetDefaultProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesRequest.Request.protoMessageName + ".GetDefaultProfile"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesRequest.Request.GetDefaultProfile, rhs: Iterm2_PreferencesRequest.Request.GetDefaultProfile) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreferencesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesResponse, rhs: Iterm2_PreferencesResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesResponse.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesResponse.protoMessageName + ".Result"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unrecognized_request"),
    2: .standard(proto: "set_preference_result"),
    3: .standard(proto: "get_preference_result"),
    4: .standard(proto: "set_default_profile_result"),
    5: .standard(proto: "get_default_profile_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_PreferencesResponse.Result.UnrecognizedResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .unrecognizedRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .unrecognizedRequest(v)
        }
      }()
      case 2: try {
        var v: Iterm2_PreferencesResponse.Result.SetPreferenceResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .setPreferenceResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .setPreferenceResult(v)
        }
      }()
      case 3: try {
        var v: Iterm2_PreferencesResponse.Result.GetPreferenceResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .getPreferenceResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .getPreferenceResult(v)
        }
      }()
      case 4: try {
        var v: Iterm2_PreferencesResponse.Result.SetDefaultProfileResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .setDefaultProfileResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .setDefaultProfileResult(v)
        }
      }()
      case 5: try {
        var v: Iterm2_PreferencesResponse.Result.GetDefaultProfileResult?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .getDefaultProfileResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .getDefaultProfileResult(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.result {
    case .unrecognizedRequest?: try {
      guard case .unrecognizedRequest(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .setPreferenceResult?: try {
      guard case .setPreferenceResult(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getPreferenceResult?: try {
      guard case .getPreferenceResult(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .setDefaultProfileResult?: try {
      guard case .setDefaultProfileResult(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .getDefaultProfileResult?: try {
      guard case .getDefaultProfileResult(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesResponse.Result, rhs: Iterm2_PreferencesResponse.Result) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesResponse.Result.SetPreferenceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesResponse.Result.protoMessageName + ".SetPreferenceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesResponse.Result.SetPreferenceResult, rhs: Iterm2_PreferencesResponse.Result.SetPreferenceResult) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesResponse.Result.SetPreferenceResult.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "BAD_JSON"),
    2: .same(proto: "INVALID_VALUE"),
  ]
}

extension Iterm2_PreferencesResponse.Result.GetPreferenceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesResponse.Result.protoMessageName + ".GetPreferenceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesResponse.Result.GetPreferenceResult, rhs: Iterm2_PreferencesResponse.Result.GetPreferenceResult) -> Bool {
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesResponse.Result.SetDefaultProfileResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesResponse.Result.protoMessageName + ".SetDefaultProfileResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesResponse.Result.SetDefaultProfileResult, rhs: Iterm2_PreferencesResponse.Result.SetDefaultProfileResult) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesResponse.Result.SetDefaultProfileResult.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "BAD_GUID"),
  ]
}

extension Iterm2_PreferencesResponse.Result.UnrecognizedResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesResponse.Result.protoMessageName + ".UnrecognizedResult"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesResponse.Result.UnrecognizedResult, rhs: Iterm2_PreferencesResponse.Result.UnrecognizedResult) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PreferencesResponse.Result.GetDefaultProfileResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_PreferencesResponse.Result.protoMessageName + ".GetDefaultProfileResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._guid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._guid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PreferencesResponse.Result.GetDefaultProfileResult, rhs: Iterm2_PreferencesResponse.Result.GetDefaultProfileResult) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ReorderTabsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReorderTabsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "assignments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.assignments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ReorderTabsRequest, rhs: Iterm2_ReorderTabsRequest) -> Bool {
    if lhs.assignments != rhs.assignments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ReorderTabsRequest.Assignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ReorderTabsRequest.protoMessageName + ".Assignment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_id"),
    2: .standard(proto: "tab_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.tabIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.tabIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tabIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ReorderTabsRequest.Assignment, rhs: Iterm2_ReorderTabsRequest.Assignment) -> Bool {
    if lhs._windowID != rhs._windowID {return false}
    if lhs.tabIds != rhs.tabIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ReorderTabsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReorderTabsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ReorderTabsResponse, rhs: Iterm2_ReorderTabsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ReorderTabsResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_ASSIGNMENT"),
    2: .same(proto: "INVALID_WINDOW_ID"),
    3: .same(proto: "INVALID_TAB_ID"),
  ]
}

extension Iterm2_TmuxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TmuxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_connections"),
    2: .standard(proto: "send_command"),
    3: .standard(proto: "set_window_visible"),
    4: .standard(proto: "create_window"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_TmuxRequest.ListConnections?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .listConnections(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .listConnections(v)
        }
      }()
      case 2: try {
        var v: Iterm2_TmuxRequest.SendCommand?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .sendCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .sendCommand(v)
        }
      }()
      case 3: try {
        var v: Iterm2_TmuxRequest.SetWindowVisible?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setWindowVisible(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setWindowVisible(v)
        }
      }()
      case 4: try {
        var v: Iterm2_TmuxRequest.CreateWindow?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .createWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .createWindow(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .listConnections?: try {
      guard case .listConnections(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sendCommand?: try {
      guard case .sendCommand(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setWindowVisible?: try {
      guard case .setWindowVisible(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .createWindow?: try {
      guard case .createWindow(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxRequest, rhs: Iterm2_TmuxRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxRequest.ListConnections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxRequest.protoMessageName + ".ListConnections"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxRequest.ListConnections, rhs: Iterm2_TmuxRequest.ListConnections) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxRequest.SendCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxRequest.protoMessageName + ".SendCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._connectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._command) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._connectionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._command {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxRequest.SendCommand, rhs: Iterm2_TmuxRequest.SendCommand) -> Bool {
    if lhs._connectionID != rhs._connectionID {return false}
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxRequest.SetWindowVisible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxRequest.protoMessageName + ".SetWindowVisible"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .standard(proto: "window_id"),
    3: .same(proto: "visible"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._connectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._visible) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._connectionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._visible {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxRequest.SetWindowVisible, rhs: Iterm2_TmuxRequest.SetWindowVisible) -> Bool {
    if lhs._connectionID != rhs._connectionID {return false}
    if lhs._windowID != rhs._windowID {return false}
    if lhs._visible != rhs._visible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxRequest.CreateWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxRequest.protoMessageName + ".CreateWindow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .same(proto: "affinity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._connectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._affinity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._connectionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._affinity {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxRequest.CreateWindow, rhs: Iterm2_TmuxRequest.CreateWindow) -> Bool {
    if lhs._connectionID != rhs._connectionID {return false}
    if lhs._affinity != rhs._affinity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TmuxResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_connections"),
    2: .standard(proto: "send_command"),
    3: .standard(proto: "set_window_visible"),
    5: .standard(proto: "create_window"),
    4: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_TmuxResponse.ListConnections?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .listConnections(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .listConnections(v)
        }
      }()
      case 2: try {
        var v: Iterm2_TmuxResponse.SendCommand?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .sendCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .sendCommand(v)
        }
      }()
      case 3: try {
        var v: Iterm2_TmuxResponse.SetWindowVisible?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .setWindowVisible(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .setWindowVisible(v)
        }
      }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 5: try {
        var v: Iterm2_TmuxResponse.CreateWindow?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .createWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .createWindow(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .listConnections?: try {
      guard case .listConnections(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sendCommand?: try {
      guard case .sendCommand(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setWindowVisible?: try {
      guard case .setWindowVisible(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if case .createWindow(let v)? = self.payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxResponse, rhs: Iterm2_TmuxResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_REQUEST"),
    2: .same(proto: "INVALID_CONNECTION_ID"),
    3: .same(proto: "INVALID_WINDOW_ID"),
  ]
}

extension Iterm2_TmuxResponse.ListConnections: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxResponse.protoMessageName + ".ListConnections"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.connections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxResponse.ListConnections, rhs: Iterm2_TmuxResponse.ListConnections) -> Bool {
    if lhs.connections != rhs.connections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxResponse.ListConnections.Connection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxResponse.ListConnections.protoMessageName + ".Connection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_id"),
    2: .standard(proto: "owning_session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._connectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._owningSessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._connectionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._owningSessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxResponse.ListConnections.Connection, rhs: Iterm2_TmuxResponse.ListConnections.Connection) -> Bool {
    if lhs._connectionID != rhs._connectionID {return false}
    if lhs._owningSessionID != rhs._owningSessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxResponse.SendCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxResponse.protoMessageName + ".SendCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._output) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._output {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxResponse.SendCommand, rhs: Iterm2_TmuxResponse.SendCommand) -> Bool {
    if lhs._output != rhs._output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxResponse.SetWindowVisible: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxResponse.protoMessageName + ".SetWindowVisible"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxResponse.SetWindowVisible, rhs: Iterm2_TmuxResponse.SetWindowVisible) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TmuxResponse.CreateWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_TmuxResponse.protoMessageName + ".CreateWindow"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tab_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tabID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tabID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TmuxResponse.CreateWindow, rhs: Iterm2_TmuxResponse.CreateWindow) -> Bool {
    if lhs._tabID != rhs._tabID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetBroadcastDomainsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBroadcastDomainsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetBroadcastDomainsRequest, rhs: Iterm2_GetBroadcastDomainsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_BroadcastDomain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastDomain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.sessionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sessionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_BroadcastDomain, rhs: Iterm2_BroadcastDomain) -> Bool {
    if lhs.sessionIds != rhs.sessionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetBroadcastDomainsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBroadcastDomainsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "broadcast_domains"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.broadcastDomains) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.broadcastDomains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.broadcastDomains, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetBroadcastDomainsResponse, rhs: Iterm2_GetBroadcastDomainsResponse) -> Bool {
    if lhs.broadcastDomains != rhs.broadcastDomains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetTabLayoutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTabLayoutRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "root"),
    2: .standard(proto: "tab_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._root) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._tabID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._root {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._tabID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetTabLayoutRequest, rhs: Iterm2_SetTabLayoutRequest) -> Bool {
    if lhs._root != rhs._root {return false}
    if lhs._tabID != rhs._tabID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetTabLayoutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTabLayoutResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetTabLayoutResponse, rhs: Iterm2_SetTabLayoutResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetTabLayoutResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "BAD_TAB_ID"),
    2: .same(proto: "WRONG_TREE"),
    3: .same(proto: "INVALID_SIZE"),
  ]
}

extension Iterm2_MenuItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MenuItemRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .standard(proto: "query_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._queryOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._queryOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_MenuItemRequest, rhs: Iterm2_MenuItemRequest) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._queryOnly != rhs._queryOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_MenuItemResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MenuItemResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "checked"),
    3: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._checked) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._checked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_MenuItemResponse, rhs: Iterm2_MenuItemResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._checked != rhs._checked {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_MenuItemResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "BAD_IDENTIFIER"),
    2: .same(proto: "DISABLED"),
  ]
}

extension Iterm2_RestartSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestartSessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "only_if_exited"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._onlyIfExited) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._onlyIfExited {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RestartSessionRequest, rhs: Iterm2_RestartSessionRequest) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._onlyIfExited != rhs._onlyIfExited {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RestartSessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RestartSessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RestartSessionResponse, rhs: Iterm2_RestartSessionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RestartSessionResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "SESSION_NOT_RESTARTABLE"),
  ]
}

extension Iterm2_ServerOriginatedRPCResultRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerOriginatedRPCResultRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "json_exception"),
    3: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._requestID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .jsonException(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .jsonValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._requestID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.result {
    case .jsonException?: try {
      guard case .jsonException(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .jsonValue?: try {
      guard case .jsonValue(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ServerOriginatedRPCResultRequest, rhs: Iterm2_ServerOriginatedRPCResultRequest) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ServerOriginatedRPCResultResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerOriginatedRPCResultResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ServerOriginatedRPCResultResponse, rhs: Iterm2_ServerOriginatedRPCResultResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListProfilesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListProfilesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
    2: .same(proto: "guids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.properties) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.guids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitRepeatedStringField(value: self.properties, fieldNumber: 1)
    }
    if !self.guids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.guids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListProfilesRequest, rhs: Iterm2_ListProfilesRequest) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs.guids != rhs.guids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListProfilesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListProfilesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profiles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.profiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.profiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.profiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListProfilesResponse, rhs: Iterm2_ListProfilesResponse) -> Bool {
    if lhs.profiles != rhs.profiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListProfilesResponse.Profile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ListProfilesResponse.protoMessageName + ".Profile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListProfilesResponse.Profile, rhs: Iterm2_ListProfilesResponse.Profile) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_FocusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FocusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_FocusRequest, rhs: Iterm2_FocusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_FocusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FocusResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_FocusResponse, rhs: Iterm2_FocusResponse) -> Bool {
    if lhs.notifications != rhs.notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SavedArrangementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedArrangementRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "action"),
    3: .standard(proto: "window_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SavedArrangementRequest, rhs: Iterm2_SavedArrangementRequest) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._action != rhs._action {return false}
    if lhs._windowID != rhs._windowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SavedArrangementRequest.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESTORE"),
    1: .same(proto: "SAVE"),
    2: .same(proto: "LIST"),
  ]
}

extension Iterm2_SavedArrangementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedArrangementResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SavedArrangementResponse, rhs: Iterm2_SavedArrangementResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.names != rhs.names {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SavedArrangementResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ARRANGEMENT_NOT_FOUND"),
    2: .same(proto: "WINDOW_NOT_FOUND"),
    3: .same(proto: "REQUEST_MALFORMED"),
  ]
}

extension Iterm2_VariableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VariableRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    4: .standard(proto: "tab_id"),
    5: .same(proto: "app"),
    6: .standard(proto: "window_id"),
    2: .same(proto: "set"),
    3: .same(proto: "get"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.scope != nil {try decoder.handleConflictingOneOf()}
          self.scope = .sessionID(v)
        }
      }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.set) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.get) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.scope != nil {try decoder.handleConflictingOneOf()}
          self.scope = .tabID(v)
        }
      }()
      case 5: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.scope != nil {try decoder.handleConflictingOneOf()}
          self.scope = .app(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.scope != nil {try decoder.handleConflictingOneOf()}
          self.scope = .windowID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .sessionID(let v)? = self.scope {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.set.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.set, fieldNumber: 2)
    }
    if !self.get.isEmpty {
      try visitor.visitRepeatedStringField(value: self.get, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.scope {
    case .tabID?: try {
      guard case .tabID(let v)? = self.scope else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .app?: try {
      guard case .app(let v)? = self.scope else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }()
    case .windowID?: try {
      guard case .windowID(let v)? = self.scope else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_VariableRequest, rhs: Iterm2_VariableRequest) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.set != rhs.set {return false}
    if lhs.get != rhs.get {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_VariableRequest.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_VariableRequest.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_VariableRequest.Set, rhs: Iterm2_VariableRequest.Set) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_VariableResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VariableResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_VariableResponse, rhs: Iterm2_VariableResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_VariableResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "INVALID_NAME"),
    3: .same(proto: "MISSING_SCOPE"),
    4: .same(proto: "TAB_NOT_FOUND"),
    5: .same(proto: "MULTI_GET_DISALLOWED"),
    6: .same(proto: "WINDOW_NOT_FOUND"),
  ]
}

extension Iterm2_ActivateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_id"),
    2: .standard(proto: "tab_id"),
    3: .standard(proto: "session_id"),
    4: .standard(proto: "order_window_front"),
    5: .standard(proto: "select_tab"),
    6: .standard(proto: "select_session"),
    7: .standard(proto: "activate_app"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .windowID(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .tabID(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .sessionID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._orderWindowFront) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._selectTab) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._selectSession) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._activateApp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.identifier {
    case .windowID?: try {
      guard case .windowID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .tabID?: try {
      guard case .tabID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .sessionID?: try {
      guard case .sessionID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if let v = self._orderWindowFront {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._selectTab {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._selectSession {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._activateApp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ActivateRequest, rhs: Iterm2_ActivateRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._orderWindowFront != rhs._orderWindowFront {return false}
    if lhs._selectTab != rhs._selectTab {return false}
    if lhs._selectSession != rhs._selectSession {return false}
    if lhs._activateApp != rhs._activateApp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ActivateRequest.App: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ActivateRequest.protoMessageName + ".App"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raise_all_windows"),
    2: .standard(proto: "ignoring_other_apps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._raiseAllWindows) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._ignoringOtherApps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._raiseAllWindows {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._ignoringOtherApps {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ActivateRequest.App, rhs: Iterm2_ActivateRequest.App) -> Bool {
    if lhs._raiseAllWindows != rhs._raiseAllWindows {return false}
    if lhs._ignoringOtherApps != rhs._ignoringOtherApps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ActivateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActivateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ActivateResponse, rhs: Iterm2_ActivateResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ActivateResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "BAD_IDENTIFIER"),
    2: .same(proto: "INVALID_OPTION"),
  ]
}

extension Iterm2_InjectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InjectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sessionID, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InjectRequest, rhs: Iterm2_InjectRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InjectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InjectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_InjectResponse, rhs: Iterm2_InjectResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_InjectResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
  ]
}

extension Iterm2_GetPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPropertyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_id"),
    3: .standard(proto: "session_id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .windowID(v)
        }
      }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .sessionID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .windowID(let v)? = self.identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if case .sessionID(let v)? = self.identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetPropertyRequest, rhs: Iterm2_GetPropertyRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetPropertyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPropertyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetPropertyResponse, rhs: Iterm2_GetPropertyResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetPropertyResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "UNRECOGNIZED_NAME"),
    2: .same(proto: "INVALID_TARGET"),
  ]
}

extension Iterm2_SetPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPropertyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_id"),
    5: .standard(proto: "session_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .windowID(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .sessionID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .windowID(let v)? = self.identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if case .sessionID(let v)? = self.identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetPropertyRequest, rhs: Iterm2_SetPropertyRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._name != rhs._name {return false}
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetPropertyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPropertyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetPropertyResponse, rhs: Iterm2_SetPropertyResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetPropertyResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "UNRECOGNIZED_NAME"),
    2: .same(proto: "INVALID_VALUE"),
    3: .same(proto: "INVALID_TARGET"),
    4: .same(proto: "DEFERRED"),
    5: .same(proto: "IMPOSSIBLE"),
    6: .same(proto: "FAILED"),
  ]
}

extension Iterm2_RegisterToolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterToolRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "identifier"),
    5: .standard(proto: "reveal_if_already_registered"),
    3: .standard(proto: "tool_type"),
    4: .same(proto: "URL"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._toolType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._revealIfAlreadyRegistered) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._toolType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._revealIfAlreadyRegistered {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RegisterToolRequest, rhs: Iterm2_RegisterToolRequest) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._revealIfAlreadyRegistered != rhs._revealIfAlreadyRegistered {return false}
    if lhs._toolType != rhs._toolType {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RegisterToolRequest.ToolType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "WEB_VIEW_TOOL"),
  ]
}

extension Iterm2_RPCRegistrationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RPCRegistrationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "arguments"),
    4: .same(proto: "defaults"),
    3: .same(proto: "timeout"),
    5: .same(proto: "role"),
    7: .standard(proto: "session_title_attributes"),
    8: .standard(proto: "status_bar_component_attributes"),
    9: .standard(proto: "context_menu_attributes"),
    6: .standard(proto: "display_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._timeout) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.defaults) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._role) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      case 7: try {
        var v: Iterm2_RPCRegistrationRequest.SessionTitleAttributes?
        var hadOneofValue = false
        if let current = self.roleSpecificAttributes {
          hadOneofValue = true
          if case .sessionTitleAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.roleSpecificAttributes = .sessionTitleAttributes(v)
        }
      }()
      case 8: try {
        var v: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes?
        var hadOneofValue = false
        if let current = self.roleSpecificAttributes {
          hadOneofValue = true
          if case .statusBarComponentAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.roleSpecificAttributes = .statusBarComponentAttributes(v)
        }
      }()
      case 9: try {
        var v: Iterm2_RPCRegistrationRequest.ContextMenuAttributes?
        var hadOneofValue = false
        if let current = self.roleSpecificAttributes {
          hadOneofValue = true
          if case .contextMenuAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.roleSpecificAttributes = .contextMenuAttributes(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 2)
    }
    if let v = self._timeout {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }
    if !self.defaults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.defaults, fieldNumber: 4)
    }
    if let v = self._role {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.roleSpecificAttributes {
    case .sessionTitleAttributes?: try {
      guard case .sessionTitleAttributes(let v)? = self.roleSpecificAttributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .statusBarComponentAttributes?: try {
      guard case .statusBarComponentAttributes(let v)? = self.roleSpecificAttributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .contextMenuAttributes?: try {
      guard case .contextMenuAttributes(let v)? = self.roleSpecificAttributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest, rhs: Iterm2_RPCRegistrationRequest) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.defaults != rhs.defaults {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._role != rhs._role {return false}
    if lhs.roleSpecificAttributes != rhs.roleSpecificAttributes {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RPCRegistrationRequest.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GENERIC"),
    2: .same(proto: "SESSION_TITLE"),
    3: .same(proto: "STATUS_BAR_COMPONENT"),
    4: .same(proto: "CONTEXT_MENU"),
  ]
}

extension Iterm2_RPCRegistrationRequest.RPCArgumentSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_RPCRegistrationRequest.protoMessageName + ".RPCArgumentSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest.RPCArgumentSignature, rhs: Iterm2_RPCRegistrationRequest.RPCArgumentSignature) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RPCRegistrationRequest.RPCArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_RPCRegistrationRequest.protoMessageName + ".RPCArgument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest.RPCArgument, rhs: Iterm2_RPCRegistrationRequest.RPCArgument) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RPCRegistrationRequest.SessionTitleAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_RPCRegistrationRequest.protoMessageName + ".SessionTitleAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    6: .standard(proto: "unique_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._uniqueIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._uniqueIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest.SessionTitleAttributes, rhs: Iterm2_RPCRegistrationRequest.SessionTitleAttributes) -> Bool {
    if lhs._displayName != rhs._displayName {return false}
    if lhs._uniqueIdentifier != rhs._uniqueIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_RPCRegistrationRequest.protoMessageName + ".StatusBarComponentAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "short_description"),
    2: .standard(proto: "detailed_description"),
    3: .same(proto: "knobs"),
    4: .same(proto: "exemplar"),
    5: .standard(proto: "update_cadence"),
    6: .standard(proto: "unique_identifier"),
    7: .same(proto: "icons"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._shortDescription) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._detailedDescription) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.knobs) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._exemplar) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._updateCadence) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._uniqueIdentifier) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.icons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._shortDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._detailedDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.knobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.knobs, fieldNumber: 3)
    }
    if let v = self._exemplar {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._updateCadence {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    if let v = self._uniqueIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if !self.icons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.icons, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes, rhs: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes) -> Bool {
    if lhs._shortDescription != rhs._shortDescription {return false}
    if lhs._detailedDescription != rhs._detailedDescription {return false}
    if lhs.knobs != rhs.knobs {return false}
    if lhs._exemplar != rhs._exemplar {return false}
    if lhs._updateCadence != rhs._updateCadence {return false}
    if lhs._uniqueIdentifier != rhs._uniqueIdentifier {return false}
    if lhs.icons != rhs.icons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.protoMessageName + ".Knob"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "placeholder"),
    4: .standard(proto: "json_default_value"),
    5: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._placeholder) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._jsonDefaultValue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._placeholder {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._jsonDefaultValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob, rhs: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._type != rhs._type {return false}
    if lhs._placeholder != rhs._placeholder {return false}
    if lhs._jsonDefaultValue != rhs._jsonDefaultValue {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Knob.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Checkbox"),
    2: .same(proto: "String"),
    3: .same(proto: "PositiveFloatingPoint"),
    4: .same(proto: "Color"),
  ]
}

extension Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Icon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.protoMessageName + ".Icon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._scale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._scale {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Icon, rhs: Iterm2_RPCRegistrationRequest.StatusBarComponentAttributes.Icon) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._scale != rhs._scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RPCRegistrationRequest.ContextMenuAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_RPCRegistrationRequest.protoMessageName + ".ContextMenuAttributes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .standard(proto: "unique_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._uniqueIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._uniqueIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RPCRegistrationRequest.ContextMenuAttributes, rhs: Iterm2_RPCRegistrationRequest.ContextMenuAttributes) -> Bool {
    if lhs._displayName != rhs._displayName {return false}
    if lhs._uniqueIdentifier != rhs._uniqueIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RegisterToolResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterToolResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_RegisterToolResponse, rhs: Iterm2_RegisterToolResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_RegisterToolResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "REQUEST_MALFORMED"),
    2: .same(proto: "PERMISSION_DENIED"),
  ]
}

extension Iterm2_KeystrokePattern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeystrokePattern"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "required_modifiers"),
    2: .standard(proto: "forbidden_modifiers"),
    3: .same(proto: "keycodes"),
    4: .same(proto: "characters"),
    5: .standard(proto: "characters_ignoring_modifiers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.requiredModifiers) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.forbiddenModifiers) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.keycodes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.characters) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.charactersIgnoringModifiers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requiredModifiers.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.requiredModifiers, fieldNumber: 1)
    }
    if !self.forbiddenModifiers.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.forbiddenModifiers, fieldNumber: 2)
    }
    if !self.keycodes.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.keycodes, fieldNumber: 3)
    }
    if !self.characters.isEmpty {
      try visitor.visitRepeatedStringField(value: self.characters, fieldNumber: 4)
    }
    if !self.charactersIgnoringModifiers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.charactersIgnoringModifiers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_KeystrokePattern, rhs: Iterm2_KeystrokePattern) -> Bool {
    if lhs.requiredModifiers != rhs.requiredModifiers {return false}
    if lhs.forbiddenModifiers != rhs.forbiddenModifiers {return false}
    if lhs.keycodes != rhs.keycodes {return false}
    if lhs.characters != rhs.characters {return false}
    if lhs.charactersIgnoringModifiers != rhs.charactersIgnoringModifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_KeystrokeMonitorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeystrokeMonitorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "patterns_to_ignore"),
    2: .same(proto: "advanced"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.patternsToIgnore) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._advanced) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patternsToIgnore.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patternsToIgnore, fieldNumber: 1)
    }
    if let v = self._advanced {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_KeystrokeMonitorRequest, rhs: Iterm2_KeystrokeMonitorRequest) -> Bool {
    if lhs.patternsToIgnore != rhs.patternsToIgnore {return false}
    if lhs._advanced != rhs._advanced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_KeystrokeFilterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeystrokeFilterRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "patterns_to_ignore"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.patternsToIgnore) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patternsToIgnore.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patternsToIgnore, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_KeystrokeFilterRequest, rhs: Iterm2_KeystrokeFilterRequest) -> Bool {
    if lhs.patternsToIgnore != rhs.patternsToIgnore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_VariableMonitorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VariableMonitorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "scope"),
    3: .same(proto: "identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._scope) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._scope {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_VariableMonitorRequest, rhs: Iterm2_VariableMonitorRequest) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._scope != rhs._scope {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ProfileChangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileChangeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._guid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._guid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ProfileChangeRequest, rhs: Iterm2_ProfileChangeRequest) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PromptMonitorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromptMonitorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.modes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modes.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.modes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PromptMonitorRequest, rhs: Iterm2_PromptMonitorRequest) -> Bool {
    if lhs.modes != rhs.modes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_NotificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "subscribe"),
    3: .standard(proto: "notification_type"),
    4: .standard(proto: "rpc_registration_request"),
    5: .standard(proto: "keystroke_monitor_request"),
    6: .standard(proto: "variable_monitor_request"),
    7: .standard(proto: "profile_change_request"),
    8: .standard(proto: "keystroke_filter_request"),
    9: .standard(proto: "prompt_monitor_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._subscribe) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._notificationType) }()
      case 4: try {
        var v: Iterm2_RPCRegistrationRequest?
        var hadOneofValue = false
        if let current = self.arguments {
          hadOneofValue = true
          if case .rpcRegistrationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.arguments = .rpcRegistrationRequest(v)
        }
      }()
      case 5: try {
        var v: Iterm2_KeystrokeMonitorRequest?
        var hadOneofValue = false
        if let current = self.arguments {
          hadOneofValue = true
          if case .keystrokeMonitorRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.arguments = .keystrokeMonitorRequest(v)
        }
      }()
      case 6: try {
        var v: Iterm2_VariableMonitorRequest?
        var hadOneofValue = false
        if let current = self.arguments {
          hadOneofValue = true
          if case .variableMonitorRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.arguments = .variableMonitorRequest(v)
        }
      }()
      case 7: try {
        var v: Iterm2_ProfileChangeRequest?
        var hadOneofValue = false
        if let current = self.arguments {
          hadOneofValue = true
          if case .profileChangeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.arguments = .profileChangeRequest(v)
        }
      }()
      case 8: try {
        var v: Iterm2_KeystrokeFilterRequest?
        var hadOneofValue = false
        if let current = self.arguments {
          hadOneofValue = true
          if case .keystrokeFilterRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.arguments = .keystrokeFilterRequest(v)
        }
      }()
      case 9: try {
        var v: Iterm2_PromptMonitorRequest?
        var hadOneofValue = false
        if let current = self.arguments {
          hadOneofValue = true
          if case .promptMonitorRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.arguments = .promptMonitorRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._subscribe {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._notificationType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.arguments {
    case .rpcRegistrationRequest?: try {
      guard case .rpcRegistrationRequest(let v)? = self.arguments else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .keystrokeMonitorRequest?: try {
      guard case .keystrokeMonitorRequest(let v)? = self.arguments else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .variableMonitorRequest?: try {
      guard case .variableMonitorRequest(let v)? = self.arguments else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .profileChangeRequest?: try {
      guard case .profileChangeRequest(let v)? = self.arguments else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .keystrokeFilterRequest?: try {
      guard case .keystrokeFilterRequest(let v)? = self.arguments else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .promptMonitorRequest?: try {
      guard case .promptMonitorRequest(let v)? = self.arguments else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_NotificationRequest, rhs: Iterm2_NotificationRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs._subscribe != rhs._subscribe {return false}
    if lhs._notificationType != rhs._notificationType {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_NotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_NotificationResponse, rhs: Iterm2_NotificationResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_NotificationResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "REQUEST_MALFORMED"),
    3: .same(proto: "NOT_SUBSCRIBED"),
    4: .same(proto: "ALREADY_SUBSCRIBED"),
    5: .same(proto: "DUPLICATE_SERVER_ORIGINATED_RPC"),
    6: .same(proto: "INVALID_IDENTIFIER"),
  ]
}

extension Iterm2_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Notification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "keystroke_notification"),
    2: .standard(proto: "screen_update_notification"),
    3: .standard(proto: "prompt_notification"),
    4: .standard(proto: "location_change_notification"),
    5: .standard(proto: "custom_escape_sequence_notification"),
    6: .standard(proto: "new_session_notification"),
    7: .standard(proto: "terminate_session_notification"),
    8: .standard(proto: "layout_changed_notification"),
    9: .standard(proto: "focus_changed_notification"),
    10: .standard(proto: "server_originated_rpc_notification"),
    11: .standard(proto: "broadcast_domains_changed"),
    12: .standard(proto: "variable_changed_notification"),
    13: .standard(proto: "profile_changed_notification"),
  ]

  fileprivate class _StorageClass {
    var _keystrokeNotification: Iterm2_KeystrokeNotification? = nil
    var _screenUpdateNotification: Iterm2_ScreenUpdateNotification? = nil
    var _promptNotification: Iterm2_PromptNotification? = nil
    var _locationChangeNotification: Iterm2_LocationChangeNotification? = nil
    var _customEscapeSequenceNotification: Iterm2_CustomEscapeSequenceNotification? = nil
    var _newSessionNotification: Iterm2_NewSessionNotification? = nil
    var _terminateSessionNotification: Iterm2_TerminateSessionNotification? = nil
    var _layoutChangedNotification: Iterm2_LayoutChangedNotification? = nil
    var _focusChangedNotification: Iterm2_FocusChangedNotification? = nil
    var _serverOriginatedRpcNotification: Iterm2_ServerOriginatedRPCNotification? = nil
    var _broadcastDomainsChanged: Iterm2_BroadcastDomainsChangedNotification? = nil
    var _variableChangedNotification: Iterm2_VariableChangedNotification? = nil
    var _profileChangedNotification: Iterm2_ProfileChangedNotification? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keystrokeNotification = source._keystrokeNotification
      _screenUpdateNotification = source._screenUpdateNotification
      _promptNotification = source._promptNotification
      _locationChangeNotification = source._locationChangeNotification
      _customEscapeSequenceNotification = source._customEscapeSequenceNotification
      _newSessionNotification = source._newSessionNotification
      _terminateSessionNotification = source._terminateSessionNotification
      _layoutChangedNotification = source._layoutChangedNotification
      _focusChangedNotification = source._focusChangedNotification
      _serverOriginatedRpcNotification = source._serverOriginatedRpcNotification
      _broadcastDomainsChanged = source._broadcastDomainsChanged
      _variableChangedNotification = source._variableChangedNotification
      _profileChangedNotification = source._profileChangedNotification
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._keystrokeNotification) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._screenUpdateNotification) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._promptNotification) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._locationChangeNotification) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._customEscapeSequenceNotification) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._newSessionNotification) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._terminateSessionNotification) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._layoutChangedNotification) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._focusChangedNotification) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._serverOriginatedRpcNotification) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._broadcastDomainsChanged) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._variableChangedNotification) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._profileChangedNotification) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._keystrokeNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._screenUpdateNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._promptNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._locationChangeNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._customEscapeSequenceNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._newSessionNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._terminateSessionNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._layoutChangedNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._focusChangedNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._serverOriginatedRpcNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._broadcastDomainsChanged {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._variableChangedNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._profileChangedNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_Notification, rhs: Iterm2_Notification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keystrokeNotification != rhs_storage._keystrokeNotification {return false}
        if _storage._screenUpdateNotification != rhs_storage._screenUpdateNotification {return false}
        if _storage._promptNotification != rhs_storage._promptNotification {return false}
        if _storage._locationChangeNotification != rhs_storage._locationChangeNotification {return false}
        if _storage._customEscapeSequenceNotification != rhs_storage._customEscapeSequenceNotification {return false}
        if _storage._newSessionNotification != rhs_storage._newSessionNotification {return false}
        if _storage._terminateSessionNotification != rhs_storage._terminateSessionNotification {return false}
        if _storage._layoutChangedNotification != rhs_storage._layoutChangedNotification {return false}
        if _storage._focusChangedNotification != rhs_storage._focusChangedNotification {return false}
        if _storage._serverOriginatedRpcNotification != rhs_storage._serverOriginatedRpcNotification {return false}
        if _storage._broadcastDomainsChanged != rhs_storage._broadcastDomainsChanged {return false}
        if _storage._variableChangedNotification != rhs_storage._variableChangedNotification {return false}
        if _storage._profileChangedNotification != rhs_storage._profileChangedNotification {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ProfileChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileChangedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._guid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._guid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ProfileChangedNotification, rhs: Iterm2_ProfileChangedNotification) -> Bool {
    if lhs._guid != rhs._guid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_VariableChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VariableChangedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "identifier"),
    3: .same(proto: "name"),
    4: .standard(proto: "json_new_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._scope) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._jsonNewValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scope {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._jsonNewValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_VariableChangedNotification, rhs: Iterm2_VariableChangedNotification) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs._identifier != rhs._identifier {return false}
    if lhs._name != rhs._name {return false}
    if lhs._jsonNewValue != rhs._jsonNewValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_BroadcastDomainsChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BroadcastDomainsChangedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "broadcast_domains"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.broadcastDomains) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.broadcastDomains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.broadcastDomains, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_BroadcastDomainsChangedNotification, rhs: Iterm2_BroadcastDomainsChangedNotification) -> Bool {
    if lhs.broadcastDomains != rhs.broadcastDomains {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ServerOriginatedRPC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerOriginatedRPC"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "name"),
    3: .same(proto: "arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ServerOriginatedRPC, rhs: Iterm2_ServerOriginatedRPC) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ServerOriginatedRPC.RPCArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ServerOriginatedRPC.protoMessageName + ".RPCArgument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ServerOriginatedRPC.RPCArgument, rhs: Iterm2_ServerOriginatedRPC.RPCArgument) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ServerOriginatedRPCNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerOriginatedRPCNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "rpc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rpc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._requestID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._rpc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ServerOriginatedRPCNotification, rhs: Iterm2_ServerOriginatedRPCNotification) -> Bool {
    if lhs._requestID != rhs._requestID {return false}
    if lhs._rpc != rhs._rpc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_KeystrokeNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeystrokeNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "characters"),
    2: .same(proto: "charactersIgnoringModifiers"),
    3: .same(proto: "modifiers"),
    4: .same(proto: "keyCode"),
    5: .same(proto: "session"),
    6: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._characters) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._charactersIgnoringModifiers) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.modifiers) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._keyCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._characters {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._charactersIgnoringModifiers {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.modifiers.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.modifiers, fieldNumber: 3)
    }
    if let v = self._keyCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_KeystrokeNotification, rhs: Iterm2_KeystrokeNotification) -> Bool {
    if lhs._characters != rhs._characters {return false}
    if lhs._charactersIgnoringModifiers != rhs._charactersIgnoringModifiers {return false}
    if lhs.modifiers != rhs.modifiers {return false}
    if lhs._keyCode != rhs._keyCode {return false}
    if lhs._session != rhs._session {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_KeystrokeNotification.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_DOWN"),
    1: .same(proto: "KEY_UP"),
    2: .same(proto: "FLAGS_CHANGED"),
  ]
}

extension Iterm2_ScreenUpdateNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScreenUpdateNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ScreenUpdateNotification, rhs: Iterm2_ScreenUpdateNotification) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PromptNotificationPrompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromptNotificationPrompt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "placeholder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._placeholder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._placeholder {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PromptNotificationPrompt, rhs: Iterm2_PromptNotificationPrompt) -> Bool {
    if lhs._placeholder != rhs._placeholder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PromptNotificationCommandStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromptNotificationCommandStart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._command) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._command {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PromptNotificationCommandStart, rhs: Iterm2_PromptNotificationCommandStart) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PromptNotificationCommandEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromptNotificationCommandEnd"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PromptNotificationCommandEnd, rhs: Iterm2_PromptNotificationCommandEnd) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_PromptNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PromptNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "prompt"),
    3: .standard(proto: "command_start"),
    4: .standard(proto: "command_end"),
    5: .standard(proto: "unique_prompt_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try {
        var v: Iterm2_PromptNotificationPrompt?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .prompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .prompt(v)
        }
      }()
      case 3: try {
        var v: Iterm2_PromptNotificationCommandStart?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .commandStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .commandStart(v)
        }
      }()
      case 4: try {
        var v: Iterm2_PromptNotificationCommandEnd?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .commandEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .commandEnd(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._uniquePromptID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.event {
    case .prompt?: try {
      guard case .prompt(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .commandStart?: try {
      guard case .commandStart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .commandEnd?: try {
      guard case .commandEnd(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if let v = self._uniquePromptID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_PromptNotification, rhs: Iterm2_PromptNotification) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.event != rhs.event {return false}
    if lhs._uniquePromptID != rhs._uniquePromptID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_LocationChangeNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocationChangeNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "host_name"),
    2: .standard(proto: "user_name"),
    3: .same(proto: "directory"),
    4: .same(proto: "session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._hostName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._userName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._directory) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._hostName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._userName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._directory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_LocationChangeNotification, rhs: Iterm2_LocationChangeNotification) -> Bool {
    if lhs._hostName != rhs._hostName {return false}
    if lhs._userName != rhs._userName {return false}
    if lhs._directory != rhs._directory {return false}
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CustomEscapeSequenceNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomEscapeSequenceNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "sender_identity"),
    3: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._senderIdentity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._senderIdentity {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._payload {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CustomEscapeSequenceNotification, rhs: Iterm2_CustomEscapeSequenceNotification) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs._senderIdentity != rhs._senderIdentity {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_NewSessionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewSessionNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_NewSessionNotification, rhs: Iterm2_NewSessionNotification) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_FocusChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FocusChangedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "application_active"),
    2: .same(proto: "window"),
    3: .standard(proto: "selected_tab"),
    4: .same(proto: "session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .applicationActive(v)
        }
      }()
      case 2: try {
        var v: Iterm2_FocusChangedNotification.Window?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .window(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .window(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .selectedTab(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.event != nil {try decoder.handleConflictingOneOf()}
          self.event = .session(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.event {
    case .applicationActive?: try {
      guard case .applicationActive(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .window?: try {
      guard case .window(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .selectedTab?: try {
      guard case .selectedTab(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .session?: try {
      guard case .session(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_FocusChangedNotification, rhs: Iterm2_FocusChangedNotification) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_FocusChangedNotification.Window: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_FocusChangedNotification.protoMessageName + ".Window"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_status"),
    2: .standard(proto: "window_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._windowStatus) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._windowStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_FocusChangedNotification.Window, rhs: Iterm2_FocusChangedNotification.Window) -> Bool {
    if lhs._windowStatus != rhs._windowStatus {return false}
    if lhs._windowID != rhs._windowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_FocusChangedNotification.Window.WindowStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TERMINAL_WINDOW_BECAME_KEY"),
    1: .same(proto: "TERMINAL_WINDOW_IS_CURRENT"),
    2: .same(proto: "TERMINAL_WINDOW_RESIGNED_KEY"),
  ]
}

extension Iterm2_TerminateSessionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TerminateSessionNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TerminateSessionNotification, rhs: Iterm2_TerminateSessionNotification) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_LayoutChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LayoutChangedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_sessions_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._listSessionsResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._listSessionsResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_LayoutChangedNotification, rhs: Iterm2_LayoutChangedNotification) -> Bool {
    if lhs._listSessionsResponse != rhs._listSessionsResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetBufferRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBufferRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "line_range"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lineRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._lineRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetBufferRequest, rhs: Iterm2_GetBufferRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs._lineRange != rhs._lineRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetBufferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBufferResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "range"),
    3: .same(proto: "contents"),
    4: .same(proto: "cursor"),
    5: .standard(proto: "num_lines_above_screen"),
    6: .standard(proto: "windowed_coord_range"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.contents) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._numLinesAboveScreen) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._windowedCoordRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.contents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contents, fieldNumber: 3)
    }
    if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._numLinesAboveScreen {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._windowedCoordRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetBufferResponse, rhs: Iterm2_GetBufferResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._range != rhs._range {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs._numLinesAboveScreen != rhs._numLinesAboveScreen {return false}
    if lhs._windowedCoordRange != rhs._windowedCoordRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetBufferResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "INVALID_LINE_RANGE"),
    3: .same(proto: "REQUEST_MALFORMED"),
  ]
}

extension Iterm2_GetPromptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPromptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "unique_prompt_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._uniquePromptID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._uniquePromptID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetPromptRequest, rhs: Iterm2_GetPromptRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs._uniquePromptID != rhs._uniquePromptID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetPromptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPromptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "prompt_range"),
    3: .standard(proto: "command_range"),
    4: .standard(proto: "output_range"),
    5: .standard(proto: "working_directory"),
    6: .same(proto: "command"),
    7: .standard(proto: "prompt_state"),
    9: .standard(proto: "exit_status"),
    10: .standard(proto: "unique_prompt_id"),
  ]

  fileprivate class _StorageClass {
    var _status: Iterm2_GetPromptResponse.Status? = nil
    var _promptRange: Iterm2_CoordRange? = nil
    var _commandRange: Iterm2_CoordRange? = nil
    var _outputRange: Iterm2_CoordRange? = nil
    var _workingDirectory: String? = nil
    var _command: String? = nil
    var _promptState: Iterm2_GetPromptResponse.State? = nil
    var _exitStatus: UInt32? = nil
    var _uniquePromptID: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _promptRange = source._promptRange
      _commandRange = source._commandRange
      _outputRange = source._outputRange
      _workingDirectory = source._workingDirectory
      _command = source._command
      _promptState = source._promptState
      _exitStatus = source._exitStatus
      _uniquePromptID = source._uniquePromptID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._promptRange) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._commandRange) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._outputRange) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._workingDirectory) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._command) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._promptState) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._exitStatus) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._uniquePromptID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._status {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._promptRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._commandRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._outputRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._workingDirectory {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._command {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._promptState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      }
      if let v = _storage._exitStatus {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._uniquePromptID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetPromptResponse, rhs: Iterm2_GetPromptResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._promptRange != rhs_storage._promptRange {return false}
        if _storage._commandRange != rhs_storage._commandRange {return false}
        if _storage._outputRange != rhs_storage._outputRange {return false}
        if _storage._workingDirectory != rhs_storage._workingDirectory {return false}
        if _storage._command != rhs_storage._command {return false}
        if _storage._promptState != rhs_storage._promptState {return false}
        if _storage._exitStatus != rhs_storage._exitStatus {return false}
        if _storage._uniquePromptID != rhs_storage._uniquePromptID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetPromptResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "REQUEST_MALFORMED"),
    3: .same(proto: "PROMPT_UNAVAILABLE"),
  ]
}

extension Iterm2_GetPromptResponse.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EDITING"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "FINISHED"),
  ]
}

extension Iterm2_ListPromptsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPromptsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "first_unique_id"),
    3: .standard(proto: "last_unique_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._firstUniqueID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._lastUniqueID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._firstUniqueID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._lastUniqueID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListPromptsRequest, rhs: Iterm2_ListPromptsRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs._firstUniqueID != rhs._firstUniqueID {return false}
    if lhs._lastUniqueID != rhs._lastUniqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListPromptsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPromptsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "unique_prompt_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.uniquePromptID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.uniquePromptID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uniquePromptID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListPromptsResponse, rhs: Iterm2_ListPromptsResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.uniquePromptID != rhs.uniquePromptID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListPromptsResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
  ]
}

extension Iterm2_GetProfilePropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetProfilePropertyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetProfilePropertyRequest, rhs: Iterm2_GetProfilePropertyRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ProfileProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileProperty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ProfileProperty, rhs: Iterm2_ProfileProperty) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetProfilePropertyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetProfilePropertyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    3: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_GetProfilePropertyResponse, rhs: Iterm2_GetProfilePropertyResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_GetProfilePropertyResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "REQUEST_MALFORMED"),
    3: .same(proto: "ERROR"),
  ]
}

extension Iterm2_SetProfilePropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetProfilePropertyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "guid_list"),
    3: .same(proto: "key"),
    4: .standard(proto: "json_value"),
    5: .same(proto: "assignments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .session(v)
        }
      }()
      case 2: try {
        var v: Iterm2_SetProfilePropertyRequest.GuidList?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .guidList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .guidList(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.assignments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.target {
    case .session?: try {
      guard case .session(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .guidList?: try {
      guard case .guidList(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.assignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignments, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetProfilePropertyRequest, rhs: Iterm2_SetProfilePropertyRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs._key != rhs._key {return false}
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.assignments != rhs.assignments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetProfilePropertyRequest.GuidList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_SetProfilePropertyRequest.protoMessageName + ".GuidList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "guids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.guids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.guids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.guids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetProfilePropertyRequest.GuidList, rhs: Iterm2_SetProfilePropertyRequest.GuidList) -> Bool {
    if lhs.guids != rhs.guids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetProfilePropertyRequest.Assignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_SetProfilePropertyRequest.protoMessageName + ".Assignment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "json_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._jsonValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._jsonValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetProfilePropertyRequest.Assignment, rhs: Iterm2_SetProfilePropertyRequest.Assignment) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._jsonValue != rhs._jsonValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetProfilePropertyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetProfilePropertyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SetProfilePropertyResponse, rhs: Iterm2_SetProfilePropertyResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SetProfilePropertyResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "REQUEST_MALFORMED"),
    3: .same(proto: "BAD_GUID"),
  ]
}

extension Iterm2_TransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "begin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._begin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._begin {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TransactionRequest, rhs: Iterm2_TransactionRequest) -> Bool {
    if lhs._begin != rhs._begin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_TransactionResponse, rhs: Iterm2_TransactionResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_TransactionResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "NO_TRANSACTION"),
    2: .same(proto: "ALREADY_IN_TRANSACTION"),
  ]
}

extension Iterm2_LineRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LineRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "screen_contents_only"),
    2: .standard(proto: "trailing_lines"),
    3: .standard(proto: "windowed_coord_range"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._screenContentsOnly) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._trailingLines) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._windowedCoordRange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._screenContentsOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._trailingLines {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._windowedCoordRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_LineRange, rhs: Iterm2_LineRange) -> Bool {
    if lhs._screenContentsOnly != rhs._screenContentsOnly {return false}
    if lhs._trailingLines != rhs._trailingLines {return false}
    if lhs._windowedCoordRange != rhs._windowedCoordRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Range"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._location) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._location {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._length {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_Range, rhs: Iterm2_Range) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs._length != rhs._length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CoordRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoordRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CoordRange, rhs: Iterm2_CoordRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_Coord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Coord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._x) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._x {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._y {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_Coord, rhs: Iterm2_Coord) -> Bool {
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_LineContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LineContents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "code_points_per_cell"),
    3: .same(proto: "continuation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.codePointsPerCell) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._continuation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.codePointsPerCell.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.codePointsPerCell, fieldNumber: 2)
    }
    if let v = self._continuation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_LineContents, rhs: Iterm2_LineContents) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs.codePointsPerCell != rhs.codePointsPerCell {return false}
    if lhs._continuation != rhs._continuation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_LineContents.Continuation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CONTINUATION_HARD_EOL"),
    2: .same(proto: "CONTINUATION_SOFT_EOL"),
  ]
}

extension Iterm2_CodePointsPerCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CodePointsPerCell"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_code_points"),
    2: .same(proto: "repeats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._numCodePoints) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._repeats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._numCodePoints {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._repeats {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CodePointsPerCell, rhs: Iterm2_CodePointsPerCell) -> Bool {
    if lhs._numCodePoints != rhs._numCodePoints {return false}
    if lhs._repeats != rhs._repeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSessionsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListSessionsRequest, rhs: Iterm2_ListSessionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SendTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendTextRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "text"),
    3: .standard(proto: "suppress_broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._suppressBroadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._suppressBroadcast {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SendTextRequest, rhs: Iterm2_SendTextRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs._text != rhs._text {return false}
    if lhs._suppressBroadcast != rhs._suppressBroadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SendTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendTextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SendTextResponse, rhs: Iterm2_SendTextResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SendTextResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
  ]
}

extension Iterm2_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Size"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._width {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._height {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_Size, rhs: Iterm2_Size) -> Bool {
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._x) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._x {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._y {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_Point, rhs: Iterm2_Point) -> Bool {
    if lhs._x != rhs._x {return false}
    if lhs._y != rhs._y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_Frame, rhs: Iterm2_Frame) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SessionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unique_identifier"),
    2: .same(proto: "frame"),
    3: .standard(proto: "grid_size"),
    4: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uniqueIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._frame) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gridSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uniqueIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._frame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._gridSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SessionSummary, rhs: Iterm2_SessionSummary) -> Bool {
    if lhs._uniqueIdentifier != rhs._uniqueIdentifier {return false}
    if lhs._frame != rhs._frame {return false}
    if lhs._gridSize != rhs._gridSize {return false}
    if lhs._title != rhs._title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SplitTreeNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SplitTreeNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vertical"),
    2: .same(proto: "links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._vertical) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vertical {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SplitTreeNode, rhs: Iterm2_SplitTreeNode) -> Bool {
    if lhs._vertical != rhs._vertical {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SplitTreeNode.SplitTreeLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_SplitTreeNode.protoMessageName + ".SplitTreeLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Iterm2_SessionSummary?
        var hadOneofValue = false
        if let current = self.child {
          hadOneofValue = true
          if case .session(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.child = .session(v)
        }
      }()
      case 2: try {
        var v: Iterm2_SplitTreeNode?
        var hadOneofValue = false
        if let current = self.child {
          hadOneofValue = true
          if case .node(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.child = .node(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.child {
    case .session?: try {
      guard case .session(let v)? = self.child else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .node?: try {
      guard case .node(let v)? = self.child else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SplitTreeNode.SplitTreeLink, rhs: Iterm2_SplitTreeNode.SplitTreeLink) -> Bool {
    if lhs.child != rhs.child {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSessionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "windows"),
    2: .standard(proto: "buried_sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.windows) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.buriedSessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.windows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.windows, fieldNumber: 1)
    }
    if !self.buriedSessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buriedSessions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListSessionsResponse, rhs: Iterm2_ListSessionsResponse) -> Bool {
    if lhs.windows != rhs.windows {return false}
    if lhs.buriedSessions != rhs.buriedSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListSessionsResponse.Window: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ListSessionsResponse.protoMessageName + ".Window"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tabs"),
    2: .standard(proto: "window_id"),
    3: .same(proto: "frame"),
    4: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tabs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._frame) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._number) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tabs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tabs, fieldNumber: 1)
    }
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._frame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._number {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListSessionsResponse.Window, rhs: Iterm2_ListSessionsResponse.Window) -> Bool {
    if lhs.tabs != rhs.tabs {return false}
    if lhs._windowID != rhs._windowID {return false}
    if lhs._frame != rhs._frame {return false}
    if lhs._number != rhs._number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_ListSessionsResponse.Tab: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Iterm2_ListSessionsResponse.protoMessageName + ".Tab"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "root"),
    2: .standard(proto: "tab_id"),
    4: .standard(proto: "tmux_window_id"),
    5: .standard(proto: "tmux_connection_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._tabID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._root) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._tmuxWindowID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._tmuxConnectionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tabID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._root {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._tmuxWindowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._tmuxConnectionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_ListSessionsResponse.Tab, rhs: Iterm2_ListSessionsResponse.Tab) -> Bool {
    if lhs._root != rhs._root {return false}
    if lhs._tabID != rhs._tabID {return false}
    if lhs._tmuxWindowID != rhs._tmuxWindowID {return false}
    if lhs._tmuxConnectionID != rhs._tmuxConnectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CreateTabRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateTabRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "profile_name"),
    2: .standard(proto: "window_id"),
    3: .standard(proto: "tab_index"),
    4: .same(proto: "command"),
    5: .standard(proto: "custom_profile_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._profileName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._tabIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._command) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.customProfileProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._profileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._tabIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._command {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.customProfileProperties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customProfileProperties, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CreateTabRequest, rhs: Iterm2_CreateTabRequest) -> Bool {
    if lhs._profileName != rhs._profileName {return false}
    if lhs._windowID != rhs._windowID {return false}
    if lhs._tabIndex != rhs._tabIndex {return false}
    if lhs._command != rhs._command {return false}
    if lhs.customProfileProperties != rhs.customProfileProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CreateTabResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateTabResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "window_id"),
    3: .standard(proto: "tab_id"),
    4: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._windowID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._tabID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._windowID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._tabID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_CreateTabResponse, rhs: Iterm2_CreateTabResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs._windowID != rhs._windowID {return false}
    if lhs._tabID != rhs._tabID {return false}
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_CreateTabResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "INVALID_PROFILE_NAME"),
    2: .same(proto: "INVALID_WINDOW_ID"),
    3: .same(proto: "INVALID_TAB_INDEX"),
    4: .same(proto: "MISSING_SUBSTITUTION"),
  ]
}

extension Iterm2_SplitPaneRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SplitPaneRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "split_direction"),
    3: .same(proto: "before"),
    4: .standard(proto: "profile_name"),
    5: .standard(proto: "custom_profile_properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._splitDirection) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._before) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._profileName) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.customProfileProperties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._splitDirection {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._before {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._profileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.customProfileProperties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customProfileProperties, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SplitPaneRequest, rhs: Iterm2_SplitPaneRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs._splitDirection != rhs._splitDirection {return false}
    if lhs._before != rhs._before {return false}
    if lhs._profileName != rhs._profileName {return false}
    if lhs.customProfileProperties != rhs.customProfileProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SplitPaneRequest.SplitDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERTICAL"),
    1: .same(proto: "HORIZONTAL"),
  ]
}

extension Iterm2_SplitPaneResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SplitPaneResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "session_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sessionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Iterm2_SplitPaneResponse, rhs: Iterm2_SplitPaneResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Iterm2_SplitPaneResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "SESSION_NOT_FOUND"),
    2: .same(proto: "INVALID_PROFILE_NAME"),
    3: .same(proto: "CANNOT_SPLIT"),
    4: .same(proto: "MALFORMED_CUSTOM_PROFILE_PROPERTY"),
  ]
}
