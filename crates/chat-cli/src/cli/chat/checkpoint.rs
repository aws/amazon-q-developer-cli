use std::collections::HashMap;
use std::path::{
    Path,
    PathBuf,
};
use std::cmp::Eq;
use std::str::FromStr;

use crossterm::style::Stylize;
use eyre::{
    Result,
    bail,
    eyre,
    Report
};
use serde::{
    Deserialize,
    Serialize,
};
use sha2::{
    Digest,
    Sha256,
};
use walkdir::WalkDir;

use crate::cli::ConversationState;
use crate::os::Os;

// ######## HARDCODED VALUES ########
const CHECKPOINT_DIR: &str = "/Users/kiranbug/.aws/amazonq/checkpoints/first/";
const CHECKPOINT_FILE: &str = "/Users/kiranbug/.aws/amazonq/checkpoints/test_file.json";
// ######## ---------------- ########

// FIX: Move complicated logic (None -> Some) into checkpoint function?
//      - The benefit is that calling new_checkpoint() will be cleaner
//      - The downside is that the function will be messier and may miss edge cases; maybe better to
//        handle on a case-by-case basis?
// FIX: Remove hardcoded values
// FIX:

#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CheckpointManager {
    pub checkpoints: Vec<Checkpoint>,
    pub tag_to_index: HashMap<Tag, usize>,
    pub num_turn_checkpoints: usize,

    store_dir: PathBuf,
    first_occurrence_cache: HashMap<PathBuf, usize>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct Checkpoint {
    pub state: HashMap<PathBuf, Option<ContentHash>>,
    pub summary: String,
    pub history_index: usize,
    pub tagged: bool,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct ContentHash(String);

impl std::fmt::Display for ContentHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum Tag {
    Single(usize),
    Nested(usize, usize),
}

// Generated by Q
impl FromStr for Tag {
    type Err = Report;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some((outer, inner)) = s.split_once('.') {
            let outer_tag = match outer.parse::<usize>() {
                Ok(o) => o,
                Err(_) => bail!("Invalid outer tag: {outer}")
            };
            let inner_tag = match inner.parse::<usize>() {
                Ok(i) => i,
                Err(_) => bail!("Invalid inner tag: {inner}")
            };
            
            // Convert from 1-based to 0-based indexing
            Ok(Self::Nested(outer_tag - 1, inner_tag - 1))
        } else {
            let tag = match s.parse::<usize>() {
                Ok(i) => i,
                Err(_) => bail!("Invalid tag: {s}")
            };
            
            // Convert from 1-based to 0-based indexing
            Ok(Self::Single(tag - 1))
        }
    }
}

impl Tag {
    pub fn is_sub_tag_of_outer(tag: Tag, outer: Tag) -> bool {
        match (tag, outer) {
            (Tag::Nested(i, _), Tag::Single(t)) => t == i,
            (_, _) => false,
        }
    }
}

impl CheckpointManager {
    pub async fn init(os: &Os) -> Result<()> {
        let manager = Self {
            store_dir: Self::get_new_directory(),
            ..Default::default()
        };
        Self::save_manager(os, &manager).await?;
        Ok(())
    }

    pub async fn load_manager(os: &Os) -> Result<Self> {
        Ok(serde_json::from_str::<CheckpointManager>(
            &os.fs.read_to_string(CHECKPOINT_FILE).await?
        )?)
    }

    pub async fn save_manager(os: &Os, manager: &CheckpointManager) -> Result<()> {
        os.fs.write(CHECKPOINT_FILE, serde_json::to_string(manager)?).await?;
        Ok(())
    }

    pub async fn checkpoint_with_data<P, D>(&mut self, os: &Os, paths: P, datas: D) -> Result<()>
    where
        P: Into<Vec<PathBuf>>,
        D: Into<Vec<Option<Vec<u8>>>>,
    {
        let paths = paths.into();
        let datas = datas.into();
        // Copy the previous checkpoint's state
        let mut new_map = if let Some(checkpoint) = self.checkpoints.iter().last() {
            checkpoint.state.clone()
        } else {
            HashMap::new()
        };

        for (path, data) in paths.iter().zip(datas) {
            let hash = data.as_ref().map(hash_contents);

            // Create obj file
            if let Some((hash, data)) = hash.as_ref().zip(data.as_ref()) {
                self.create_obj_if_needed(os, &hash, data).await?;
            }

            new_map.insert(path.clone(), hash);

            // Log first occurrence
            self.first_occurrence_cache
                .entry(path.clone())
                .or_insert(self.checkpoints.len());
        }
        self.checkpoints.push(Checkpoint {
            state: new_map,
            summary: String::new(),
            history_index: 0,
            tagged: false,
        });

        Ok(())
    }

    pub async fn restore_checkpoint(
        &mut self,
        os: &Os,
        conversation: &mut ConversationState,
        tag: String,
    ) -> Result<()> {
        let index = match self.tag_to_index.get(&Tag::from_str(&tag)?) {
            Some(i) => i,
            None => bail!("No checkpoint with tag {tag}"),
        };
        self.restore(os, conversation, *index).await?;
        Ok(())
    }

    async fn restore(&mut self, os: &Os, conversation: &mut ConversationState, index: usize) -> Result<()> {
        let checkpoint = match self.checkpoints.get(index) {
            Some(c) => c,
            None => bail!(format!("No checkpoint with index: {index}")),
        };
        if !checkpoint.tagged {
            bail!("Attempting to restore an untagged checkpoint!");
        }
        // If a touched file isn't in this checkpoint's state, look forward in history
        // to see the first time the file shows up.
        // This is complicated but necessary given the current design.
        for path in self.first_occurrence_cache.keys() {
            let hash_option = match checkpoint.state.get(path) {
                Some(hash) => hash,
                None => {
                    let first_occurrence = self.first_occurrence_cache.get(path).unwrap();
                    self.checkpoints[*first_occurrence].state.get(path).unwrap()
                },
            };
            match hash_option {
                Some(hash) => self.restore_file(os, path, hash).await?,
                None if os.fs.exists(path) => os.fs.remove_file(path).await?,
                _ => (),
            };
        }

        for _ in checkpoint.history_index..conversation.get_history_len() {
            conversation
                .pop_from_history()
                .ok_or(eyre!("Tried to pop from empty history"))?;
        }
        Ok(())
    }

    async fn create_obj_if_needed(&self, os: &Os, hash: &ContentHash, data: impl AsRef<[u8]>) -> Result<()> {
        let obj_path = self.hash_to_obj_path(hash);
        if os.fs.exists(&obj_path) {
            return Ok(());
        }
        os.fs.create_new(&obj_path).await?;
        os.fs.write(obj_path, data).await?;
        Ok(())
    }

    fn hash_to_obj_path(&self, hash: &ContentHash) -> PathBuf {
        self.store_dir.join(hash.to_string())
    }

    fn get_new_directory() -> PathBuf {
        PathBuf::from(CHECKPOINT_DIR)
    }

    async fn restore_file(&self, os: &Os, path: impl AsRef<Path>, hash: &ContentHash) -> Result<()> {
        let path = path.as_ref();
        if !os.fs.exists(&path) {
            os.fs.create_new(&path).await?;
        }
        os.fs.copy(self.hash_to_obj_path(hash), path).await?;
        Ok(())
    }

    pub fn tag_latest_checkpoint(&mut self, tag: String, summary: Option<String>, history_index: usize) {
        let description = if let Some(s) = summary {
            s
        } else {
            "No description provided".dark_grey().to_string()
        };
        let num_checkpoints = self.checkpoints.len();

        // This is only called internally, so unwrapping Tag Result is fine
        self.tag_to_index.insert(Tag::from_str(&tag).unwrap(), num_checkpoints - 1);

        let checkpoint = &mut self.checkpoints[num_checkpoints - 1];
        checkpoint.summary = description;
        checkpoint.history_index = history_index;
        checkpoint.tagged = true;
    }
}

fn hash_contents(data: impl AsRef<[u8]>) -> ContentHash {
    let hash = Sha256::digest(data);
    ContentHash(hash.iter().map(|b| format!("{:02x}", b)).collect())
}

pub async fn collect_paths_and_data(os: &Os, dir: impl AsRef<Path>) -> Result<(Vec<PathBuf>, Vec<Vec<u8>>)> {
    let mut paths = Vec::new();
    let mut datas = Vec::new();
    for entry in WalkDir::new(&dir) {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() {
            paths.push(path.strip_prefix(&dir)?.to_path_buf());
            datas.push(os.fs.read(path).await?);
        }
    }
    Ok((paths, datas))
}


