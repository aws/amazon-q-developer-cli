use std::cmp::Eq;
use std::collections::{
    HashMap,
    HashSet,
};
use std::fmt::Display;
use std::path::{
    Path,
    PathBuf,
};
use std::str::FromStr;

use async_trait::async_trait;
use chrono::{
    DateTime,
    Local,
};
use crossterm::style::Stylize;
use eyre::{
    Report,
    Result,
    bail,
    eyre,
};
use serde::{
    Deserialize,
    Serialize,
};
use sha2::{
    Digest,
    Sha256,
};
use walkdir::WalkDir;

use crate::cli::ConversationState;
use crate::os::Os;

// ######## HARDCODED VALUES ########
pub const CHECKPOINT_DIR: &str = "/Users/kiranbug/.aws/amazonq/checkpoints/first/";
pub const CHECKPOINT_FILE: &str = "/Users/kiranbug/.aws/amazonq/checkpoints/test_file.json";
// ######## ---------------- ########

// FIX: Move complicated logic (None -> Some) into checkpoint function?
//      - The benefit is that calling new_checkpoint() will be cleaner
//      - The downside is that the function will be messier and may miss edge cases; maybe better to
//        handle on a case-by-case basis?
// FIX: Remove hardcoded values
// FIX:

#[async_trait]
pub trait Trackable {
    async fn setup_checkpointing(&self, os: &Os, manager: &mut CheckpointManager) -> Result<()>;
    async fn finish_checkpointing(&self, os: &Os, manager: &mut CheckpointManager) -> Result<()>;
    fn get_summary(&self, os: &Os) -> Option<String>;
}

#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CheckpointManager {
    pub checkpoints: Vec<Checkpoint>,
    pub tag_to_index: HashMap<Tag, usize>,
    pub num_turn_checkpoints: usize,

    store_dir: PathBuf,
    first_occurrence_cache: HashMap<PathBuf, usize>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct Checkpoint {
    pub state: HashMap<PathBuf, Option<ContentHash>>,
    pub directories: HashSet<PathBuf>,
    pub summary: String,
    pub tool_name: String,
    pub history_index: usize,
    pub tag: Option<Tag>,
    pub timestamp: DateTime<Local>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct ContentHash(String);

impl Display for ContentHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(into = "String", try_from = "String")]
pub enum Tag {
    TurnLevel(usize),
    ToolLevel(usize, usize),
}

impl From<Tag> for String {
    fn from(tag: Tag) -> Self {
        tag.to_string()
    }
}

impl TryFrom<String> for Tag {
    type Error = Report;

    fn try_from(s: String) -> Result<Self, Self::Error> {
        Tag::from_str(&s)
    }
}

impl Display for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Tag::ToolLevel(i, j) => write!(f, "{i}.{j}"),
            Tag::TurnLevel(i) => write!(f, "{i}"),
        }
    }
}

// Generated by Q
impl FromStr for Tag {
    type Err = Report;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some((outer, inner)) = s.split_once('.') {
            let outer_tag = match outer.parse::<usize>() {
                Ok(o) => o,
                Err(_) => bail!("Invalid outer tag: {outer}"),
            };
            let inner_tag = match inner.parse::<usize>() {
                Ok(i) => i,
                Err(_) => bail!("Invalid inner tag: {inner}"),
            };

            Ok(Self::ToolLevel(outer_tag, inner_tag))
        } else {
            let tag = match s.parse::<usize>() {
                Ok(i) => i,
                Err(_) => bail!("Invalid tag: {s}"),
            };

            Ok(Self::TurnLevel(tag))
        }
    }
}

impl Tag {
    pub fn tag_belongs_to_turn(tag: Tag, turn_tag: Tag) -> bool {
        match (tag, turn_tag) {
            (Tag::ToolLevel(i, _), Tag::TurnLevel(t)) => t == i,
            (_, _) => false,
        }
    }

    pub fn is_turn(&self) -> bool {
        match self {
            Tag::ToolLevel(..) => false,
            Tag::TurnLevel(_) => true,
        }
    }
}

impl CheckpointManager {
    pub async fn init(os: &Os) -> Result<()> {
        let manager = Self {
            store_dir: Self::get_new_directory(),
            num_turn_checkpoints: 1,
            ..Default::default()
        };
        Self::save_manager(os, &manager).await?;
        Ok(())
    }

    pub async fn load_manager(os: &Os) -> Result<Self> {
        Ok(serde_json::from_str::<CheckpointManager>(
            &os.fs.read_to_string(CHECKPOINT_FILE).await?,
        )?)
    }

    pub async fn save_manager(os: &Os, manager: &CheckpointManager) -> Result<()> {
        os.fs.write(CHECKPOINT_FILE, serde_json::to_string(manager)?).await?;
        Ok(())
    }

    pub async fn checkpoint_with_data<P, D>(&mut self, os: &Os, paths: P, datas: D) -> Result<()>
    where
        P: Into<Vec<PathBuf>>,
        D: Into<Vec<Option<Vec<u8>>>>,
    {
        let paths = paths.into();
        let datas = datas.into();
        let directories = HashSet::from_iter(collect_absolute_dir_paths(os.env.current_dir()?).await?.iter().cloned());

        // Copy the previous checkpoint's state
        let mut new_map = if let Some(checkpoint) = self.checkpoints.iter().last() {
            checkpoint.state.clone()
        } else {
            HashMap::new()
        };

        for (path, data) in paths.iter().zip(datas) {
            let hash = data.as_ref().map(hash_data);

            // Create obj file
            if let Some((hash, data)) = hash.as_ref().zip(data.as_ref()) {
                self.create_obj_if_needed(os, &hash, data).await?;
            }

            new_map.insert(path.clone(), hash);

            // Log first occurrence
            self.first_occurrence_cache
                .entry(path.clone())
                .or_insert(self.checkpoints.len());
        }
        self.checkpoints.push(Checkpoint {
            state: new_map,
            directories,
            summary: String::new(),
            tool_name: String::new(),
            history_index: 0,
            tag: None,
            timestamp: Local::now(),
        });

        Ok(())
    }

    pub async fn restore_checkpoint(
        &mut self,
        os: &Os,
        conversation: &mut ConversationState,
        tag: String,
    ) -> Result<()> {
        let index = match self.tag_to_index.get(&Tag::from_str(&tag)?) {
            Some(i) => i,
            None => bail!("No checkpoint with tag {tag}"),
        };
        self.restore(os, conversation, *index).await?;
        Ok(())
    }

    async fn restore(&mut self, os: &Os, conversation: &mut ConversationState, index: usize) -> Result<()> {
        let checkpoint = match self.checkpoints.get(index) {
            Some(c) => c,
            None => bail!(format!("No checkpoint with index: {index}")),
        };
        if checkpoint.tag.is_none() {
            bail!("Attempting to restore an untagged checkpoint!");
        }

        // Delete directories that shouldn't exist first
        let directories = collect_absolute_dir_paths(os.env.current_dir()?).await?;
        for dir in directories {
            if !checkpoint.directories.contains(&dir) && os.fs.exists(&dir) {
                os.fs.remove_dir_all(dir).await?;
            }
        }

        // If a touched file isn't in this checkpoint's state, look forward in history
        // to see the first time the file shows up.
        // This is complicated but necessary given the current design.
        for path in self.first_occurrence_cache.keys() {
            let hash_option = match checkpoint.state.get(path) {
                Some(hash) => hash,
                None => {
                    let first_occurrence = self.first_occurrence_cache.get(path).unwrap();
                    self.checkpoints[*first_occurrence].state.get(path).unwrap()
                },
            };
            match hash_option {
                Some(hash) => self.restore_file(os, path, hash).await?,
                None if os.fs.exists(path) => os.fs.remove_file(path).await?,
                _ => (),
            };
        }

        for _ in checkpoint.history_index..conversation.history().len() {
            conversation
                .pop_from_history()
                .ok_or(eyre!("Tried to pop from empty history"))?;
        }
        Ok(())
    }

    async fn create_obj_if_needed(&self, os: &Os, hash: &ContentHash, data: impl AsRef<[u8]>) -> Result<()> {
        let obj_path = self.hash_to_obj_path(hash);
        if os.fs.exists(&obj_path) {
            return Ok(());
        }
        os.fs.create_new(&obj_path).await?;
        os.fs.write(obj_path, data).await?;
        Ok(())
    }

    fn hash_to_obj_path(&self, hash: &ContentHash) -> PathBuf {
        self.store_dir.join(hash.to_string())
    }

    fn get_new_directory() -> PathBuf {
        PathBuf::from(CHECKPOINT_DIR)
    }

    async fn restore_file(&self, os: &Os, path: impl AsRef<Path>, hash: &ContentHash) -> Result<()> {
        let path = path.as_ref();

        // Create parent directories if needed
        if let Some(parent) = path.parent() {
            os.fs.create_dir_all(parent).await?;
        }
        if !os.fs.exists(&path) {
            os.fs.create_new(&path).await?;
        }
        os.fs.copy(self.hash_to_obj_path(hash), path).await?;
        Ok(())
    }

    pub fn tag_latest_checkpoint(
        &mut self,
        tag: String,
        summary: Option<String>,
        history_index: usize,
        tool_name: String,
    ) {
        let description = if let Some(s) = summary {
            s
        } else {
            "No description provided".dark_grey().to_string()
        };
        let num_checkpoints = self.checkpoints.len();

        self.tag_to_index
            .insert(Tag::from_str(&tag).unwrap(), num_checkpoints - 1);

        let checkpoint = &mut self.checkpoints[num_checkpoints - 1];
        checkpoint.summary = description;
        checkpoint.history_index = history_index;
        checkpoint.tag = Some(Tag::from_str(&tag).unwrap());
        checkpoint.tool_name = tool_name;
    }

    pub fn can_create_turn_checkpoint(&self) -> bool {
        if self.checkpoints.is_empty() {
            return false;
        }
        let last_checkpoint = self.checkpoints.iter().last().unwrap();
        if last_checkpoint.tag.is_none() || last_checkpoint.tag.as_ref().unwrap().is_turn() {
            return false;
        }
        true
    }

    pub fn turn_checkpoint(&mut self, summary: String) -> String {
        let mut new_checkpoint = self.checkpoints.iter().last().unwrap().clone();
        if let Tag::ToolLevel(t, _) = new_checkpoint.tag.clone().unwrap() {
            new_checkpoint.tag = Some(Tag::TurnLevel(t));
        }
        new_checkpoint.summary = summary;
        let return_tag = new_checkpoint.tag.clone().unwrap().to_string();

        self.checkpoints.push(new_checkpoint);
        self.tag_to_index
            .insert(Tag::from_str(&return_tag).unwrap(), self.checkpoints.len() - 1);
        self.num_turn_checkpoints += 1;

        return_tag
    }

    pub fn tag_initial_checkpoint_if_able(&mut self, history_index: usize) {
        if !self.checkpoints.is_empty() && self.checkpoints[0].tag.is_none() {
            let checkpoint = &mut self.checkpoints[0];
            let tag = Tag::from_str("0").unwrap();
            checkpoint.tag = Some(tag.clone());
            checkpoint.history_index = history_index;
            checkpoint.summary = "Initial checkpoint".to_string();

            self.tag_to_index.insert(tag, 0);
        }
    }
}

fn hash_data(data: impl AsRef<[u8]>) -> ContentHash {
    let hash = Sha256::digest(data);
    ContentHash(hash.iter().map(|b| format!("{:02x}", b)).collect())
}

pub async fn collect_relative_file_paths(dir: impl AsRef<Path>) -> Result<Vec<PathBuf>> {
    let mut paths = Vec::new();
    for entry in WalkDir::new(&dir) {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() {
            paths.push(path.strip_prefix(&dir)?.to_path_buf());
        }
    }
    Ok(paths)
}

pub async fn collect_absolute_dir_paths(dir: impl AsRef<Path>) -> Result<Vec<PathBuf>> {
    let mut paths = Vec::new();
    for entry in WalkDir::new(&dir) {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            paths.push(path.to_path_buf());
        }
    }
    Ok(paths)
}

pub async fn collect_datas(os: &Os, paths: &Vec<PathBuf>) -> Result<Vec<Vec<u8>>> {
    let mut datas = Vec::new();
    for path in paths.iter() {
        datas.push(os.fs.read(path).await?);
    }
    Ok(datas)
}

// #[cfg(test)]
// mod tests {
//     use std::collections::HashMap;
//     use std::path::{Path, PathBuf};
//     use std::str::FromStr;
//     use crate::cli::chat::tool_manager::ToolManager;
//     use crate::cli::chat::checkpoint::{
//         CheckpointManager, Tag, CHECKPOINT_DIR, CHECKPOINT_FILE
//     };
//     use crate::cli::agent::{Agents};
//     use crate::cli::chat::tools::fs_remove::FsRemove;
//     use crate::cli::chat::util::test::setup_test_directory;
//     use crate::cli::chat::conversation::{
//         ConversationState,
//     };
//     use crate::cli::chat::message::{
//         AssistantMessage,
//     };
//     use crate::os::Os;

//     const TEST_FILE_PATH: &str = "/test-file";

//     async fn create_conversation(os: &mut Os) -> ConversationState{
//         let agents = Agents::default();
//         let tool_config = HashMap::new();
//         let tool_manager = ToolManager::default();
//         let mut conversation = ConversationState::new(
//             "fake_id",
//             agents.clone(),
//             tool_config.clone(),
//             tool_manager.clone(),
//             None
//         ).await;

//          // Add some mock history entries
//         let user_msg1 = "Hello, can you help me with a file?".to_string();
//         let assistant_msg1 = AssistantMessage::new_response(
//             None,
//             "Sure! I can help you with file operations.".into()
//         );

//         conversation.set_next_user_message(user_msg1).await;
//         conversation.push_assistant_message(os, assistant_msg1, None);

//         let user_msg2 = "Create a test file for me".to_string();
//         let assistant_msg2 = AssistantMessage::new_response(
//             None,
//             "I'll create a test file for you.".into()
//         );

//         conversation.set_next_user_message(user_msg2).await;
//         conversation.push_assistant_message(os, assistant_msg2, None);

//         // Add more
//         // Add more history entries to simulate a longer conversation
//         for i in 3..=5 {
//             let user_msg = format!("User message {}", i);
//             let assistant_msg = AssistantMessage::new_response(
//                 None,
//                 format!("Assistant response {}", i).into()
//             );

//             conversation.set_next_user_message(user_msg).await;
//             conversation.push_assistant_message(os, assistant_msg, None);
//         }
//         conversation

//     }

//     async fn setup() -> (Os, ConversationState, CheckpointManager) {
//         let mut os = setup_test_directory().await;
//         let conversation = create_conversation(&mut os).await;
//         os.fs.create_dir_all(CHECKPOINT_DIR).await.unwrap();
//         os.fs.create_new(CHECKPOINT_FILE).await.unwrap();
//         CheckpointManager::init(&os).await.unwrap();
//         let manager = CheckpointManager::load_manager(&os).await.unwrap();

//         (os, conversation, manager)
//     }

//     async fn create_and_populate_dir(os: &Os, path: impl AsRef<Path>) {
//         let path = path.as_ref();
//         os.fs.create_dir_all(path).await.unwrap();
//         for i in 0..3 {
//             let nested = path.join(format!("test_dir{i}"));
//             os.fs.create_dir(&nested).await.unwrap();
//             for j in 0..5 {
//                 os.fs.create_new(nested.join(format!("test_file{j}"))).await.unwrap();
//             }
//         }
//     }

//     fn assert_dir_is_restored(os: &Os, path: impl AsRef<Path>) {
//         let path = path.as_ref();
//         assert!(os.fs.exists(path));
//         for i in 0..3 {
//             let nested = path.join(format!("test_dir{i}"));
//             assert!(os.fs.exists(&nested));
//             for j in 0..5 {
//                 assert!(os.fs.exists(nested.join(format!("test_file{j}"))));
//             }
//         }
//     }

//     #[tokio::test]
//     async fn restore_modify_file() {
//         let (os, mut conversation, mut manager) = setup().await;
//         let path = PathBuf::from(TEST_FILE_PATH);

//         let old_contents = "original contents";
//         let new_contents = "this is a new message!";

//         // Create file
//         os.fs.create_new(&path).await.unwrap();
//         os.fs.write(&path, old_contents).await.unwrap();

//         // Set up checkpointing and modify file
//         manager.setup_fs_write(&os, path.clone()).await.unwrap();
//         os.fs.write(&path, new_contents).await.unwrap();
//         assert_eq!(os.fs.read_to_string(&path).await.unwrap(), new_contents);

//         // Finish checkpointing
//         manager.checkpoint_fs_write(&os, path.clone(), "1".to_string(), Some("test
// checkpoint".to_string()), 0).await.unwrap();         assert_eq!(manager.checkpoints.len(), 2);
//         assert!(manager.tag_to_index.contains_key(&Tag::from_str("1").unwrap()));

//         // Tag initial checkpoint
//         manager.tag_initial_checkpoint_if_able(0);

//         // Restore checkpoint
//         manager.restore_checkpoint(&os, &mut conversation, "0".to_string()).await.unwrap();

//         // File content assertions
//         assert_eq!(os.fs.read_to_string(&path).await.unwrap(), old_contents);
//         assert_eq!(conversation.get_history_len(), 0);
//     }

//     #[tokio::test]
//     async fn restore_remove_file() {
//         let (os, mut conversation, mut manager) = setup().await;
//         let path = PathBuf::from(TEST_FILE_PATH);

//         let old_contents = "original contents";

//         // Create file
//         os.fs.create_new(&path).await.unwrap();
//         os.fs.write(&path, old_contents).await.unwrap();

//         // Set up checkpointing and delete file
//         manager.checkpoint_fs_remove(&os, vec![path.clone()], "1".to_string(), Some("test
// checkpoint".to_string()), 0).await.unwrap();         os.fs.remove_file(&path).await.unwrap();
//         assert!(!os.fs.exists(&path));

//         assert_eq!(manager.checkpoints.len(), 2);
//         assert!(manager.tag_to_index.contains_key(&Tag::from_str("1").unwrap()));

//         // Tag initial checkpoint
//         manager.tag_initial_checkpoint_if_able(0);

//         // Restore checkpoint
//         manager.restore_checkpoint(&os, &mut conversation, "0".to_string()).await.unwrap();

//         // File content assertions
//         assert!(os.fs.exists(&path));
//         assert_eq!(os.fs.read_to_string(&path).await.unwrap(), old_contents);
//         assert_eq!(conversation.get_history_len(), 0);
//     }

//     #[tokio::test]
//     async fn restore_rename_file() {
//         let (os, mut conversation, mut manager) = setup().await;
//         let old_path = PathBuf::from(TEST_FILE_PATH);
//         let new_path = PathBuf::from("/new_path");

//         let old_contents = "original contents";

//         // Create and rename file
//         os.fs.create_new(&old_path).await.unwrap();
//         os.fs.write(&old_path, old_contents).await.unwrap();
//         os.fs.rename(&old_path, &new_path).await.unwrap();

//         // Checkpoint
//         manager.checkpoint_fs_rename(&os, vec![old_path.clone()], vec![new_path.clone()],
// "1".to_string(), Some("test checkpoint".to_string()), 0).await.unwrap();

//         // Tag initial checkpoint
//         manager.tag_initial_checkpoint_if_able(0);

//         // Restore checkpoint
//         manager.restore_checkpoint(&os, &mut conversation, "0".to_string()).await.unwrap();

//         // File content assertions
//         assert!(!os.fs.exists(&new_path));
//         assert!(os.fs.exists(&old_path));
//         assert_eq!(os.fs.read_to_string(&old_path).await.unwrap(), old_contents);
//         assert_eq!(conversation.get_history_len(), 0);
//     }

//     #[tokio::test]
//     async fn restore_remove_dir() {
//         let (os, mut conversation, mut manager) = setup().await;
//         let path = PathBuf::from("/test_dir");

//         // Create dir to remove
//         create_and_populate_dir(&os, &path).await;

//         // Set up checkpointing and delete dir
//         let tool = FsRemove::RemoveDir { path: path.display().to_string(), summary: None };
//         let paths = tool.gather_paths_for_checkpointing(&os).await.unwrap();
//         let CheckpointPaths::Remove { paths } = paths else { panic!("Gathered paths were not the
// right format") };         manager.checkpoint_fs_remove(&os, paths, "1".to_string(), Some("test
// checkpoint".to_string()), 0).await.unwrap();

//         os.fs.remove_dir_all(&path).await.unwrap();
//         assert!(!os.fs.exists(&path));

//         assert_eq!(manager.checkpoints.len(), 2);
//         assert!(manager.tag_to_index.contains_key(&Tag::from_str("1").unwrap()));

//         // Tag initial checkpoint
//         manager.tag_initial_checkpoint_if_able(0);

//         // Restore checkpoint
//         manager.restore_checkpoint(&os, &mut conversation, "0".to_string()).await.unwrap();

//         // File content assertions
//         assert!(os.fs.exists(&path));
//         assert_dir_is_restored(&os, path);
//         assert_eq!(conversation.get_history_len(), 0);
//     }

// }
