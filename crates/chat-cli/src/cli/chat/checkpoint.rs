use std::cmp::Eq;
use std::collections::HashMap;
use std::fmt::Display;
use std::path::{
    Path,
    PathBuf,
};
use std::str::FromStr;

use chrono::{
    DateTime,
    Local,
};
use crossterm::style::Stylize;
use eyre::{
    Report,
    Result,
    bail,
    eyre,
};
use serde::{
    Deserialize,
    Serialize,
};
use sha2::{
    Digest,
    Sha256,
};
use walkdir::WalkDir;

use crate::cli::ConversationState;
use crate::os::Os;

// ######## HARDCODED VALUES ########
const CHECKPOINT_DIR: &str = "/Users/kiranbug/.aws/amazonq/checkpoints/first/";
const CHECKPOINT_FILE: &str = "/Users/kiranbug/.aws/amazonq/checkpoints/test_file.json";
// ######## ---------------- ########

// FIX: Move complicated logic (None -> Some) into checkpoint function?
//      - The benefit is that calling new_checkpoint() will be cleaner
//      - The downside is that the function will be messier and may miss edge cases; maybe better to
//        handle on a case-by-case basis?
// FIX: Remove hardcoded values
// FIX:

#[derive(Default, Clone, Serialize, Deserialize)]
pub struct CheckpointManager {
    pub checkpoints: Vec<Checkpoint>,
    pub tag_to_index: HashMap<Tag, usize>,
    pub num_turn_checkpoints: usize,

    store_dir: PathBuf,
    first_occurrence_cache: HashMap<PathBuf, usize>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct Checkpoint {
    pub state: HashMap<PathBuf, Option<ContentHash>>,
    pub summary: String,
    pub tool_name: String,
    pub history_index: usize,
    pub tag: Option<Tag>,
    pub timestamp: DateTime<Local>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct ContentHash(String);

impl Display for ContentHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(into = "String", try_from = "String")]
pub enum Tag {
    TurnLevel(usize),
    ToolLevel(usize, usize),
}

#[derive(Clone)]
pub enum CheckpointPaths {
    Write {
        path: PathBuf,
    },
    Rename {
        old_paths: Vec<PathBuf>,
        new_paths: Vec<PathBuf>,
    },
    Remove {
        paths: Vec<PathBuf>
    }
}

impl From<Tag> for String {
    fn from(tag: Tag) -> Self {
        tag.to_string()
    }
}

impl TryFrom<String> for Tag {
    type Error = Report;

    fn try_from(s: String) -> Result<Self, Self::Error> {
        Tag::from_str(&s)
    }
}

impl Display for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Tag::ToolLevel(i, j) => write!(f, "{i}.{j}"),
            Tag::TurnLevel(i) => write!(f, "{i}"),
        }
    }
}

// Generated by Q
impl FromStr for Tag {
    type Err = Report;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some((outer, inner)) = s.split_once('.') {
            let outer_tag = match outer.parse::<usize>() {
                Ok(o) => o,
                Err(_) => bail!("Invalid outer tag: {outer}"),
            };
            let inner_tag = match inner.parse::<usize>() {
                Ok(i) => i,
                Err(_) => bail!("Invalid inner tag: {inner}"),
            };

            Ok(Self::ToolLevel(outer_tag, inner_tag))
        } else {
            let tag = match s.parse::<usize>() {
                Ok(i) => i,
                Err(_) => bail!("Invalid tag: {s}"),
            };

            Ok(Self::TurnLevel(tag))
        }
    }
}

impl Tag {
    pub fn tag_belongs_to_turn(tag: Tag, turn_tag: Tag) -> bool {
        match (tag, turn_tag) {
            (Tag::ToolLevel(i, _), Tag::TurnLevel(t)) => t == i,
            (_, _) => false,
        }
    }

    pub fn is_turn(&self) -> bool {
        match self {
            Tag::ToolLevel(..) => false,
            Tag::TurnLevel(_) => true,
        }
    }
}

impl CheckpointManager {
    pub async fn init(os: &Os) -> Result<()> {
        let manager = Self {
            store_dir: Self::get_new_directory(),
            num_turn_checkpoints: 1,
            ..Default::default()
        };
        Self::save_manager(os, &manager).await?;
        Ok(())
    }

    pub async fn load_manager(os: &Os) -> Result<Self> {
        Ok(serde_json::from_str::<CheckpointManager>(
            &os.fs.read_to_string(CHECKPOINT_FILE).await?,
        )?)
    }

    pub async fn save_manager(os: &Os, manager: &CheckpointManager) -> Result<()> {
        os.fs.write(CHECKPOINT_FILE, serde_json::to_string(manager)?).await?;
        Ok(())
    }

    pub async fn checkpoint_with_data<P, D>(&mut self, os: &Os, paths: P, datas: D) -> Result<()>
    where
        P: Into<Vec<PathBuf>>,
        D: Into<Vec<Option<Vec<u8>>>>,
    {
        let paths = paths.into();
        let datas = datas.into();
        // Copy the previous checkpoint's state
        let mut new_map = if let Some(checkpoint) = self.checkpoints.iter().last() {
            checkpoint.state.clone()
        } else {
            HashMap::new()
        };

        for (path, data) in paths.iter().zip(datas) {
            let hash = data.as_ref().map(hash_data);

            // Create obj file
            if let Some((hash, data)) = hash.as_ref().zip(data.as_ref()) {
                self.create_obj_if_needed(os, &hash, data).await?;
            }

            new_map.insert(path.clone(), hash);

            // Log first occurrence
            self.first_occurrence_cache
                .entry(path.clone())
                .or_insert(self.checkpoints.len());
        }
        self.checkpoints.push(Checkpoint {
            state: new_map,
            summary: String::new(),
            tool_name: String::new(),
            history_index: 0,
            tag: None,
            timestamp: Local::now(),
        });

        Ok(())
    }

    pub async fn restore_checkpoint(
        &mut self,
        os: &Os,
        conversation: &mut ConversationState,
        tag: String,
    ) -> Result<()> {
        let index = match self.tag_to_index.get(&Tag::from_str(&tag)?) {
            Some(i) => i,
            None => bail!("No checkpoint with tag {tag}"),
        };
        self.restore(os, conversation, *index).await?;
        Ok(())
    }

    async fn restore(&mut self, os: &Os, conversation: &mut ConversationState, index: usize) -> Result<()> {
        let checkpoint = match self.checkpoints.get(index) {
            Some(c) => c,
            None => bail!(format!("No checkpoint with index: {index}")),
        };
        if checkpoint.tag.is_none() {
            bail!("Attempting to restore an untagged checkpoint!");
        }
        // If a touched file isn't in this checkpoint's state, look forward in history
        // to see the first time the file shows up.
        // This is complicated but necessary given the current design.
        for path in self.first_occurrence_cache.keys() {
            let hash_option = match checkpoint.state.get(path) {
                Some(hash) => hash,
                None => {
                    let first_occurrence = self.first_occurrence_cache.get(path).unwrap();
                    self.checkpoints[*first_occurrence].state.get(path).unwrap()
                },
            };
            match hash_option {
                Some(hash) => self.restore_file(os, path, hash).await?,
                None if os.fs.exists(path) => os.fs.remove_file(path).await?,
                _ => (),
            };
        }

        for _ in checkpoint.history_index..conversation.get_history_len() {
            conversation
                .pop_from_history()
                .ok_or(eyre!("Tried to pop from empty history"))?;
        }
        Ok(())
    }

    async fn create_obj_if_needed(&self, os: &Os, hash: &ContentHash, data: impl AsRef<[u8]>) -> Result<()> {
        let obj_path = self.hash_to_obj_path(hash);
        if os.fs.exists(&obj_path) {
            return Ok(());
        }
        os.fs.create_new(&obj_path).await?;
        os.fs.write(obj_path, data).await?;
        Ok(())
    }

    fn hash_to_obj_path(&self, hash: &ContentHash) -> PathBuf {
        self.store_dir.join(hash.to_string())
    }

    fn get_new_directory() -> PathBuf {
        PathBuf::from(CHECKPOINT_DIR)
    }

    async fn restore_file(&self, os: &Os, path: impl AsRef<Path>, hash: &ContentHash) -> Result<()> {
        let path = path.as_ref();
        
        // Create parent directories if needed
        if let Some(parent) = path.parent() {
            os.fs.create_dir_all(parent).await?;
        }
        if !os.fs.exists(&path) {
            os.fs.create_new(&path).await?;
        }
        os.fs.copy(self.hash_to_obj_path(hash), path).await?;
        Ok(())
    }

    fn tag_latest_checkpoint(&mut self, tag: String, summary: Option<String>, history_index: usize, tool_name: String) {
        let description = if let Some(s) = summary {
            s
        } else {
            "No description provided".dark_grey().to_string()
        };
        let num_checkpoints = self.checkpoints.len();

        self.tag_to_index
            .insert(Tag::from_str(&tag).unwrap(), num_checkpoints - 1);

        let checkpoint = &mut self.checkpoints[num_checkpoints - 1];
        checkpoint.summary = description;
        checkpoint.history_index = history_index;
        checkpoint.tag = Some(Tag::from_str(&tag).unwrap());
        checkpoint.tool_name = tool_name;
    }

    pub fn can_create_turn_checkpoint(&self) -> bool {
        if self.checkpoints.is_empty() {
            return false;
        }
        let last_checkpoint = self.checkpoints.iter().last().unwrap();
        if last_checkpoint.tag.is_none() || last_checkpoint.tag.as_ref().unwrap().is_turn() {
            return false;
        }
        true
    }

    pub fn turn_checkpoint(&mut self, summary: String) -> String {
        let mut new_checkpoint = self.checkpoints.iter().last().unwrap().clone();
        if let Tag::ToolLevel(t, _) = new_checkpoint.tag.clone().unwrap() {
            new_checkpoint.tag = Some(Tag::TurnLevel(t));
        }
        new_checkpoint.summary = summary;
        let return_tag = new_checkpoint.tag.clone().unwrap().to_string();

        self.checkpoints.push(new_checkpoint);
        self.tag_to_index
            .insert(Tag::from_str(&return_tag).unwrap(), self.checkpoints.len() - 1);
        self.num_turn_checkpoints += 1;

        return_tag
    }

    pub fn tag_initial_checkpoint_if_able(&mut self, history_index: usize) {
        if !self.checkpoints.is_empty() && self.checkpoints[0].tag.is_none() {
            let checkpoint = &mut self.checkpoints[0];
            let tag = Tag::from_str("0").unwrap();
            checkpoint.tag = Some(tag.clone());
            checkpoint.history_index = history_index;
            checkpoint.summary = "Initial checkpoint".to_string();

            self.tag_to_index.insert(tag, 0);
        }
    }

    pub async fn setup_fs_write(&mut self, os: &Os, path: PathBuf) -> Result<()> {
        let original_contents = if os.fs.exists(&path) {
            Some(os.fs.read(&path).await?)
        } else {
            None
        };
        // Save original contents
        self
            .checkpoint_with_data(os, &[path], &[original_contents])
            .await?;
        Ok(())
    }

    pub async fn checkpoint_fs_write(&mut self, os: &Os, path: PathBuf, tag: String, summary: Option<String>, history_index: usize) -> Result<()> {
        // Save new contents
        self
            .checkpoint_with_data(os, &[path.clone()], &[Some(os.fs.read(&path).await?)])
            .await?;
        self.tag_latest_checkpoint(tag, summary, history_index, "fs_write".to_string());
        Ok(())
    }

    pub async fn checkpoint_fs_remove(&mut self, os: &Os, paths: Vec<PathBuf>, tag: String, summary: Option<String>, history_index: usize)  -> Result<()> {
        let mut datas = Vec::new();
        for path in paths.iter() {
            datas.push(Some(os.fs.read(path).await?));
        }

        // Save all data
        self.checkpoint_with_data(os, paths.clone(), datas.clone()).await?;

        // Track files as deleted
        self
            .checkpoint_with_data(os, paths.clone(), vec![None; paths.len()])
            .await?;

        self.tag_latest_checkpoint(tag, summary, history_index, "fs_remove".to_string());

        Ok(())
    }

    pub async fn checkpoint_fs_rename(&mut self, os: &Os, old_paths: Vec<PathBuf>, new_paths: Vec<PathBuf>, tag: String, summary: Option<String>, history_index: usize) -> Result<()> {
        let mut datas = Vec::new();
        for path in new_paths.iter() {
            datas.push(Some(os.fs.read(path).await?));
        }
        
        // Save old paths and data
        self
            .checkpoint_with_data(os, old_paths.clone(), datas.clone())
            .await?;

        // Track both original and new paths as deleted (necessary intermediate step)
        self
            .checkpoint_with_data(
                os,
                [old_paths.clone(), new_paths.clone()].concat(),
                vec![None; old_paths.len() + new_paths.len()],
            )
            .await?;

        // Track new paths and their contents
        self.checkpoint_with_data(os, new_paths, datas).await?;
        
        self.tag_latest_checkpoint(tag, summary, history_index, "fs_rename".to_string());
        Ok(())
    }
}

fn hash_data(data: impl AsRef<[u8]>) -> ContentHash {
    let hash = Sha256::digest(data);
    ContentHash(hash.iter().map(|b| format!("{:02x}", b)).collect())
}

pub async fn collect_paths(dir: impl AsRef<Path>) -> Result<Vec<PathBuf>> {
    let mut paths = Vec::new();
    for entry in WalkDir::new(&dir) {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() {
            paths.push(path.strip_prefix(&dir)?.to_path_buf());
        }
    }
    Ok(paths)
}