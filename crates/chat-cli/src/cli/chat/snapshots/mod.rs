use std::path::Path;
use std::time::{
    SystemTime,
    UNIX_EPOCH,
};

use crossterm::style::{
    Color,
    Stylize,
};
use crossterm::{
    execute,
    style,
};
use eyre::{
    Result,
    bail,
};
use git2::{
    Repository,
    RepositoryInitOptions,
};

use serde::{
    Deserialize,
    Serialize,
};
use walkdir::WalkDir;

use super::ChatSession;
use crate::os::Os;

// ######## HARDCODED VALUES ########
const SHADOW_REPO_DIR: &str = "/Users/kiranbug/.aws/amazonq/shadow";
// ######## ---------------- ########

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnapshotManager {}

impl SnapshotManager {
    pub async fn init(os: &Os) -> Result<()> {
        let options = RepositoryInitOptions::new();
        let repo = Repository::init_opts(SHADOW_REPO_DIR, &options)?;

        copy_dir_exclude_git(os, os.env.current_dir()?, SHADOW_REPO_DIR).await?;

        Ok(())
    }

    pub fn stage_all(os: &Os, repo: Repository) -> Result<()> {
        let mut index = repo.index()?;
        index.add_all(["."].iter(), git2::IndexAddOption::DEFAULT, None)?;
        index.write()?;
        Ok(())
    }
}

pub fn get_timestamp() -> String {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_millis();

    format!("{timestamp}")
}

pub async fn get_modified_timestamp(os: &Os, path: &str) -> Result<u64> {
    let file = os.fs.open(path).await?;
    Ok(file
        .metadata()
        .await?
        .modified()?
        .duration_since(std::time::UNIX_EPOCH)?
        .as_secs())
}

/// Copies all contents from source to target, excluding the .git folder
///
/// Expects that `target` is an absolute path to an existing directory
pub async fn copy_dir_exclude_git(os: &Os, source: impl AsRef<Path>, target: impl AsRef<Path>) -> Result<()> {
    // Paths generated by WalkDir are not absolute
    for entry in WalkDir::new(&source)
        .into_iter()
        .filter_entry(|e| !path_contains(e.path(), ".git"))
    {
        let entry = match entry {
            Ok(entry) => entry,
            Err(_) => {
                // FIX: what do we do here instead of silently failing?
                continue;
            },
        };
        update_file_in_shadow(os, entry.path(), target.as_ref()).await?;
    }

    Ok(())
}

/// Copies the file/directory to the shadow repo
///
/// Assumes that all parent directories already exist in the shadow repo
async fn update_file_in_shadow(os: &Os, path: impl AsRef<Path>, shadow_repo: impl AsRef<Path>) -> Result<()> {
    let cwd = os.env.current_dir()?;

    let absolute_path = cwd.join(&path);
    let relative_path = path.as_ref().strip_prefix(os.env.current_dir()?)?;
    let target_path = Path::join(shadow_repo.as_ref(), relative_path);

    if absolute_path.is_dir() {
        os.fs.create_dir_all(target_path).await?;
    } else {
        os.fs.copy(absolute_path, target_path).await?;
    }
    Ok(())
}

/// Returns true if path contains part
///
/// Generated by Q
fn path_contains(path: &Path, part: &str) -> bool {
    path.components().any(|component| {
        if let std::path::Component::Normal(name) = component {
            name == part
        } else {
            false
        }
    })
}
