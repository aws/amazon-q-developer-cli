// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: fig.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Fig_Modifiers: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case control // = 0
  case option // = 1
  case command // = 2
  case shift // = 3
  case function // = 4
  case numpad // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .control
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .control
    case 1: self = .option
    case 2: self = .command
    case 3: self = .shift
    case 4: self = .function
    case 5: self = .numpad
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .control: return 0
    case .option: return 1
    case .command: return 2
    case .shift: return 3
    case .function: return 4
    case .numpad: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Fig_Modifiers: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Fig_Modifiers] = [
    .control,
    .option,
    .command,
    .shift,
    .function,
    .numpad,
  ]
}

#endif  // swift(>=4.2)

public enum Fig_OnboardingAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case installationScript // = 0
  case promptForAccessibilityPermission // = 1
  case launchShellOnboarding // = 3
  case uninstall // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .installationScript
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .installationScript
    case 1: self = .promptForAccessibilityPermission
    case 3: self = .launchShellOnboarding
    case 4: self = .uninstall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .installationScript: return 0
    case .promptForAccessibilityPermission: return 1
    case .launchShellOnboarding: return 3
    case .uninstall: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Fig_OnboardingAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Fig_OnboardingAction] = [
    .installationScript,
    .promptForAccessibilityPermission,
    .launchShellOnboarding,
    .uninstall,
  ]
}

#endif  // swift(>=4.2)

public enum Fig_FocusAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case takeFocus // = 0
  case returnFocus // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .takeFocus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .takeFocus
    case 1: self = .returnFocus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .takeFocus: return 0
    case .returnFocus: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Fig_FocusAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Fig_FocusAction] = [
    .takeFocus,
    .returnFocus,
  ]
}

#endif  // swift(>=4.2)

public enum Fig_ActionAvailability: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case always // = 0

  /// the action can only be performed when the app has keyboard focus
  case whenFocused // = 1

  /// the action can only be performed when the app is visible
  case whenVisible // = 2

  /// the action can only be performed when the app is hidden
  case whenHidden // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .always
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .always
    case 1: self = .whenFocused
    case 2: self = .whenVisible
    case 3: self = .whenHidden
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .always: return 0
    case .whenFocused: return 1
    case .whenVisible: return 2
    case .whenHidden: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Fig_ActionAvailability: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Fig_ActionAvailability] = [
    .always,
    .whenFocused,
    .whenVisible,
    .whenHidden,
  ]
}

#endif  // swift(>=4.2)

public enum Fig_NotificationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case all // = 0
  case notifyOnEditbuffferChange // = 1
  case notifyOnSettingsChange // = 2
  case notifyOnPrompt // = 3
  case notifyOnLocationChange // = 4
  case notifyOnProcessChanged // = 5
  case notifyOnKeybindingPressed // = 6
  case notifyOnFocusChanged // = 7
  case notifyOnHistoryUpdated // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .all
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .all
    case 1: self = .notifyOnEditbuffferChange
    case 2: self = .notifyOnSettingsChange
    case 3: self = .notifyOnPrompt
    case 4: self = .notifyOnLocationChange
    case 5: self = .notifyOnProcessChanged
    case 6: self = .notifyOnKeybindingPressed
    case 7: self = .notifyOnFocusChanged
    case 8: self = .notifyOnHistoryUpdated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .all: return 0
    case .notifyOnEditbuffferChange: return 1
    case .notifyOnSettingsChange: return 2
    case .notifyOnPrompt: return 3
    case .notifyOnLocationChange: return 4
    case .notifyOnProcessChanged: return 5
    case .notifyOnKeybindingPressed: return 6
    case .notifyOnFocusChanged: return 7
    case .notifyOnHistoryUpdated: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Fig_NotificationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Fig_NotificationType] = [
    .all,
    .notifyOnEditbuffferChange,
    .notifyOnSettingsChange,
    .notifyOnPrompt,
    .notifyOnLocationChange,
    .notifyOnProcessChanged,
    .notifyOnKeybindingPressed,
    .notifyOnFocusChanged,
    .notifyOnHistoryUpdated,
  ]
}

#endif  // swift(>=4.2)

public struct Fig_ClientOriginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var submessage: Fig_ClientOriginatedMessage.OneOf_Submessage? = nil

  public var positionWindowRequest: Fig_PositionWindowRequest {
    get {
      if case .positionWindowRequest(let v)? = submessage {return v}
      return Fig_PositionWindowRequest()
    }
    set {submessage = .positionWindowRequest(newValue)}
  }

  public var pseudoterminalExecuteRequest: Fig_PseudoterminalExecuteRequest {
    get {
      if case .pseudoterminalExecuteRequest(let v)? = submessage {return v}
      return Fig_PseudoterminalExecuteRequest()
    }
    set {submessage = .pseudoterminalExecuteRequest(newValue)}
  }

  public var pseudoterminalWriteRequest: Fig_PseudoterminalWriteRequest {
    get {
      if case .pseudoterminalWriteRequest(let v)? = submessage {return v}
      return Fig_PseudoterminalWriteRequest()
    }
    set {submessage = .pseudoterminalWriteRequest(newValue)}
  }

  public var readFileRequest: Fig_ReadFileRequest {
    get {
      if case .readFileRequest(let v)? = submessage {return v}
      return Fig_ReadFileRequest()
    }
    set {submessage = .readFileRequest(newValue)}
  }

  public var writeFileRequest: Fig_WriteFileRequest {
    get {
      if case .writeFileRequest(let v)? = submessage {return v}
      return Fig_WriteFileRequest()
    }
    set {submessage = .writeFileRequest(newValue)}
  }

  public var contentsOfDirectoryRequest: Fig_ContentsOfDirectoryRequest {
    get {
      if case .contentsOfDirectoryRequest(let v)? = submessage {return v}
      return Fig_ContentsOfDirectoryRequest()
    }
    set {submessage = .contentsOfDirectoryRequest(newValue)}
  }

  public var notificationRequest: Fig_NotificationRequest {
    get {
      if case .notificationRequest(let v)? = submessage {return v}
      return Fig_NotificationRequest()
    }
    set {submessage = .notificationRequest(newValue)}
  }

  public var getSettingsPropertyRequest: Fig_GetSettingsPropertyRequest {
    get {
      if case .getSettingsPropertyRequest(let v)? = submessage {return v}
      return Fig_GetSettingsPropertyRequest()
    }
    set {submessage = .getSettingsPropertyRequest(newValue)}
  }

  public var updateSettingsPropertyRequest: Fig_UpdateSettingsPropertyRequest {
    get {
      if case .updateSettingsPropertyRequest(let v)? = submessage {return v}
      return Fig_UpdateSettingsPropertyRequest()
    }
    set {submessage = .updateSettingsPropertyRequest(newValue)}
  }

  public var insertTextRequest: Fig_InsertTextRequest {
    get {
      if case .insertTextRequest(let v)? = submessage {return v}
      return Fig_InsertTextRequest()
    }
    set {submessage = .insertTextRequest(newValue)}
  }

  public var updateApplicationPropertiesRequest: Fig_UpdateApplicationPropertiesRequest {
    get {
      if case .updateApplicationPropertiesRequest(let v)? = submessage {return v}
      return Fig_UpdateApplicationPropertiesRequest()
    }
    set {submessage = .updateApplicationPropertiesRequest(newValue)}
  }

  public var destinationOfSymbolicLinkRequest: Fig_DestinationOfSymbolicLinkRequest {
    get {
      if case .destinationOfSymbolicLinkRequest(let v)? = submessage {return v}
      return Fig_DestinationOfSymbolicLinkRequest()
    }
    set {submessage = .destinationOfSymbolicLinkRequest(newValue)}
  }

  public var getDefaultsPropertyRequest: Fig_GetDefaultsPropertyRequest {
    get {
      if case .getDefaultsPropertyRequest(let v)? = submessage {return v}
      return Fig_GetDefaultsPropertyRequest()
    }
    set {submessage = .getDefaultsPropertyRequest(newValue)}
  }

  public var updateDefaultsPropertyRequest: Fig_UpdateDefaultsPropertyRequest {
    get {
      if case .updateDefaultsPropertyRequest(let v)? = submessage {return v}
      return Fig_UpdateDefaultsPropertyRequest()
    }
    set {submessage = .updateDefaultsPropertyRequest(newValue)}
  }

  public var telemetryAliasRequest: Fig_TelemetryAliasRequest {
    get {
      if case .telemetryAliasRequest(let v)? = submessage {return v}
      return Fig_TelemetryAliasRequest()
    }
    set {submessage = .telemetryAliasRequest(newValue)}
  }

  public var telemetryIdentifyRequest: Fig_TelemetryIdentifyRequest {
    get {
      if case .telemetryIdentifyRequest(let v)? = submessage {return v}
      return Fig_TelemetryIdentifyRequest()
    }
    set {submessage = .telemetryIdentifyRequest(newValue)}
  }

  public var telemetryTrackRequest: Fig_TelemetryTrackRequest {
    get {
      if case .telemetryTrackRequest(let v)? = submessage {return v}
      return Fig_TelemetryTrackRequest()
    }
    set {submessage = .telemetryTrackRequest(newValue)}
  }

  public var onboardingRequest: Fig_OnboardingRequest {
    get {
      if case .onboardingRequest(let v)? = submessage {return v}
      return Fig_OnboardingRequest()
    }
    set {submessage = .onboardingRequest(newValue)}
  }

  public var windowFocusRequest: Fig_WindowFocusRequest {
    get {
      if case .windowFocusRequest(let v)? = submessage {return v}
      return Fig_WindowFocusRequest()
    }
    set {submessage = .windowFocusRequest(newValue)}
  }

  public var openInExternalApplicationRequest: Fig_OpenInExternalApplicationRequest {
    get {
      if case .openInExternalApplicationRequest(let v)? = submessage {return v}
      return Fig_OpenInExternalApplicationRequest()
    }
    set {submessage = .openInExternalApplicationRequest(newValue)}
  }

  public var getConfigPropertyRequest: Fig_GetConfigPropertyRequest {
    get {
      if case .getConfigPropertyRequest(let v)? = submessage {return v}
      return Fig_GetConfigPropertyRequest()
    }
    set {submessage = .getConfigPropertyRequest(newValue)}
  }

  public var updateConfigPropertyRequest: Fig_UpdateConfigPropertyRequest {
    get {
      if case .updateConfigPropertyRequest(let v)? = submessage {return v}
      return Fig_UpdateConfigPropertyRequest()
    }
    set {submessage = .updateConfigPropertyRequest(newValue)}
  }

  public var pseudoterminalRestartRequest: Fig_PseudoterminalRestartRequest {
    get {
      if case .pseudoterminalRestartRequest(let v)? = submessage {return v}
      return Fig_PseudoterminalRestartRequest()
    }
    set {submessage = .pseudoterminalRestartRequest(newValue)}
  }

  public var terminalSessionInfoRequest: Fig_TerminalSessionInfoRequest {
    get {
      if case .terminalSessionInfoRequest(let v)? = submessage {return v}
      return Fig_TerminalSessionInfoRequest()
    }
    set {submessage = .terminalSessionInfoRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Submessage: Equatable {
    case positionWindowRequest(Fig_PositionWindowRequest)
    case pseudoterminalExecuteRequest(Fig_PseudoterminalExecuteRequest)
    case pseudoterminalWriteRequest(Fig_PseudoterminalWriteRequest)
    case readFileRequest(Fig_ReadFileRequest)
    case writeFileRequest(Fig_WriteFileRequest)
    case contentsOfDirectoryRequest(Fig_ContentsOfDirectoryRequest)
    case notificationRequest(Fig_NotificationRequest)
    case getSettingsPropertyRequest(Fig_GetSettingsPropertyRequest)
    case updateSettingsPropertyRequest(Fig_UpdateSettingsPropertyRequest)
    case insertTextRequest(Fig_InsertTextRequest)
    case updateApplicationPropertiesRequest(Fig_UpdateApplicationPropertiesRequest)
    case destinationOfSymbolicLinkRequest(Fig_DestinationOfSymbolicLinkRequest)
    case getDefaultsPropertyRequest(Fig_GetDefaultsPropertyRequest)
    case updateDefaultsPropertyRequest(Fig_UpdateDefaultsPropertyRequest)
    case telemetryAliasRequest(Fig_TelemetryAliasRequest)
    case telemetryIdentifyRequest(Fig_TelemetryIdentifyRequest)
    case telemetryTrackRequest(Fig_TelemetryTrackRequest)
    case onboardingRequest(Fig_OnboardingRequest)
    case windowFocusRequest(Fig_WindowFocusRequest)
    case openInExternalApplicationRequest(Fig_OpenInExternalApplicationRequest)
    case getConfigPropertyRequest(Fig_GetConfigPropertyRequest)
    case updateConfigPropertyRequest(Fig_UpdateConfigPropertyRequest)
    case pseudoterminalRestartRequest(Fig_PseudoterminalRestartRequest)
    case terminalSessionInfoRequest(Fig_TerminalSessionInfoRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_ClientOriginatedMessage.OneOf_Submessage, rhs: Fig_ClientOriginatedMessage.OneOf_Submessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.positionWindowRequest, .positionWindowRequest): return {
        guard case .positionWindowRequest(let l) = lhs, case .positionWindowRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pseudoterminalExecuteRequest, .pseudoterminalExecuteRequest): return {
        guard case .pseudoterminalExecuteRequest(let l) = lhs, case .pseudoterminalExecuteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pseudoterminalWriteRequest, .pseudoterminalWriteRequest): return {
        guard case .pseudoterminalWriteRequest(let l) = lhs, case .pseudoterminalWriteRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readFileRequest, .readFileRequest): return {
        guard case .readFileRequest(let l) = lhs, case .readFileRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.writeFileRequest, .writeFileRequest): return {
        guard case .writeFileRequest(let l) = lhs, case .writeFileRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contentsOfDirectoryRequest, .contentsOfDirectoryRequest): return {
        guard case .contentsOfDirectoryRequest(let l) = lhs, case .contentsOfDirectoryRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationRequest, .notificationRequest): return {
        guard case .notificationRequest(let l) = lhs, case .notificationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getSettingsPropertyRequest, .getSettingsPropertyRequest): return {
        guard case .getSettingsPropertyRequest(let l) = lhs, case .getSettingsPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateSettingsPropertyRequest, .updateSettingsPropertyRequest): return {
        guard case .updateSettingsPropertyRequest(let l) = lhs, case .updateSettingsPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.insertTextRequest, .insertTextRequest): return {
        guard case .insertTextRequest(let l) = lhs, case .insertTextRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateApplicationPropertiesRequest, .updateApplicationPropertiesRequest): return {
        guard case .updateApplicationPropertiesRequest(let l) = lhs, case .updateApplicationPropertiesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destinationOfSymbolicLinkRequest, .destinationOfSymbolicLinkRequest): return {
        guard case .destinationOfSymbolicLinkRequest(let l) = lhs, case .destinationOfSymbolicLinkRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getDefaultsPropertyRequest, .getDefaultsPropertyRequest): return {
        guard case .getDefaultsPropertyRequest(let l) = lhs, case .getDefaultsPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateDefaultsPropertyRequest, .updateDefaultsPropertyRequest): return {
        guard case .updateDefaultsPropertyRequest(let l) = lhs, case .updateDefaultsPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.telemetryAliasRequest, .telemetryAliasRequest): return {
        guard case .telemetryAliasRequest(let l) = lhs, case .telemetryAliasRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.telemetryIdentifyRequest, .telemetryIdentifyRequest): return {
        guard case .telemetryIdentifyRequest(let l) = lhs, case .telemetryIdentifyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.telemetryTrackRequest, .telemetryTrackRequest): return {
        guard case .telemetryTrackRequest(let l) = lhs, case .telemetryTrackRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.onboardingRequest, .onboardingRequest): return {
        guard case .onboardingRequest(let l) = lhs, case .onboardingRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowFocusRequest, .windowFocusRequest): return {
        guard case .windowFocusRequest(let l) = lhs, case .windowFocusRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.openInExternalApplicationRequest, .openInExternalApplicationRequest): return {
        guard case .openInExternalApplicationRequest(let l) = lhs, case .openInExternalApplicationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getConfigPropertyRequest, .getConfigPropertyRequest): return {
        guard case .getConfigPropertyRequest(let l) = lhs, case .getConfigPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateConfigPropertyRequest, .updateConfigPropertyRequest): return {
        guard case .updateConfigPropertyRequest(let l) = lhs, case .updateConfigPropertyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pseudoterminalRestartRequest, .pseudoterminalRestartRequest): return {
        guard case .pseudoterminalRestartRequest(let l) = lhs, case .pseudoterminalRestartRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.terminalSessionInfoRequest, .terminalSessionInfoRequest): return {
        guard case .terminalSessionInfoRequest(let l) = lhs, case .terminalSessionInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
}

public struct Fig_ServerOriginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// Responses to ClientOriginatedMessages of the corresponding type
  public var submessage: Fig_ServerOriginatedMessage.OneOf_Submessage? = nil

  public var error: String {
    get {
      if case .error(let v)? = submessage {return v}
      return String()
    }
    set {submessage = .error(newValue)}
  }

  public var success: Bool {
    get {
      if case .success(let v)? = submessage {return v}
      return false
    }
    set {submessage = .success(newValue)}
  }

  public var positionWindowResponse: Fig_PositionWindowResponse {
    get {
      if case .positionWindowResponse(let v)? = submessage {return v}
      return Fig_PositionWindowResponse()
    }
    set {submessage = .positionWindowResponse(newValue)}
  }

  public var pseudoterminalExecuteResponse: Fig_PseudoterminalExecuteResponse {
    get {
      if case .pseudoterminalExecuteResponse(let v)? = submessage {return v}
      return Fig_PseudoterminalExecuteResponse()
    }
    set {submessage = .pseudoterminalExecuteResponse(newValue)}
  }

  public var readFileResponse: Fig_ReadFileResponse {
    get {
      if case .readFileResponse(let v)? = submessage {return v}
      return Fig_ReadFileResponse()
    }
    set {submessage = .readFileResponse(newValue)}
  }

  public var contentsOfDirectoryResponse: Fig_ContentsOfDirectoryResponse {
    get {
      if case .contentsOfDirectoryResponse(let v)? = submessage {return v}
      return Fig_ContentsOfDirectoryResponse()
    }
    set {submessage = .contentsOfDirectoryResponse(newValue)}
  }

  public var getSettingsPropertyResponse: Fig_GetSettingsPropertyResponse {
    get {
      if case .getSettingsPropertyResponse(let v)? = submessage {return v}
      return Fig_GetSettingsPropertyResponse()
    }
    set {submessage = .getSettingsPropertyResponse(newValue)}
  }

  public var destinationOfSymbolicLinkResponse: Fig_DestinationOfSymbolicLinkResponse {
    get {
      if case .destinationOfSymbolicLinkResponse(let v)? = submessage {return v}
      return Fig_DestinationOfSymbolicLinkResponse()
    }
    set {submessage = .destinationOfSymbolicLinkResponse(newValue)}
  }

  public var getDefaultsPropertyResponse: Fig_GetDefaultsPropertyResponse {
    get {
      if case .getDefaultsPropertyResponse(let v)? = submessage {return v}
      return Fig_GetDefaultsPropertyResponse()
    }
    set {submessage = .getDefaultsPropertyResponse(newValue)}
  }

  public var getConfigPropertyResponse: Fig_GetConfigPropertyResponse {
    get {
      if case .getConfigPropertyResponse(let v)? = submessage {return v}
      return Fig_GetConfigPropertyResponse()
    }
    set {submessage = .getConfigPropertyResponse(newValue)}
  }

  public var terminalSessionInfoResponse: Fig_TerminalSessionInfoResponse {
    get {
      if case .terminalSessionInfoResponse(let v)? = submessage {return v}
      return Fig_TerminalSessionInfoResponse()
    }
    set {submessage = .terminalSessionInfoResponse(newValue)}
  }

  public var notification: Fig_Notification {
    get {
      if case .notification(let v)? = submessage {return v}
      return Fig_Notification()
    }
    set {submessage = .notification(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Responses to ClientOriginatedMessages of the corresponding type
  public enum OneOf_Submessage: Equatable {
    case error(String)
    case success(Bool)
    case positionWindowResponse(Fig_PositionWindowResponse)
    case pseudoterminalExecuteResponse(Fig_PseudoterminalExecuteResponse)
    case readFileResponse(Fig_ReadFileResponse)
    case contentsOfDirectoryResponse(Fig_ContentsOfDirectoryResponse)
    case getSettingsPropertyResponse(Fig_GetSettingsPropertyResponse)
    case destinationOfSymbolicLinkResponse(Fig_DestinationOfSymbolicLinkResponse)
    case getDefaultsPropertyResponse(Fig_GetDefaultsPropertyResponse)
    case getConfigPropertyResponse(Fig_GetConfigPropertyResponse)
    case terminalSessionInfoResponse(Fig_TerminalSessionInfoResponse)
    case notification(Fig_Notification)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_ServerOriginatedMessage.OneOf_Submessage, rhs: Fig_ServerOriginatedMessage.OneOf_Submessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionWindowResponse, .positionWindowResponse): return {
        guard case .positionWindowResponse(let l) = lhs, case .positionWindowResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pseudoterminalExecuteResponse, .pseudoterminalExecuteResponse): return {
        guard case .pseudoterminalExecuteResponse(let l) = lhs, case .pseudoterminalExecuteResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readFileResponse, .readFileResponse): return {
        guard case .readFileResponse(let l) = lhs, case .readFileResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contentsOfDirectoryResponse, .contentsOfDirectoryResponse): return {
        guard case .contentsOfDirectoryResponse(let l) = lhs, case .contentsOfDirectoryResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getSettingsPropertyResponse, .getSettingsPropertyResponse): return {
        guard case .getSettingsPropertyResponse(let l) = lhs, case .getSettingsPropertyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destinationOfSymbolicLinkResponse, .destinationOfSymbolicLinkResponse): return {
        guard case .destinationOfSymbolicLinkResponse(let l) = lhs, case .destinationOfSymbolicLinkResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getDefaultsPropertyResponse, .getDefaultsPropertyResponse): return {
        guard case .getDefaultsPropertyResponse(let l) = lhs, case .getDefaultsPropertyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getConfigPropertyResponse, .getConfigPropertyResponse): return {
        guard case .getConfigPropertyResponse(let l) = lhs, case .getConfigPropertyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.terminalSessionInfoResponse, .terminalSessionInfoResponse): return {
        guard case .terminalSessionInfoResponse(let l) = lhs, case .terminalSessionInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notification, .notification): return {
        guard case .notification(let l) = lhs, case .notification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _id: Int64? = nil
}

public struct Fig_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Float = 0

  public var y: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_Size {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Float = 0

  public var height: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var origin: Fig_Point {
    get {return _origin ?? Fig_Point()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  public var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  public mutating func clearOrigin() {self._origin = nil}

  public var size: Fig_Size {
    get {return _size ?? Fig_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _origin: Fig_Point? = nil
  fileprivate var _size: Fig_Size? = nil
}

public struct Fig_EnvironmentVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: String? = nil
}

public struct Fig_Process {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pid: Int32 {
    get {return _pid ?? 0}
    set {_pid = newValue}
  }
  /// Returns true if `pid` has been explicitly set.
  public var hasPid: Bool {return self._pid != nil}
  /// Clears the value of `pid`. Subsequent reads from it will return its default value.
  public mutating func clearPid() {self._pid = nil}

  public var executable: String {
    get {return _executable ?? String()}
    set {_executable = newValue}
  }
  /// Returns true if `executable` has been explicitly set.
  public var hasExecutable: Bool {return self._executable != nil}
  /// Clears the value of `executable`. Subsequent reads from it will return its default value.
  public mutating func clearExecutable() {self._executable = nil}

  public var directory: String {
    get {return _directory ?? String()}
    set {_directory = newValue}
  }
  /// Returns true if `directory` has been explicitly set.
  public var hasDirectory: Bool {return self._directory != nil}
  /// Clears the value of `directory`. Subsequent reads from it will return its default value.
  public mutating func clearDirectory() {self._directory = nil}

  public var env: [Fig_EnvironmentVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pid: Int32? = nil
  fileprivate var _executable: String? = nil
  fileprivate var _directory: String? = nil
}

public struct Fig_FilePath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var relativeTo: String {
    get {return _relativeTo ?? String()}
    set {_relativeTo = newValue}
  }
  /// Returns true if `relativeTo` has been explicitly set.
  public var hasRelativeTo: Bool {return self._relativeTo != nil}
  /// Clears the value of `relativeTo`. Subsequent reads from it will return its default value.
  public mutating func clearRelativeTo() {self._relativeTo = nil}

  public var expandTildeInPath: Bool {
    get {return _expandTildeInPath ?? false}
    set {_expandTildeInPath = newValue}
  }
  /// Returns true if `expandTildeInPath` has been explicitly set.
  public var hasExpandTildeInPath: Bool {return self._expandTildeInPath != nil}
  /// Clears the value of `expandTildeInPath`. Subsequent reads from it will return its default value.
  public mutating func clearExpandTildeInPath() {self._expandTildeInPath = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _path: String? = nil
  fileprivate var _relativeTo: String? = nil
  fileprivate var _expandTildeInPath: Bool? = nil
}

public struct Fig_KeyEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appleKeyCode: Int32 {
    get {return _appleKeyCode ?? 0}
    set {_appleKeyCode = newValue}
  }
  /// Returns true if `appleKeyCode` has been explicitly set.
  public var hasAppleKeyCode: Bool {return self._appleKeyCode != nil}
  /// Clears the value of `appleKeyCode`. Subsequent reads from it will return its default value.
  public mutating func clearAppleKeyCode() {self._appleKeyCode = nil}

  public var characters: String {
    get {return _characters ?? String()}
    set {_characters = newValue}
  }
  /// Returns true if `characters` has been explicitly set.
  public var hasCharacters: Bool {return self._characters != nil}
  /// Clears the value of `characters`. Subsequent reads from it will return its default value.
  public mutating func clearCharacters() {self._characters = nil}

  public var charactersIgnoringModifiers: String {
    get {return _charactersIgnoringModifiers ?? String()}
    set {_charactersIgnoringModifiers = newValue}
  }
  /// Returns true if `charactersIgnoringModifiers` has been explicitly set.
  public var hasCharactersIgnoringModifiers: Bool {return self._charactersIgnoringModifiers != nil}
  /// Clears the value of `charactersIgnoringModifiers`. Subsequent reads from it will return its default value.
  public mutating func clearCharactersIgnoringModifiers() {self._charactersIgnoringModifiers = nil}

  public var modifiers: [Fig_Modifiers] = []

  public var isRepeat: Bool {
    get {return _isRepeat ?? false}
    set {_isRepeat = newValue}
  }
  /// Returns true if `isRepeat` has been explicitly set.
  public var hasIsRepeat: Bool {return self._isRepeat != nil}
  /// Clears the value of `isRepeat`. Subsequent reads from it will return its default value.
  public mutating func clearIsRepeat() {self._isRepeat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _appleKeyCode: Int32? = nil
  fileprivate var _characters: String? = nil
  fileprivate var _charactersIgnoringModifiers: String? = nil
  fileprivate var _isRepeat: Bool? = nil
}

public struct Fig_Screen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var frame: Fig_Frame {
    get {return _frame ?? Fig_Frame()}
    set {_frame = newValue}
  }
  /// Returns true if `frame` has been explicitly set.
  public var hasFrame: Bool {return self._frame != nil}
  /// Clears the value of `frame`. Subsequent reads from it will return its default value.
  public mutating func clearFrame() {self._frame = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _frame: Fig_Frame? = nil
}

public struct Fig_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var frontmostProcess: Fig_Process {
    get {return _frontmostProcess ?? Fig_Process()}
    set {_frontmostProcess = newValue}
  }
  /// Returns true if `frontmostProcess` has been explicitly set.
  public var hasFrontmostProcess: Bool {return self._frontmostProcess != nil}
  /// Clears the value of `frontmostProcess`. Subsequent reads from it will return its default value.
  public mutating func clearFrontmostProcess() {self._frontmostProcess = nil}

  public var env: [Fig_EnvironmentVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionID: String? = nil
  fileprivate var _frontmostProcess: Fig_Process? = nil
}

public struct Fig_Application {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bundleIdentifier: String {
    get {return _bundleIdentifier ?? String()}
    set {_bundleIdentifier = newValue}
  }
  /// Returns true if `bundleIdentifier` has been explicitly set.
  public var hasBundleIdentifier: Bool {return self._bundleIdentifier != nil}
  /// Clears the value of `bundleIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearBundleIdentifier() {self._bundleIdentifier = nil}

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bundleIdentifier: String? = nil
  fileprivate var _name: String? = nil
}

public struct Fig_Window {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var windowID: String {
    get {return _storage._windowID ?? String()}
    set {_uniqueStorage()._windowID = newValue}
  }
  /// Returns true if `windowID` has been explicitly set.
  public var hasWindowID: Bool {return _storage._windowID != nil}
  /// Clears the value of `windowID`. Subsequent reads from it will return its default value.
  public mutating func clearWindowID() {_uniqueStorage()._windowID = nil}

  public var frame: Fig_Frame {
    get {return _storage._frame ?? Fig_Frame()}
    set {_uniqueStorage()._frame = newValue}
  }
  /// Returns true if `frame` has been explicitly set.
  public var hasFrame: Bool {return _storage._frame != nil}
  /// Clears the value of `frame`. Subsequent reads from it will return its default value.
  public mutating func clearFrame() {_uniqueStorage()._frame = nil}

  public var currentSession: Fig_Session {
    get {return _storage._currentSession ?? Fig_Session()}
    set {_uniqueStorage()._currentSession = newValue}
  }
  /// Returns true if `currentSession` has been explicitly set.
  public var hasCurrentSession: Bool {return _storage._currentSession != nil}
  /// Clears the value of `currentSession`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentSession() {_uniqueStorage()._currentSession = nil}

  public var app: Fig_Application {
    get {return _storage._app ?? Fig_Application()}
    set {_uniqueStorage()._app = newValue}
  }
  /// Returns true if `app` has been explicitly set.
  public var hasApp: Bool {return _storage._app != nil}
  /// Clears the value of `app`. Subsequent reads from it will return its default value.
  public mutating func clearApp() {_uniqueStorage()._app = nil}

  public var currentScreen: Fig_Screen {
    get {return _storage._currentScreen ?? Fig_Screen()}
    set {_uniqueStorage()._currentScreen = newValue}
  }
  /// Returns true if `currentScreen` has been explicitly set.
  public var hasCurrentScreen: Bool {return _storage._currentScreen != nil}
  /// Clears the value of `currentScreen`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentScreen() {_uniqueStorage()._currentScreen = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Fig_TextUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var insertion: String {
    get {return _insertion ?? String()}
    set {_insertion = newValue}
  }
  /// Returns true if `insertion` has been explicitly set.
  public var hasInsertion: Bool {return self._insertion != nil}
  /// Clears the value of `insertion`. Subsequent reads from it will return its default value.
  public mutating func clearInsertion() {self._insertion = nil}

  public var deletion: Int64 {
    get {return _deletion ?? 0}
    set {_deletion = newValue}
  }
  /// Returns true if `deletion` has been explicitly set.
  public var hasDeletion: Bool {return self._deletion != nil}
  /// Clears the value of `deletion`. Subsequent reads from it will return its default value.
  public mutating func clearDeletion() {self._deletion = nil}

  public var offset: Int64 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  public var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  public mutating func clearOffset() {self._offset = nil}

  public var immediate: Bool {
    get {return _immediate ?? false}
    set {_immediate = newValue}
  }
  /// Returns true if `immediate` has been explicitly set.
  public var hasImmediate: Bool {return self._immediate != nil}
  /// Clears the value of `immediate`. Subsequent reads from it will return its default value.
  public mutating func clearImmediate() {self._immediate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _insertion: String? = nil
  fileprivate var _deletion: Int64? = nil
  fileprivate var _offset: Int64? = nil
  fileprivate var _immediate: Bool? = nil
}

public struct Fig_InsertTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Fig_InsertTextRequest.OneOf_Type? = nil

  public var text: String {
    get {
      if case .text(let v)? = type {return v}
      return String()
    }
    set {type = .text(newValue)}
  }

  public var update: Fig_TextUpdate {
    get {
      if case .update(let v)? = type {return v}
      return Fig_TextUpdate()
    }
    set {type = .update(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case text(String)
    case update(Fig_TextUpdate)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_InsertTextRequest.OneOf_Type, rhs: Fig_InsertTextRequest.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Fig_PseudoterminalWriteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: Fig_PseudoterminalWriteRequest.OneOf_Input? = nil

  public var text: String {
    get {
      if case .text(let v)? = input {return v}
      return String()
    }
    set {input = .text(newValue)}
  }

  public var octal: Data {
    get {
      if case .octal(let v)? = input {return v}
      return Data()
    }
    set {input = .octal(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Input: Equatable {
    case text(String)
    case octal(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_PseudoterminalWriteRequest.OneOf_Input, rhs: Fig_PseudoterminalWriteRequest.OneOf_Input) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.octal, .octal): return {
        guard case .octal(let l) = lhs, case .octal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Fig_PseudoterminalExecuteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: String = String()

  public var workingDirectory: String {
    get {return _workingDirectory ?? String()}
    set {_workingDirectory = newValue}
  }
  /// Returns true if `workingDirectory` has been explicitly set.
  public var hasWorkingDirectory: Bool {return self._workingDirectory != nil}
  /// Clears the value of `workingDirectory`. Subsequent reads from it will return its default value.
  public mutating func clearWorkingDirectory() {self._workingDirectory = nil}

  public var backgroundJob: Bool {
    get {return _backgroundJob ?? false}
    set {_backgroundJob = newValue}
  }
  /// Returns true if `backgroundJob` has been explicitly set.
  public var hasBackgroundJob: Bool {return self._backgroundJob != nil}
  /// Clears the value of `backgroundJob`. Subsequent reads from it will return its default value.
  public mutating func clearBackgroundJob() {self._backgroundJob = nil}

  public var isPipelined: Bool {
    get {return _isPipelined ?? false}
    set {_isPipelined = newValue}
  }
  /// Returns true if `isPipelined` has been explicitly set.
  public var hasIsPipelined: Bool {return self._isPipelined != nil}
  /// Clears the value of `isPipelined`. Subsequent reads from it will return its default value.
  public mutating func clearIsPipelined() {self._isPipelined = nil}

  public var env: [Fig_EnvironmentVariable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workingDirectory: String? = nil
  fileprivate var _backgroundJob: Bool? = nil
  fileprivate var _isPipelined: Bool? = nil
}

public struct Fig_PseudoterminalExecuteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stdout: String = String()

  public var stderr: String {
    get {return _stderr ?? String()}
    set {_stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  public var hasStderr: Bool {return self._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  public mutating func clearStderr() {self._stderr = nil}

  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stderr: String? = nil
  fileprivate var _exitCode: Int32? = nil
}

public struct Fig_PseudoterminalRestartRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_PositionWindowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var anchor: Fig_Point {
    get {return _anchor ?? Fig_Point()}
    set {_anchor = newValue}
  }
  /// Returns true if `anchor` has been explicitly set.
  public var hasAnchor: Bool {return self._anchor != nil}
  /// Clears the value of `anchor`. Subsequent reads from it will return its default value.
  public mutating func clearAnchor() {self._anchor = nil}

  public var size: Fig_Size {
    get {return _size ?? Fig_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var dryrun: Bool {
    get {return _dryrun ?? false}
    set {_dryrun = newValue}
  }
  /// Returns true if `dryrun` has been explicitly set.
  public var hasDryrun: Bool {return self._dryrun != nil}
  /// Clears the value of `dryrun`. Subsequent reads from it will return its default value.
  public mutating func clearDryrun() {self._dryrun = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _anchor: Fig_Point? = nil
  fileprivate var _size: Fig_Size? = nil
  fileprivate var _dryrun: Bool? = nil
}

public struct Fig_PositionWindowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isAbove: Bool {
    get {return _isAbove ?? false}
    set {_isAbove = newValue}
  }
  /// Returns true if `isAbove` has been explicitly set.
  public var hasIsAbove: Bool {return self._isAbove != nil}
  /// Clears the value of `isAbove`. Subsequent reads from it will return its default value.
  public mutating func clearIsAbove() {self._isAbove = nil}

  public var isClipped: Bool {
    get {return _isClipped ?? false}
    set {_isClipped = newValue}
  }
  /// Returns true if `isClipped` has been explicitly set.
  public var hasIsClipped: Bool {return self._isClipped != nil}
  /// Clears the value of `isClipped`. Subsequent reads from it will return its default value.
  public mutating func clearIsClipped() {self._isClipped = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _isAbove: Bool? = nil
  fileprivate var _isClipped: Bool? = nil
}

public struct Fig_ReadFileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: Fig_FilePath {
    get {return _path ?? Fig_FilePath()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var isBinaryFile: Bool {
    get {return _isBinaryFile ?? false}
    set {_isBinaryFile = newValue}
  }
  /// Returns true if `isBinaryFile` has been explicitly set.
  public var hasIsBinaryFile: Bool {return self._isBinaryFile != nil}
  /// Clears the value of `isBinaryFile`. Subsequent reads from it will return its default value.
  public mutating func clearIsBinaryFile() {self._isBinaryFile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _path: Fig_FilePath? = nil
  fileprivate var _isBinaryFile: Bool? = nil
}

public struct Fig_ReadFileResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Fig_ReadFileResponse.OneOf_Type? = nil

  public var data: Data {
    get {
      if case .data(let v)? = type {return v}
      return Data()
    }
    set {type = .data(newValue)}
  }

  public var text: String {
    get {
      if case .text(let v)? = type {return v}
      return String()
    }
    set {type = .text(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case data(Data)
    case text(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_ReadFileResponse.OneOf_Type, rhs: Fig_ReadFileResponse.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Fig_WriteFileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: Fig_FilePath {
    get {return _path ?? Fig_FilePath()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var data: Fig_WriteFileRequest.OneOf_Data? = nil

  public var text: String {
    get {
      if case .text(let v)? = data {return v}
      return String()
    }
    set {data = .text(newValue)}
  }

  public var binary: Data {
    get {
      if case .binary(let v)? = data {return v}
      return Data()
    }
    set {data = .binary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    case text(String)
    case binary(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_WriteFileRequest.OneOf_Data, rhs: Fig_WriteFileRequest.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binary, .binary): return {
        guard case .binary(let l) = lhs, case .binary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _path: Fig_FilePath? = nil
}

public struct Fig_ContentsOfDirectoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var directory: Fig_FilePath {
    get {return _directory ?? Fig_FilePath()}
    set {_directory = newValue}
  }
  /// Returns true if `directory` has been explicitly set.
  public var hasDirectory: Bool {return self._directory != nil}
  /// Clears the value of `directory`. Subsequent reads from it will return its default value.
  public mutating func clearDirectory() {self._directory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _directory: Fig_FilePath? = nil
}

public struct Fig_ContentsOfDirectoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileNames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_DestinationOfSymbolicLinkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: Fig_FilePath {
    get {return _path ?? Fig_FilePath()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _path: Fig_FilePath? = nil
}

public struct Fig_DestinationOfSymbolicLinkResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var destination: Fig_FilePath {
    get {return _destination ?? Fig_FilePath()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {self._destination = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _destination: Fig_FilePath? = nil
}

public struct Fig_DefaultsValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Fig_DefaultsValue.OneOf_Type? = nil

  public var null: Bool {
    get {
      if case .null(let v)? = type {return v}
      return false
    }
    set {type = .null(newValue)}
  }

  public var boolean: Bool {
    get {
      if case .boolean(let v)? = type {return v}
      return false
    }
    set {type = .boolean(newValue)}
  }

  public var string: String {
    get {
      if case .string(let v)? = type {return v}
      return String()
    }
    set {type = .string(newValue)}
  }

  public var integer: Int64 {
    get {
      if case .integer(let v)? = type {return v}
      return 0
    }
    set {type = .integer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case null(Bool)
    case boolean(Bool)
    case string(String)
    case integer(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_DefaultsValue.OneOf_Type, rhs: Fig_DefaultsValue.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.null, .null): return {
        guard case .null(let l) = lhs, case .null(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolean, .boolean): return {
        guard case .boolean(let l) = lhs, case .boolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integer, .integer): return {
        guard case .integer(let l) = lhs, case .integer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Fig_GetDefaultsPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
}

public struct Fig_GetDefaultsPropertyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: Fig_DefaultsValue {
    get {return _value ?? Fig_DefaultsValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: Fig_DefaultsValue? = nil
}

public struct Fig_UpdateDefaultsPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: Fig_DefaultsValue {
    get {return _value ?? Fig_DefaultsValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: Fig_DefaultsValue? = nil
}

public struct Fig_GetConfigPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
}

public struct Fig_GetConfigPropertyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: String? = nil
}

public struct Fig_UpdateConfigPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
}

public struct Fig_GetSettingsPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
}

public struct Fig_GetSettingsPropertyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jsonBlob: String {
    get {return _jsonBlob ?? String()}
    set {_jsonBlob = newValue}
  }
  /// Returns true if `jsonBlob` has been explicitly set.
  public var hasJsonBlob: Bool {return self._jsonBlob != nil}
  /// Clears the value of `jsonBlob`. Subsequent reads from it will return its default value.
  public mutating func clearJsonBlob() {self._jsonBlob = nil}

  public var isDefault: Bool {
    get {return _isDefault ?? false}
    set {_isDefault = newValue}
  }
  /// Returns true if `isDefault` has been explicitly set.
  public var hasIsDefault: Bool {return self._isDefault != nil}
  /// Clears the value of `isDefault`. Subsequent reads from it will return its default value.
  public mutating func clearIsDefault() {self._isDefault = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jsonBlob: String? = nil
  fileprivate var _isDefault: Bool? = nil
}

public struct Fig_UpdateSettingsPropertyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
}

public struct Fig_TelemetryProperty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_TelemetryAliasRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String {
    get {return _userID ?? String()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userID: String? = nil
}

public struct Fig_TelemetryTrackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: String {
    get {return _event ?? String()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  public var properties: [Fig_TelemetryProperty] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _event: String? = nil
}

public struct Fig_TelemetryIdentifyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var traits: [Fig_TelemetryProperty] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_OnboardingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Fig_OnboardingAction = .installationScript

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_WindowFocusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Fig_FocusAction {
    get {return _type ?? .takeFocus}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: Fig_FocusAction? = nil
}

public struct Fig_OpenInExternalApplicationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _url: String? = nil
}

public struct Fig_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique identifier for the action; not user facing.
  public var identifier: String {
    get {return _identifier ?? String()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  public var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  public mutating func clearIdentifier() {self._identifier = nil}

  /// name of action, will appear in user interfaces.
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// a quick summary of what the action will do
  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var category: String {
    get {return _category ?? String()}
    set {_category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  public var hasCategory: Bool {return self._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  public mutating func clearCategory() {self._category = nil}

  /// when can this action be performed
  public var availability: Fig_ActionAvailability {
    get {return _availability ?? .always}
    set {_availability = newValue}
  }
  /// Returns true if `availability` has been explicitly set.
  public var hasAvailability: Bool {return self._availability != nil}
  /// Clears the value of `availability`. Subsequent reads from it will return its default value.
  public mutating func clearAvailability() {self._availability = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _identifier: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _category: String? = nil
  fileprivate var _availability: Fig_ActionAvailability? = nil
}

public struct Fig_UpdateApplicationPropertiesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var interceptBoundKeystrokes: Bool {
    get {return _interceptBoundKeystrokes ?? false}
    set {_interceptBoundKeystrokes = newValue}
  }
  /// Returns true if `interceptBoundKeystrokes` has been explicitly set.
  public var hasInterceptBoundKeystrokes: Bool {return self._interceptBoundKeystrokes != nil}
  /// Clears the value of `interceptBoundKeystrokes`. Subsequent reads from it will return its default value.
  public mutating func clearInterceptBoundKeystrokes() {self._interceptBoundKeystrokes = nil}

  public var actions: [Fig_Action] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interceptBoundKeystrokes: Bool? = nil
}

public struct Fig_TerminalSessionInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var terminalSessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Fig_TerminalSessionInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var buffer: String {
    get {return _buffer ?? String()}
    set {_buffer = newValue}
  }
  /// Returns true if `buffer` has been explicitly set.
  public var hasBuffer: Bool {return self._buffer != nil}
  /// Clears the value of `buffer`. Subsequent reads from it will return its default value.
  public mutating func clearBuffer() {self._buffer = nil}

  public var cursor: Int64 {
    get {return _cursor ?? 0}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Local_ShellContext? = nil
  fileprivate var _buffer: String? = nil
  fileprivate var _cursor: Int64? = nil
}

public struct Fig_NotificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscribe: Bool {
    get {return _subscribe ?? false}
    set {_subscribe = newValue}
  }
  /// Returns true if `subscribe` has been explicitly set.
  public var hasSubscribe: Bool {return self._subscribe != nil}
  /// Clears the value of `subscribe`. Subsequent reads from it will return its default value.
  public mutating func clearSubscribe() {self._subscribe = nil}

  public var type: Fig_NotificationType {
    get {return _type ?? .all}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subscribe: Bool? = nil
  fileprivate var _type: Fig_NotificationType? = nil
}

public struct Fig_Notification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Fig_Notification.OneOf_Type? = nil

  public var editBufferNotification: Fig_EditBufferChangedNotification {
    get {
      if case .editBufferNotification(let v)? = type {return v}
      return Fig_EditBufferChangedNotification()
    }
    set {type = .editBufferNotification(newValue)}
  }

  public var settingsChangedNotification: Fig_SettingsChangedNotification {
    get {
      if case .settingsChangedNotification(let v)? = type {return v}
      return Fig_SettingsChangedNotification()
    }
    set {type = .settingsChangedNotification(newValue)}
  }

  public var shellPromptReturnedNotification: Fig_ShellPromptReturnedNotification {
    get {
      if case .shellPromptReturnedNotification(let v)? = type {return v}
      return Fig_ShellPromptReturnedNotification()
    }
    set {type = .shellPromptReturnedNotification(newValue)}
  }

  public var locationChangedNotification: Fig_LocationChangedNotification {
    get {
      if case .locationChangedNotification(let v)? = type {return v}
      return Fig_LocationChangedNotification()
    }
    set {type = .locationChangedNotification(newValue)}
  }

  public var processChangeNotification: Fig_ProcessChangedNotification {
    get {
      if case .processChangeNotification(let v)? = type {return v}
      return Fig_ProcessChangedNotification()
    }
    set {type = .processChangeNotification(newValue)}
  }

  public var keybindingPressedNotification: Fig_KeybindingPressedNotification {
    get {
      if case .keybindingPressedNotification(let v)? = type {return v}
      return Fig_KeybindingPressedNotification()
    }
    set {type = .keybindingPressedNotification(newValue)}
  }

  public var windowFocusChangedNotification: Fig_WindowFocusChangedNotification {
    get {
      if case .windowFocusChangedNotification(let v)? = type {return v}
      return Fig_WindowFocusChangedNotification()
    }
    set {type = .windowFocusChangedNotification(newValue)}
  }

  public var historyUpdatedNotification: Fig_HistoryUpdatedNotification {
    get {
      if case .historyUpdatedNotification(let v)? = type {return v}
      return Fig_HistoryUpdatedNotification()
    }
    set {type = .historyUpdatedNotification(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case editBufferNotification(Fig_EditBufferChangedNotification)
    case settingsChangedNotification(Fig_SettingsChangedNotification)
    case shellPromptReturnedNotification(Fig_ShellPromptReturnedNotification)
    case locationChangedNotification(Fig_LocationChangedNotification)
    case processChangeNotification(Fig_ProcessChangedNotification)
    case keybindingPressedNotification(Fig_KeybindingPressedNotification)
    case windowFocusChangedNotification(Fig_WindowFocusChangedNotification)
    case historyUpdatedNotification(Fig_HistoryUpdatedNotification)

  #if !swift(>=4.1)
    public static func ==(lhs: Fig_Notification.OneOf_Type, rhs: Fig_Notification.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.editBufferNotification, .editBufferNotification): return {
        guard case .editBufferNotification(let l) = lhs, case .editBufferNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.settingsChangedNotification, .settingsChangedNotification): return {
        guard case .settingsChangedNotification(let l) = lhs, case .settingsChangedNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shellPromptReturnedNotification, .shellPromptReturnedNotification): return {
        guard case .shellPromptReturnedNotification(let l) = lhs, case .shellPromptReturnedNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.locationChangedNotification, .locationChangedNotification): return {
        guard case .locationChangedNotification(let l) = lhs, case .locationChangedNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.processChangeNotification, .processChangeNotification): return {
        guard case .processChangeNotification(let l) = lhs, case .processChangeNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keybindingPressedNotification, .keybindingPressedNotification): return {
        guard case .keybindingPressedNotification(let l) = lhs, case .keybindingPressedNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowFocusChangedNotification, .windowFocusChangedNotification): return {
        guard case .windowFocusChangedNotification(let l) = lhs, case .windowFocusChangedNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.historyUpdatedNotification, .historyUpdatedNotification): return {
        guard case .historyUpdatedNotification(let l) = lhs, case .historyUpdatedNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Fig_EditBufferChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var cursor: Int32 {
    get {return _cursor ?? 0}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var buffer: String {
    get {return _buffer ?? String()}
    set {_buffer = newValue}
  }
  /// Returns true if `buffer` has been explicitly set.
  public var hasBuffer: Bool {return self._buffer != nil}
  /// Clears the value of `buffer`. Subsequent reads from it will return its default value.
  public mutating func clearBuffer() {self._buffer = nil}

  public var context: Local_ShellContext {
    get {return _context ?? Local_ShellContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionID: String? = nil
  fileprivate var _cursor: Int32? = nil
  fileprivate var _buffer: String? = nil
  fileprivate var _context: Local_ShellContext? = nil
}

public struct Fig_SettingsChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var jsonBlob: String {
    get {return _jsonBlob ?? String()}
    set {_jsonBlob = newValue}
  }
  /// Returns true if `jsonBlob` has been explicitly set.
  public var hasJsonBlob: Bool {return self._jsonBlob != nil}
  /// Clears the value of `jsonBlob`. Subsequent reads from it will return its default value.
  public mutating func clearJsonBlob() {self._jsonBlob = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jsonBlob: String? = nil
}

public struct Fig_ShellPromptReturnedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var shell: Fig_Process {
    get {return _shell ?? Fig_Process()}
    set {_shell = newValue}
  }
  /// Returns true if `shell` has been explicitly set.
  public var hasShell: Bool {return self._shell != nil}
  /// Clears the value of `shell`. Subsequent reads from it will return its default value.
  public mutating func clearShell() {self._shell = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionID: String? = nil
  fileprivate var _shell: Fig_Process? = nil
}

public struct Fig_LocationChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var hostName: String {
    get {return _hostName ?? String()}
    set {_hostName = newValue}
  }
  /// Returns true if `hostName` has been explicitly set.
  public var hasHostName: Bool {return self._hostName != nil}
  /// Clears the value of `hostName`. Subsequent reads from it will return its default value.
  public mutating func clearHostName() {self._hostName = nil}

  public var userName: String {
    get {return _userName ?? String()}
    set {_userName = newValue}
  }
  /// Returns true if `userName` has been explicitly set.
  public var hasUserName: Bool {return self._userName != nil}
  /// Clears the value of `userName`. Subsequent reads from it will return its default value.
  public mutating func clearUserName() {self._userName = nil}

  public var directory: String {
    get {return _directory ?? String()}
    set {_directory = newValue}
  }
  /// Returns true if `directory` has been explicitly set.
  public var hasDirectory: Bool {return self._directory != nil}
  /// Clears the value of `directory`. Subsequent reads from it will return its default value.
  public mutating func clearDirectory() {self._directory = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionID: String? = nil
  fileprivate var _hostName: String? = nil
  fileprivate var _userName: String? = nil
  fileprivate var _directory: String? = nil
}

public struct Fig_ProcessChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var newProcess: Fig_Process {
    get {return _newProcess ?? Fig_Process()}
    set {_newProcess = newValue}
  }
  /// Returns true if `newProcess` has been explicitly set.
  public var hasNewProcess: Bool {return self._newProcess != nil}
  /// Clears the value of `newProcess`. Subsequent reads from it will return its default value.
  public mutating func clearNewProcess() {self._newProcess = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionID: String? = nil
  fileprivate var _newProcess: Fig_Process? = nil
}

public struct Fig_KeybindingPressedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keypress: Fig_KeyEvent {
    get {return _keypress ?? Fig_KeyEvent()}
    set {_keypress = newValue}
  }
  /// Returns true if `keypress` has been explicitly set.
  public var hasKeypress: Bool {return self._keypress != nil}
  /// Clears the value of `keypress`. Subsequent reads from it will return its default value.
  public mutating func clearKeypress() {self._keypress = nil}

  public var action: String {
    get {return _action ?? String()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keypress: Fig_KeyEvent? = nil
  fileprivate var _action: String? = nil
}

public struct Fig_WindowFocusChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var window: Fig_Window {
    get {return _window ?? Fig_Window()}
    set {_window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return self._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {self._window = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _window: Fig_Window? = nil
}

public struct Fig_HistoryUpdatedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: String {
    get {return _command ?? String()}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() {self._command = nil}

  /// the name of the process
  public var processName: String {
    get {return _processName ?? String()}
    set {_processName = newValue}
  }
  /// Returns true if `processName` has been explicitly set.
  public var hasProcessName: Bool {return self._processName != nil}
  /// Clears the value of `processName`. Subsequent reads from it will return its default value.
  public mutating func clearProcessName() {self._processName = nil}

  /// the directory where the user ran the command
  public var currentWorkingDirectory: String {
    get {return _currentWorkingDirectory ?? String()}
    set {_currentWorkingDirectory = newValue}
  }
  /// Returns true if `currentWorkingDirectory` has been explicitly set.
  public var hasCurrentWorkingDirectory: Bool {return self._currentWorkingDirectory != nil}
  /// Clears the value of `currentWorkingDirectory`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentWorkingDirectory() {self._currentWorkingDirectory = nil}

  /// the value of $TERM_SESSION_ID
  public var sessionID: String {
    get {return _sessionID ?? String()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var hostname: String {
    get {return _hostname ?? String()}
    set {_hostname = newValue}
  }
  /// Returns true if `hostname` has been explicitly set.
  public var hasHostname: Bool {return self._hostname != nil}
  /// Clears the value of `hostname`. Subsequent reads from it will return its default value.
  public mutating func clearHostname() {self._hostname = nil}

  /// the exit code of the command
  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _command: String? = nil
  fileprivate var _processName: String? = nil
  fileprivate var _currentWorkingDirectory: String? = nil
  fileprivate var _sessionID: String? = nil
  fileprivate var _hostname: String? = nil
  fileprivate var _exitCode: Int32? = nil
}

//// Constants
/// Can be found under fig.constants. Certain legacy constants are included at the top-level for backwards compatibility.
public struct Fig_Constants {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the current version of Fig
  public var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  /// the current build of Fig 
  public var build: String {
    get {return _build ?? String()}
    set {_build = newValue}
  }
  /// Returns true if `build` has been explicitly set.
  public var hasBuild: Bool {return self._build != nil}
  /// Clears the value of `build`. Subsequent reads from it will return its default value.
  public mutating func clearBuild() {self._build = nil}

  /// the path to the figcli executable
  public var cli: String {
    get {return _cli ?? String()}
    set {_cli = newValue}
  }
  /// Returns true if `cli` has been explicitly set.
  public var hasCli: Bool {return self._cli != nil}
  /// Clears the value of `cli`. Subsequent reads from it will return its default value.
  public mutating func clearCli() {self._cli = nil}

  /// the filepath of the macOS bundle
  public var bundlePath: String {
    get {return _bundlePath ?? String()}
    set {_bundlePath = newValue}
  }
  /// Returns true if `bundlePath` has been explicitly set.
  public var hasBundlePath: Bool {return self._bundlePath != nil}
  /// Clears the value of `bundlePath`. Subsequent reads from it will return its default value.
  public mutating func clearBundlePath() {self._bundlePath = nil}

  /// the remote URL where apps are loaded from
  public var remote: String {
    get {return _remote ?? String()}
    set {_remote = newValue}
  }
  /// Returns true if `remote` has been explicitly set.
  public var hasRemote: Bool {return self._remote != nil}
  /// Clears the value of `remote`. Subsequent reads from it will return its default value.
  public mutating func clearRemote() {self._remote = nil}

  /// the user's home directory 
  public var home: String {
    get {return _home ?? String()}
    set {_home = newValue}
  }
  /// Returns true if `home` has been explicitly set.
  public var hasHome: Bool {return self._home != nil}
  /// Clears the value of `home`. Subsequent reads from it will return its default value.
  public mutating func clearHome() {self._home = nil}

  /// the user's name (equivalent to running `whoami`)
  public var user: String {
    get {return _user ?? String()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  /// the default macOS $PATH
  public var defaultPath: String {
    get {return _defaultPath ?? String()}
    set {_defaultPath = newValue}
  }
  /// Returns true if `defaultPath` has been explicitly set.
  public var hasDefaultPath: Bool {return self._defaultPath != nil}
  /// Clears the value of `defaultPath`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultPath() {self._defaultPath = nil}

  public var jsonMessageRecieved: String {
    get {return _jsonMessageRecieved ?? String()}
    set {_jsonMessageRecieved = newValue}
  }
  /// Returns true if `jsonMessageRecieved` has been explicitly set.
  public var hasJsonMessageRecieved: Bool {return self._jsonMessageRecieved != nil}
  /// Clears the value of `jsonMessageRecieved`. Subsequent reads from it will return its default value.
  public mutating func clearJsonMessageRecieved() {self._jsonMessageRecieved = nil}

  public var jsonMessageHandler: String {
    get {return _jsonMessageHandler ?? String()}
    set {_jsonMessageHandler = newValue}
  }
  /// Returns true if `jsonMessageHandler` has been explicitly set.
  public var hasJsonMessageHandler: Bool {return self._jsonMessageHandler != nil}
  /// Clears the value of `jsonMessageHandler`. Subsequent reads from it will return its default value.
  public mutating func clearJsonMessageHandler() {self._jsonMessageHandler = nil}

  public var protoMessageRecieved: String {
    get {return _protoMessageRecieved ?? String()}
    set {_protoMessageRecieved = newValue}
  }
  /// Returns true if `protoMessageRecieved` has been explicitly set.
  public var hasProtoMessageRecieved: Bool {return self._protoMessageRecieved != nil}
  /// Clears the value of `protoMessageRecieved`. Subsequent reads from it will return its default value.
  public mutating func clearProtoMessageRecieved() {self._protoMessageRecieved = nil}

  public var protoMessageHandler: String {
    get {return _protoMessageHandler ?? String()}
    set {_protoMessageHandler = newValue}
  }
  /// Returns true if `protoMessageHandler` has been explicitly set.
  public var hasProtoMessageHandler: Bool {return self._protoMessageHandler != nil}
  /// Clears the value of `protoMessageHandler`. Subsequent reads from it will return its default value.
  public mutating func clearProtoMessageHandler() {self._protoMessageHandler = nil}

  /// a comma-separated list of all themes
  public var themes: String {
    get {return _themes ?? String()}
    set {_themes = newValue}
  }
  /// Returns true if `themes` has been explicitly set.
  public var hasThemes: Bool {return self._themes != nil}
  /// Clears the value of `themes`. Subsequent reads from it will return its default value.
  public mutating func clearThemes() {self._themes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: String? = nil
  fileprivate var _build: String? = nil
  fileprivate var _cli: String? = nil
  fileprivate var _bundlePath: String? = nil
  fileprivate var _remote: String? = nil
  fileprivate var _home: String? = nil
  fileprivate var _user: String? = nil
  fileprivate var _defaultPath: String? = nil
  fileprivate var _jsonMessageRecieved: String? = nil
  fileprivate var _jsonMessageHandler: String? = nil
  fileprivate var _protoMessageRecieved: String? = nil
  fileprivate var _protoMessageHandler: String? = nil
  fileprivate var _themes: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fig"

extension Fig_Modifiers: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTROL"),
    1: .same(proto: "OPTION"),
    2: .same(proto: "COMMAND"),
    3: .same(proto: "SHIFT"),
    4: .same(proto: "FUNCTION"),
    5: .same(proto: "NUMPAD"),
  ]
}

extension Fig_OnboardingAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTALLATION_SCRIPT"),
    1: .same(proto: "PROMPT_FOR_ACCESSIBILITY_PERMISSION"),
    3: .same(proto: "LAUNCH_SHELL_ONBOARDING"),
    4: .same(proto: "UNINSTALL"),
  ]
}

extension Fig_FocusAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TAKE_FOCUS"),
    1: .same(proto: "RETURN_FOCUS"),
  ]
}

extension Fig_ActionAvailability: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALWAYS"),
    1: .same(proto: "WHEN_FOCUSED"),
    2: .same(proto: "WHEN_VISIBLE"),
    3: .same(proto: "WHEN_HIDDEN"),
  ]
}

extension Fig_NotificationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "NOTIFY_ON_EDITBUFFFER_CHANGE"),
    2: .same(proto: "NOTIFY_ON_SETTINGS_CHANGE"),
    3: .same(proto: "NOTIFY_ON_PROMPT"),
    4: .same(proto: "NOTIFY_ON_LOCATION_CHANGE"),
    5: .same(proto: "NOTIFY_ON_PROCESS_CHANGED"),
    6: .same(proto: "NOTIFY_ON_KEYBINDING_PRESSED"),
    7: .same(proto: "NOTIFY_ON_FOCUS_CHANGED"),
    8: .same(proto: "NOTIFY_ON_HISTORY_UPDATED"),
  ]
}

extension Fig_ClientOriginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientOriginatedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    101: .standard(proto: "position_window_request"),
    102: .standard(proto: "pseudoterminal_execute_request"),
    103: .standard(proto: "pseudoterminal_write_request"),
    104: .standard(proto: "read_file_request"),
    105: .standard(proto: "write_file_request"),
    106: .standard(proto: "contents_of_directory_request"),
    107: .standard(proto: "notification_request"),
    108: .standard(proto: "get_settings_property_request"),
    109: .standard(proto: "update_settings_property_request"),
    110: .standard(proto: "insert_text_request"),
    111: .standard(proto: "update_application_properties_request"),
    112: .standard(proto: "destination_of_symbolic_link_request"),
    113: .standard(proto: "get_defaults_property_request"),
    114: .standard(proto: "update_defaults_property_request"),
    115: .standard(proto: "telemetry_alias_request"),
    116: .standard(proto: "telemetry_identify_request"),
    117: .standard(proto: "telemetry_track_request"),
    118: .standard(proto: "onboarding_request"),
    119: .standard(proto: "window_focus_request"),
    120: .standard(proto: "open_in_external_application_request"),
    121: .standard(proto: "get_config_property_request"),
    122: .standard(proto: "update_config_property_request"),
    123: .standard(proto: "pseudoterminal_restart_request"),
    124: .standard(proto: "terminal_session_info_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 101: try {
        var v: Fig_PositionWindowRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .positionWindowRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .positionWindowRequest(v)
        }
      }()
      case 102: try {
        var v: Fig_PseudoterminalExecuteRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .pseudoterminalExecuteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .pseudoterminalExecuteRequest(v)
        }
      }()
      case 103: try {
        var v: Fig_PseudoterminalWriteRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .pseudoterminalWriteRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .pseudoterminalWriteRequest(v)
        }
      }()
      case 104: try {
        var v: Fig_ReadFileRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .readFileRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .readFileRequest(v)
        }
      }()
      case 105: try {
        var v: Fig_WriteFileRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .writeFileRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .writeFileRequest(v)
        }
      }()
      case 106: try {
        var v: Fig_ContentsOfDirectoryRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .contentsOfDirectoryRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .contentsOfDirectoryRequest(v)
        }
      }()
      case 107: try {
        var v: Fig_NotificationRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .notificationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .notificationRequest(v)
        }
      }()
      case 108: try {
        var v: Fig_GetSettingsPropertyRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getSettingsPropertyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getSettingsPropertyRequest(v)
        }
      }()
      case 109: try {
        var v: Fig_UpdateSettingsPropertyRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .updateSettingsPropertyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .updateSettingsPropertyRequest(v)
        }
      }()
      case 110: try {
        var v: Fig_InsertTextRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .insertTextRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .insertTextRequest(v)
        }
      }()
      case 111: try {
        var v: Fig_UpdateApplicationPropertiesRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .updateApplicationPropertiesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .updateApplicationPropertiesRequest(v)
        }
      }()
      case 112: try {
        var v: Fig_DestinationOfSymbolicLinkRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .destinationOfSymbolicLinkRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .destinationOfSymbolicLinkRequest(v)
        }
      }()
      case 113: try {
        var v: Fig_GetDefaultsPropertyRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getDefaultsPropertyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getDefaultsPropertyRequest(v)
        }
      }()
      case 114: try {
        var v: Fig_UpdateDefaultsPropertyRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .updateDefaultsPropertyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .updateDefaultsPropertyRequest(v)
        }
      }()
      case 115: try {
        var v: Fig_TelemetryAliasRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .telemetryAliasRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .telemetryAliasRequest(v)
        }
      }()
      case 116: try {
        var v: Fig_TelemetryIdentifyRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .telemetryIdentifyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .telemetryIdentifyRequest(v)
        }
      }()
      case 117: try {
        var v: Fig_TelemetryTrackRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .telemetryTrackRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .telemetryTrackRequest(v)
        }
      }()
      case 118: try {
        var v: Fig_OnboardingRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .onboardingRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .onboardingRequest(v)
        }
      }()
      case 119: try {
        var v: Fig_WindowFocusRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .windowFocusRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .windowFocusRequest(v)
        }
      }()
      case 120: try {
        var v: Fig_OpenInExternalApplicationRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .openInExternalApplicationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .openInExternalApplicationRequest(v)
        }
      }()
      case 121: try {
        var v: Fig_GetConfigPropertyRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getConfigPropertyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getConfigPropertyRequest(v)
        }
      }()
      case 122: try {
        var v: Fig_UpdateConfigPropertyRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .updateConfigPropertyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .updateConfigPropertyRequest(v)
        }
      }()
      case 123: try {
        var v: Fig_PseudoterminalRestartRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .pseudoterminalRestartRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .pseudoterminalRestartRequest(v)
        }
      }()
      case 124: try {
        var v: Fig_TerminalSessionInfoRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .terminalSessionInfoRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .terminalSessionInfoRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    switch self.submessage {
    case .positionWindowRequest?: try {
      guard case .positionWindowRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .pseudoterminalExecuteRequest?: try {
      guard case .pseudoterminalExecuteRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .pseudoterminalWriteRequest?: try {
      guard case .pseudoterminalWriteRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .readFileRequest?: try {
      guard case .readFileRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .writeFileRequest?: try {
      guard case .writeFileRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .contentsOfDirectoryRequest?: try {
      guard case .contentsOfDirectoryRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .notificationRequest?: try {
      guard case .notificationRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .getSettingsPropertyRequest?: try {
      guard case .getSettingsPropertyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .updateSettingsPropertyRequest?: try {
      guard case .updateSettingsPropertyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .insertTextRequest?: try {
      guard case .insertTextRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .updateApplicationPropertiesRequest?: try {
      guard case .updateApplicationPropertiesRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .destinationOfSymbolicLinkRequest?: try {
      guard case .destinationOfSymbolicLinkRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .getDefaultsPropertyRequest?: try {
      guard case .getDefaultsPropertyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .updateDefaultsPropertyRequest?: try {
      guard case .updateDefaultsPropertyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case .telemetryAliasRequest?: try {
      guard case .telemetryAliasRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
    }()
    case .telemetryIdentifyRequest?: try {
      guard case .telemetryIdentifyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
    }()
    case .telemetryTrackRequest?: try {
      guard case .telemetryTrackRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
    }()
    case .onboardingRequest?: try {
      guard case .onboardingRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
    }()
    case .windowFocusRequest?: try {
      guard case .windowFocusRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
    }()
    case .openInExternalApplicationRequest?: try {
      guard case .openInExternalApplicationRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
    }()
    case .getConfigPropertyRequest?: try {
      guard case .getConfigPropertyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
    }()
    case .updateConfigPropertyRequest?: try {
      guard case .updateConfigPropertyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
    }()
    case .pseudoterminalRestartRequest?: try {
      guard case .pseudoterminalRestartRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
    }()
    case .terminalSessionInfoRequest?: try {
      guard case .terminalSessionInfoRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ClientOriginatedMessage, rhs: Fig_ClientOriginatedMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.submessage != rhs.submessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ServerOriginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerOriginatedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
    100: .standard(proto: "position_window_response"),
    101: .standard(proto: "pseudoterminal_execute_response"),
    102: .standard(proto: "read_file_response"),
    103: .standard(proto: "contents_of_directory_response"),
    104: .standard(proto: "get_settings_property_response"),
    105: .standard(proto: "destination_of_symbolic_link_response"),
    106: .standard(proto: "get_defaults_property_response"),
    107: .standard(proto: "get_config_property_response"),
    108: .standard(proto: "terminal_session_info_response"),
    1000: .same(proto: "notification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.submessage != nil {try decoder.handleConflictingOneOf()}
          self.submessage = .error(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.submessage != nil {try decoder.handleConflictingOneOf()}
          self.submessage = .success(v)
        }
      }()
      case 100: try {
        var v: Fig_PositionWindowResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .positionWindowResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .positionWindowResponse(v)
        }
      }()
      case 101: try {
        var v: Fig_PseudoterminalExecuteResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .pseudoterminalExecuteResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .pseudoterminalExecuteResponse(v)
        }
      }()
      case 102: try {
        var v: Fig_ReadFileResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .readFileResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .readFileResponse(v)
        }
      }()
      case 103: try {
        var v: Fig_ContentsOfDirectoryResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .contentsOfDirectoryResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .contentsOfDirectoryResponse(v)
        }
      }()
      case 104: try {
        var v: Fig_GetSettingsPropertyResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getSettingsPropertyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getSettingsPropertyResponse(v)
        }
      }()
      case 105: try {
        var v: Fig_DestinationOfSymbolicLinkResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .destinationOfSymbolicLinkResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .destinationOfSymbolicLinkResponse(v)
        }
      }()
      case 106: try {
        var v: Fig_GetDefaultsPropertyResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getDefaultsPropertyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getDefaultsPropertyResponse(v)
        }
      }()
      case 107: try {
        var v: Fig_GetConfigPropertyResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getConfigPropertyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getConfigPropertyResponse(v)
        }
      }()
      case 108: try {
        var v: Fig_TerminalSessionInfoResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .terminalSessionInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .terminalSessionInfoResponse(v)
        }
      }()
      case 1000: try {
        var v: Fig_Notification?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .notification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .notification(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    switch self.submessage {
    case .error?: try {
      guard case .error(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .positionWindowResponse?: try {
      guard case .positionWindowResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .pseudoterminalExecuteResponse?: try {
      guard case .pseudoterminalExecuteResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .readFileResponse?: try {
      guard case .readFileResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .contentsOfDirectoryResponse?: try {
      guard case .contentsOfDirectoryResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .getSettingsPropertyResponse?: try {
      guard case .getSettingsPropertyResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .destinationOfSymbolicLinkResponse?: try {
      guard case .destinationOfSymbolicLinkResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .getDefaultsPropertyResponse?: try {
      guard case .getDefaultsPropertyResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .getConfigPropertyResponse?: try {
      guard case .getConfigPropertyResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .terminalSessionInfoResponse?: try {
      guard case .terminalSessionInfoResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .notification?: try {
      guard case .notification(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ServerOriginatedMessage, rhs: Fig_ServerOriginatedMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.submessage != rhs.submessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Point"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Point, rhs: Fig_Point) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Size"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Size, rhs: Fig_Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Frame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Frame, rhs: Fig_Frame) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_EnvironmentVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvironmentVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_EnvironmentVariable, rhs: Fig_EnvironmentVariable) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Process: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Process"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "executable"),
    3: .same(proto: "directory"),
    4: .same(proto: "env"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._pid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._executable) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._directory) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.env) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._executable {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._directory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.env.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.env, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Process, rhs: Fig_Process) -> Bool {
    if lhs._pid != rhs._pid {return false}
    if lhs._executable != rhs._executable {return false}
    if lhs._directory != rhs._directory {return false}
    if lhs.env != rhs.env {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_FilePath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilePath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "relative_to"),
    3: .standard(proto: "expand_tilde_in_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._relativeTo) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._expandTildeInPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._relativeTo {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._expandTildeInPath {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_FilePath, rhs: Fig_FilePath) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs._relativeTo != rhs._relativeTo {return false}
    if lhs._expandTildeInPath != rhs._expandTildeInPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_KeyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appleKeyCode"),
    2: .same(proto: "characters"),
    3: .standard(proto: "characters_ignoring_modifiers"),
    4: .same(proto: "modifiers"),
    5: .standard(proto: "is_repeat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._appleKeyCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._characters) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._charactersIgnoringModifiers) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.modifiers) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isRepeat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._appleKeyCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._characters {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._charactersIgnoringModifiers {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.modifiers.isEmpty {
      try visitor.visitPackedEnumField(value: self.modifiers, fieldNumber: 4)
    }
    try { if let v = self._isRepeat {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_KeyEvent, rhs: Fig_KeyEvent) -> Bool {
    if lhs._appleKeyCode != rhs._appleKeyCode {return false}
    if lhs._characters != rhs._characters {return false}
    if lhs._charactersIgnoringModifiers != rhs._charactersIgnoringModifiers {return false}
    if lhs.modifiers != rhs.modifiers {return false}
    if lhs._isRepeat != rhs._isRepeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Screen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Screen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frame"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._frame) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._frame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Screen, rhs: Fig_Screen) -> Bool {
    if lhs._frame != rhs._frame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Session"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "frontmost_process"),
    3: .same(proto: "env"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._frontmostProcess) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.env) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._frontmostProcess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.env.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.env, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Session, rhs: Fig_Session) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._frontmostProcess != rhs._frontmostProcess {return false}
    if lhs.env != rhs.env {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Application: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Application"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_identifier"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._bundleIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bundleIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Application, rhs: Fig_Application) -> Bool {
    if lhs._bundleIdentifier != rhs._bundleIdentifier {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Window: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Window"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "window_id"),
    2: .same(proto: "frame"),
    3: .standard(proto: "current_session"),
    4: .same(proto: "app"),
    5: .standard(proto: "current_screen"),
  ]

  fileprivate class _StorageClass {
    var _windowID: String? = nil
    var _frame: Fig_Frame? = nil
    var _currentSession: Fig_Session? = nil
    var _app: Fig_Application? = nil
    var _currentScreen: Fig_Screen? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _windowID = source._windowID
      _frame = source._frame
      _currentSession = source._currentSession
      _app = source._app
      _currentScreen = source._currentScreen
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._windowID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._frame) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._currentSession) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._app) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._currentScreen) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._windowID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._frame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._currentSession {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._app {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._currentScreen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Window, rhs: Fig_Window) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._windowID != rhs_storage._windowID {return false}
        if _storage._frame != rhs_storage._frame {return false}
        if _storage._currentSession != rhs_storage._currentSession {return false}
        if _storage._app != rhs_storage._app {return false}
        if _storage._currentScreen != rhs_storage._currentScreen {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_TextUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insertion"),
    2: .same(proto: "deletion"),
    3: .same(proto: "offset"),
    4: .same(proto: "immediate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._insertion) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._deletion) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._offset) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._immediate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._insertion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deletion {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._immediate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_TextUpdate, rhs: Fig_TextUpdate) -> Bool {
    if lhs._insertion != rhs._insertion {return false}
    if lhs._deletion != rhs._deletion {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._immediate != rhs._immediate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_InsertTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InsertTextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 2: try {
        var v: Fig_TextUpdate?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .update(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .update?: try {
      guard case .update(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_InsertTextRequest, rhs: Fig_InsertTextRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PseudoterminalWriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PseudoterminalWriteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "octal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.input != nil {try decoder.handleConflictingOneOf()}
          self.input = .text(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.input != nil {try decoder.handleConflictingOneOf()}
          self.input = .octal(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.input {
    case .text?: try {
      guard case .text(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .octal?: try {
      guard case .octal(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_PseudoterminalWriteRequest, rhs: Fig_PseudoterminalWriteRequest) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PseudoterminalExecuteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PseudoterminalExecuteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "workingDirectory"),
    3: .same(proto: "backgroundJob"),
    4: .same(proto: "isPipelined"),
    5: .same(proto: "env"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._workingDirectory) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._backgroundJob) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isPipelined) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.env) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 1)
    }
    try { if let v = self._workingDirectory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._backgroundJob {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isPipelined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    if !self.env.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.env, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_PseudoterminalExecuteRequest, rhs: Fig_PseudoterminalExecuteRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs._workingDirectory != rhs._workingDirectory {return false}
    if lhs._backgroundJob != rhs._backgroundJob {return false}
    if lhs._isPipelined != rhs._isPipelined {return false}
    if lhs.env != rhs.env {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PseudoterminalExecuteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PseudoterminalExecuteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdout"),
    2: .same(proto: "stderr"),
    3: .same(proto: "exitCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stdout) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._stderr) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.stdout.isEmpty {
      try visitor.visitSingularStringField(value: self.stdout, fieldNumber: 1)
    }
    try { if let v = self._stderr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_PseudoterminalExecuteResponse, rhs: Fig_PseudoterminalExecuteResponse) -> Bool {
    if lhs.stdout != rhs.stdout {return false}
    if lhs._stderr != rhs._stderr {return false}
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PseudoterminalRestartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PseudoterminalRestartRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_PseudoterminalRestartRequest, rhs: Fig_PseudoterminalRestartRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PositionWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionWindowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "anchor"),
    2: .same(proto: "size"),
    3: .same(proto: "dryrun"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._anchor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._dryrun) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._anchor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dryrun {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_PositionWindowRequest, rhs: Fig_PositionWindowRequest) -> Bool {
    if lhs._anchor != rhs._anchor {return false}
    if lhs._size != rhs._size {return false}
    if lhs._dryrun != rhs._dryrun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PositionWindowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PositionWindowResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isAbove"),
    2: .same(proto: "isClipped"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isAbove) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isClipped) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isAbove {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isClipped {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_PositionWindowResponse, rhs: Fig_PositionWindowResponse) -> Bool {
    if lhs._isAbove != rhs._isAbove {return false}
    if lhs._isClipped != rhs._isClipped {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ReadFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadFileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "isBinaryFile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isBinaryFile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isBinaryFile {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ReadFileRequest, rhs: Fig_ReadFileRequest) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs._isBinaryFile != rhs._isBinaryFile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ReadFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadFileResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .data(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .data?: try {
      guard case .data(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ReadFileResponse, rhs: Fig_ReadFileResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_WriteFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteFileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "text"),
    3: .same(proto: "binary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .text(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .binary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.data {
    case .text?: try {
      guard case .text(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .binary?: try {
      guard case .binary(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_WriteFileRequest, rhs: Fig_WriteFileRequest) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ContentsOfDirectoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentsOfDirectoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "directory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._directory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._directory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ContentsOfDirectoryRequest, rhs: Fig_ContentsOfDirectoryRequest) -> Bool {
    if lhs._directory != rhs._directory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ContentsOfDirectoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentsOfDirectoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.fileNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fileNames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ContentsOfDirectoryResponse, rhs: Fig_ContentsOfDirectoryResponse) -> Bool {
    if lhs.fileNames != rhs.fileNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_DestinationOfSymbolicLinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DestinationOfSymbolicLinkRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_DestinationOfSymbolicLinkRequest, rhs: Fig_DestinationOfSymbolicLinkRequest) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_DestinationOfSymbolicLinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DestinationOfSymbolicLinkResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._destination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_DestinationOfSymbolicLinkResponse, rhs: Fig_DestinationOfSymbolicLinkResponse) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_DefaultsValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DefaultsValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "null"),
    2: .same(proto: "boolean"),
    3: .same(proto: "string"),
    4: .same(proto: "integer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .null(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .boolean(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .string(v)
        }
      }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .integer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .null?: try {
      guard case .null(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .boolean?: try {
      guard case .boolean(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .string?: try {
      guard case .string(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .integer?: try {
      guard case .integer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_DefaultsValue, rhs: Fig_DefaultsValue) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_GetDefaultsPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDefaultsPropertyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_GetDefaultsPropertyRequest, rhs: Fig_GetDefaultsPropertyRequest) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_GetDefaultsPropertyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDefaultsPropertyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_GetDefaultsPropertyResponse, rhs: Fig_GetDefaultsPropertyResponse) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_UpdateDefaultsPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDefaultsPropertyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_UpdateDefaultsPropertyRequest, rhs: Fig_UpdateDefaultsPropertyRequest) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_GetConfigPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfigPropertyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_GetConfigPropertyRequest, rhs: Fig_GetConfigPropertyRequest) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_GetConfigPropertyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfigPropertyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_GetConfigPropertyResponse, rhs: Fig_GetConfigPropertyResponse) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_UpdateConfigPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConfigPropertyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_UpdateConfigPropertyRequest, rhs: Fig_UpdateConfigPropertyRequest) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_GetSettingsPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSettingsPropertyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_GetSettingsPropertyRequest, rhs: Fig_GetSettingsPropertyRequest) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_GetSettingsPropertyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSettingsPropertyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonBlob"),
    2: .same(proto: "isDefault"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._jsonBlob) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isDefault) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._jsonBlob {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isDefault {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_GetSettingsPropertyResponse, rhs: Fig_GetSettingsPropertyResponse) -> Bool {
    if lhs._jsonBlob != rhs._jsonBlob {return false}
    if lhs._isDefault != rhs._isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_UpdateSettingsPropertyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateSettingsPropertyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_UpdateSettingsPropertyRequest, rhs: Fig_UpdateSettingsPropertyRequest) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_TelemetryProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TelemetryProperty"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_TelemetryProperty, rhs: Fig_TelemetryProperty) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_TelemetryAliasRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TelemetryAliasRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_TelemetryAliasRequest, rhs: Fig_TelemetryAliasRequest) -> Bool {
    if lhs._userID != rhs._userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_TelemetryTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TelemetryTrackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._event) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._event {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_TelemetryTrackRequest, rhs: Fig_TelemetryTrackRequest) -> Bool {
    if lhs._event != rhs._event {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_TelemetryIdentifyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TelemetryIdentifyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "traits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.traits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traits, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_TelemetryIdentifyRequest, rhs: Fig_TelemetryIdentifyRequest) -> Bool {
    if lhs.traits != rhs.traits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_OnboardingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnboardingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .installationScript {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_OnboardingRequest, rhs: Fig_OnboardingRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_WindowFocusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WindowFocusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_WindowFocusRequest, rhs: Fig_WindowFocusRequest) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_OpenInExternalApplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenInExternalApplicationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_OpenInExternalApplicationRequest, rhs: Fig_OpenInExternalApplicationRequest) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "category"),
    5: .same(proto: "availability"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._category) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._availability) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._category {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._availability {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Action, rhs: Fig_Action) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._name != rhs._name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._category != rhs._category {return false}
    if lhs._availability != rhs._availability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_UpdateApplicationPropertiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateApplicationPropertiesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interceptBoundKeystrokes"),
    2: .same(proto: "actions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._interceptBoundKeystrokes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._interceptBoundKeystrokes {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_UpdateApplicationPropertiesRequest, rhs: Fig_UpdateApplicationPropertiesRequest) -> Bool {
    if lhs._interceptBoundKeystrokes != rhs._interceptBoundKeystrokes {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_TerminalSessionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalSessionInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "terminal_session_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.terminalSessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.terminalSessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.terminalSessionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_TerminalSessionInfoRequest, rhs: Fig_TerminalSessionInfoRequest) -> Bool {
    if lhs.terminalSessionID != rhs.terminalSessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_TerminalSessionInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminalSessionInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "buffer"),
    3: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._buffer) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._buffer {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cursor {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_TerminalSessionInfoResponse, rhs: Fig_TerminalSessionInfoResponse) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs._buffer != rhs._buffer {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_NotificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscribe"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._subscribe) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscribe {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_NotificationRequest, rhs: Fig_NotificationRequest) -> Bool {
    if lhs._subscribe != rhs._subscribe {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Notification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "edit_buffer_notification"),
    2: .standard(proto: "settings_changed_notification"),
    3: .standard(proto: "shell_prompt_returned_notification"),
    4: .standard(proto: "location_changed_notification"),
    5: .standard(proto: "process_change_notification"),
    6: .standard(proto: "keybinding_pressed_notification"),
    7: .standard(proto: "window_focus_changed_notification"),
    8: .standard(proto: "history_updated_notification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Fig_EditBufferChangedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .editBufferNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .editBufferNotification(v)
        }
      }()
      case 2: try {
        var v: Fig_SettingsChangedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .settingsChangedNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .settingsChangedNotification(v)
        }
      }()
      case 3: try {
        var v: Fig_ShellPromptReturnedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .shellPromptReturnedNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .shellPromptReturnedNotification(v)
        }
      }()
      case 4: try {
        var v: Fig_LocationChangedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .locationChangedNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .locationChangedNotification(v)
        }
      }()
      case 5: try {
        var v: Fig_ProcessChangedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .processChangeNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .processChangeNotification(v)
        }
      }()
      case 6: try {
        var v: Fig_KeybindingPressedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .keybindingPressedNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .keybindingPressedNotification(v)
        }
      }()
      case 7: try {
        var v: Fig_WindowFocusChangedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .windowFocusChangedNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .windowFocusChangedNotification(v)
        }
      }()
      case 8: try {
        var v: Fig_HistoryUpdatedNotification?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .historyUpdatedNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .historyUpdatedNotification(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .editBufferNotification?: try {
      guard case .editBufferNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .settingsChangedNotification?: try {
      guard case .settingsChangedNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .shellPromptReturnedNotification?: try {
      guard case .shellPromptReturnedNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .locationChangedNotification?: try {
      guard case .locationChangedNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .processChangeNotification?: try {
      guard case .processChangeNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .keybindingPressedNotification?: try {
      guard case .keybindingPressedNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .windowFocusChangedNotification?: try {
      guard case .windowFocusChangedNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .historyUpdatedNotification?: try {
      guard case .historyUpdatedNotification(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Notification, rhs: Fig_Notification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_EditBufferChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditBufferChangedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "cursor"),
    3: .same(proto: "buffer"),
    4: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._cursor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._buffer) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cursor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._buffer {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_EditBufferChangedNotification, rhs: Fig_EditBufferChangedNotification) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs._buffer != rhs._buffer {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_SettingsChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SettingsChangedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jsonBlob"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._jsonBlob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._jsonBlob {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_SettingsChangedNotification, rhs: Fig_SettingsChangedNotification) -> Bool {
    if lhs._jsonBlob != rhs._jsonBlob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ShellPromptReturnedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShellPromptReturnedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "shell"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shell) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ShellPromptReturnedNotification, rhs: Fig_ShellPromptReturnedNotification) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._shell != rhs._shell {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_LocationChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocationChangedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "host_name"),
    3: .standard(proto: "user_name"),
    4: .same(proto: "directory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._hostName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._userName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._directory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hostName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._userName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._directory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_LocationChangedNotification, rhs: Fig_LocationChangedNotification) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._hostName != rhs._hostName {return false}
    if lhs._userName != rhs._userName {return false}
    if lhs._directory != rhs._directory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ProcessChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProcessChangedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .standard(proto: "new_process"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newProcess) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newProcess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_ProcessChangedNotification, rhs: Fig_ProcessChangedNotification) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._newProcess != rhs._newProcess {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_KeybindingPressedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeybindingPressedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keypress"),
    2: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keypress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keypress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_KeybindingPressedNotification, rhs: Fig_KeybindingPressedNotification) -> Bool {
    if lhs._keypress != rhs._keypress {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_WindowFocusChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WindowFocusChangedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "window"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._window) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._window {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_WindowFocusChangedNotification, rhs: Fig_WindowFocusChangedNotification) -> Bool {
    if lhs._window != rhs._window {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_HistoryUpdatedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryUpdatedNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .standard(proto: "process_name"),
    3: .standard(proto: "current_working_directory"),
    4: .standard(proto: "session_id"),
    5: .same(proto: "hostname"),
    6: .standard(proto: "exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._processName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._currentWorkingDirectory) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._sessionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._hostname) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._processName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._currentWorkingDirectory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sessionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._hostname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_HistoryUpdatedNotification, rhs: Fig_HistoryUpdatedNotification) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs._processName != rhs._processName {return false}
    if lhs._currentWorkingDirectory != rhs._currentWorkingDirectory {return false}
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs._hostname != rhs._hostname {return false}
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Constants: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Constants"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "build"),
    3: .same(proto: "cli"),
    4: .same(proto: "bundlePath"),
    5: .same(proto: "remote"),
    6: .same(proto: "home"),
    7: .same(proto: "user"),
    8: .same(proto: "defaultPath"),
    9: .same(proto: "jsonMessageRecieved"),
    10: .same(proto: "jsonMessageHandler"),
    11: .same(proto: "protoMessageRecieved"),
    12: .same(proto: "protoMessageHandler"),
    13: .same(proto: "themes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._build) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._cli) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._bundlePath) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._remote) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._home) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._user) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._defaultPath) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._jsonMessageRecieved) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._jsonMessageHandler) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._protoMessageRecieved) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._protoMessageHandler) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._themes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._build {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cli {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bundlePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._remote {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._home {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._user {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._defaultPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._jsonMessageRecieved {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._jsonMessageHandler {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._protoMessageRecieved {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._protoMessageHandler {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._themes {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fig_Constants, rhs: Fig_Constants) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._build != rhs._build {return false}
    if lhs._cli != rhs._cli {return false}
    if lhs._bundlePath != rhs._bundlePath {return false}
    if lhs._remote != rhs._remote {return false}
    if lhs._home != rhs._home {return false}
    if lhs._user != rhs._user {return false}
    if lhs._defaultPath != rhs._defaultPath {return false}
    if lhs._jsonMessageRecieved != rhs._jsonMessageRecieved {return false}
    if lhs._jsonMessageHandler != rhs._jsonMessageHandler {return false}
    if lhs._protoMessageRecieved != rhs._protoMessageRecieved {return false}
    if lhs._protoMessageHandler != rhs._protoMessageHandler {return false}
    if lhs._themes != rhs._themes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
