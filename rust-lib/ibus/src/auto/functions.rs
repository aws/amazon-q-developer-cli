// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use glib::translate::*;
use std::mem;

//#[doc(alias = "ibus_accelerator_name")]
//pub fn accelerator_name(accelerator_key: u32, accelerator_mods: /*Ignored*/ModifierType) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:ibus_accelerator_name() }
//}

//#[cfg(any(feature = "v1_5_18", feature = "dox"))]
//#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_18")))]
//#[doc(alias = "ibus_accelerator_parse")]
//pub fn accelerator_parse(accelerator: &str) -> (u32, /*Ignored*/ModifierType) {
//    unsafe { TODO: call ffi:ibus_accelerator_parse() }
//}

//#[doc(alias = "ibus_accelerator_valid")]
//pub fn accelerator_valid(keyval: u32, modifiers: /*Ignored*/ModifierType) -> bool {
//    unsafe { TODO: call ffi:ibus_accelerator_valid() }
//}

//#[doc(alias = "ibus_attr_background_new")]
//pub fn attr_background_new(color: u32, start_index: u32, end_index: u32) -> /*Ignored*/Option<Attribute> {
//    unsafe { TODO: call ffi:ibus_attr_background_new() }
//}

//#[doc(alias = "ibus_attr_foreground_new")]
//pub fn attr_foreground_new(color: u32, start_index: u32, end_index: u32) -> /*Ignored*/Option<Attribute> {
//    unsafe { TODO: call ffi:ibus_attr_foreground_new() }
//}

//#[doc(alias = "ibus_emoji_dict_load")]
//pub fn emoji_dict_load(path: &str) -> /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 25 } {
//    unsafe { TODO: call ffi:ibus_emoji_dict_load() }
//}

//#[doc(alias = "ibus_emoji_dict_lookup")]
//pub fn emoji_dict_lookup(dict: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 33 }, emoji: &str) -> /*Ignored*/Option<EmojiData> {
//    unsafe { TODO: call ffi:ibus_emoji_dict_lookup() }
//}

//#[doc(alias = "ibus_emoji_dict_save")]
//pub fn emoji_dict_save(path: &str, dict: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 25 }) {
//    unsafe { TODO: call ffi:ibus_emoji_dict_save() }
//}

#[doc(alias = "ibus_get_address")]
#[doc(alias = "get_address")]
pub fn address() -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::ibus_get_address()) }
}

#[doc(alias = "ibus_get_daemon_uid")]
#[doc(alias = "get_daemon_uid")]
pub fn daemon_uid() -> libc::c_long {
    unsafe { ffi::ibus_get_daemon_uid() }
}

#[doc(alias = "ibus_get_language_name")]
#[doc(alias = "get_language_name")]
pub fn language_name(_locale: &str) -> Option<glib::GString> {
    unsafe { from_glib_full(ffi::ibus_get_language_name(_locale.to_glib_none().0)) }
}

#[doc(alias = "ibus_get_local_machine_id")]
#[doc(alias = "get_local_machine_id")]
pub fn local_machine_id() -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::ibus_get_local_machine_id()) }
}

#[doc(alias = "ibus_get_socket_path")]
#[doc(alias = "get_socket_path")]
pub fn socket_path() -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::ibus_get_socket_path()) }
}

#[doc(alias = "ibus_get_timeout")]
#[doc(alias = "get_timeout")]
pub fn timeout() -> i32 {
    unsafe { ffi::ibus_get_timeout() }
}

#[doc(alias = "ibus_get_untranslated_language_name")]
#[doc(alias = "get_untranslated_language_name")]
pub fn untranslated_language_name(_locale: &str) -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::ibus_get_untranslated_language_name(
            _locale.to_glib_none().0,
        ))
    }
}

#[doc(alias = "ibus_get_user_name")]
#[doc(alias = "get_user_name")]
pub fn user_name() -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::ibus_get_user_name()) }
}

#[doc(alias = "ibus_init")]
pub fn init() {
    unsafe {
        ffi::ibus_init();
    }
}

#[doc(alias = "ibus_key_event_to_string")]
pub fn key_event_to_string(keyval: u32, modifiers: u32) -> Option<glib::GString> {
    unsafe { from_glib_full(ffi::ibus_key_event_to_string(keyval, modifiers)) }
}

#[doc(alias = "ibus_keyval_convert_case")]
pub fn keyval_convert_case(symbol: u32) -> (u32, u32) {
    unsafe {
        let mut lower = mem::MaybeUninit::uninit();
        let mut upper = mem::MaybeUninit::uninit();
        ffi::ibus_keyval_convert_case(symbol, lower.as_mut_ptr(), upper.as_mut_ptr());
        let lower = lower.assume_init();
        let upper = upper.assume_init();
        (lower, upper)
    }
}

#[doc(alias = "ibus_keyval_from_name")]
pub fn keyval_from_name(keyval_name: &str) -> u32 {
    unsafe { ffi::ibus_keyval_from_name(keyval_name.to_glib_none().0) }
}

#[doc(alias = "ibus_keyval_name")]
pub fn keyval_name(keyval: u32) -> Option<glib::GString> {
    unsafe { from_glib_none(ffi::ibus_keyval_name(keyval)) }
}

#[doc(alias = "ibus_keyval_to_lower")]
pub fn keyval_to_lower(keyval: u32) -> u32 {
    unsafe { ffi::ibus_keyval_to_lower(keyval) }
}

#[doc(alias = "ibus_keyval_to_unicode")]
pub fn keyval_to_unicode(keyval: u32) -> char {
    unsafe {
        std::convert::TryFrom::try_from(ffi::ibus_keyval_to_unicode(keyval))
            .expect("conversion from an invalid Unicode value attempted")
    }
}

#[doc(alias = "ibus_keyval_to_upper")]
pub fn keyval_to_upper(keyval: u32) -> u32 {
    unsafe { ffi::ibus_keyval_to_upper(keyval) }
}

#[doc(alias = "ibus_main")]
pub fn main() {
    unsafe {
        ffi::ibus_main();
    }
}

#[doc(alias = "ibus_quit")]
pub fn quit() {
    unsafe {
        ffi::ibus_quit();
    }
}

#[doc(alias = "ibus_set_display")]
pub fn set_display(display: &str) {
    unsafe {
        ffi::ibus_set_display(display.to_glib_none().0);
    }
}

#[doc(alias = "ibus_set_log_handler")]
pub fn set_log_handler(verbose: bool) {
    unsafe {
        ffi::ibus_set_log_handler(verbose.into_glib());
    }
}

#[doc(alias = "ibus_unicode_to_keyval")]
pub fn unicode_to_keyval(wc: char) -> u32 {
    unsafe { ffi::ibus_unicode_to_keyval(wc.into_glib()) }
}

#[doc(alias = "ibus_unset_log_handler")]
pub fn unset_log_handler() {
    unsafe {
        ffi::ibus_unset_log_handler();
    }
}

#[doc(alias = "ibus_write_address")]
pub fn write_address(address: &str) {
    unsafe {
        ffi::ibus_write_address(address.to_glib_none().0);
    }
}
