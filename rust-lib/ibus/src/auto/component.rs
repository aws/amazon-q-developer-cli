// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use glib::object::IsA;
use glib::translate::*;
use glib::ToValue;
use std::fmt;

glib::wrapper! {
    #[doc(alias = "IBusComponent")]
    pub struct Component(Object<ffi::IBusComponent, ffi::IBusComponentClass>);

    match fn {
        type_ => || ffi::ibus_component_get_type(),
    }
}

impl Component {
    pub const NONE: Option<&'static Component> = None;

    #[doc(alias = "ibus_component_new")]
    pub fn new(
        name: &str,
        description: &str,
        version: &str,
        license: &str,
        author: &str,
        homepage: &str,
        command_line: &str,
        textdomain: &str,
    ) -> Component {
        unsafe {
            from_glib_none(ffi::ibus_component_new(
                name.to_glib_none().0,
                description.to_glib_none().0,
                version.to_glib_none().0,
                license.to_glib_none().0,
                author.to_glib_none().0,
                homepage.to_glib_none().0,
                command_line.to_glib_none().0,
                textdomain.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "ibus_component_new_from_file")]
    #[doc(alias = "new_from_file")]
    pub fn from_file(filename: &str) -> Component {
        unsafe { from_glib_none(ffi::ibus_component_new_from_file(filename.to_glib_none().0)) }
    }

    //#[doc(alias = "ibus_component_new_from_xml_node")]
    //#[doc(alias = "new_from_xml_node")]
    //pub fn from_xml_node(node: /*Ignored*/&mut XML) -> Component {
    //    unsafe { TODO: call ffi:ibus_component_new_from_xml_node() }
    //}

    //#[doc(alias = "ibus_component_new_varargs")]
    //pub fn new_varargs(first_property_name: &str, : /*Unknown conversion*//*Unimplemented*/Fundamental: VarArgs) -> Component {
    //    unsafe { TODO: call ffi:ibus_component_new_varargs() }
    //}

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`Component`] objects.
    ///
    /// This method returns an instance of [`ComponentBuilder`](crate::builders::ComponentBuilder) which can be used to create [`Component`] objects.
    pub fn builder() -> ComponentBuilder {
        ComponentBuilder::default()
    }
}

impl Default for Component {
    fn default() -> Self {
        glib::object::Object::new::<Self>(&[])
            .expect("Can't construct Component object with default parameters")
    }
}

#[derive(Clone, Default)]
// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`Component`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct ComponentBuilder {
    author: Option<String>,
    command_line: Option<String>,
    description: Option<String>,
    homepage: Option<String>,
    license: Option<String>,
    name: Option<String>,
    textdomain: Option<String>,
    version: Option<String>,
}

impl ComponentBuilder {
    // rustdoc-stripper-ignore-next
    /// Create a new [`ComponentBuilder`].
    pub fn new() -> Self {
        Self::default()
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`Component`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> Component {
        let mut properties: Vec<(&str, &dyn ToValue)> = vec![];
        if let Some(ref author) = self.author {
            properties.push(("author", author));
        }
        if let Some(ref command_line) = self.command_line {
            properties.push(("command-line", command_line));
        }
        if let Some(ref description) = self.description {
            properties.push(("description", description));
        }
        if let Some(ref homepage) = self.homepage {
            properties.push(("homepage", homepage));
        }
        if let Some(ref license) = self.license {
            properties.push(("license", license));
        }
        if let Some(ref name) = self.name {
            properties.push(("name", name));
        }
        if let Some(ref textdomain) = self.textdomain {
            properties.push(("textdomain", textdomain));
        }
        if let Some(ref version) = self.version {
            properties.push(("version", version));
        }
        glib::Object::new::<Component>(&properties)
            .expect("Failed to create an instance of Component")
    }

    pub fn author(mut self, author: &str) -> Self {
        self.author = Some(author.to_string());
        self
    }

    pub fn command_line(mut self, command_line: &str) -> Self {
        self.command_line = Some(command_line.to_string());
        self
    }

    pub fn description(mut self, description: &str) -> Self {
        self.description = Some(description.to_string());
        self
    }

    pub fn homepage(mut self, homepage: &str) -> Self {
        self.homepage = Some(homepage.to_string());
        self
    }

    pub fn license(mut self, license: &str) -> Self {
        self.license = Some(license.to_string());
        self
    }

    pub fn name(mut self, name: &str) -> Self {
        self.name = Some(name.to_string());
        self
    }

    pub fn textdomain(mut self, textdomain: &str) -> Self {
        self.textdomain = Some(textdomain.to_string());
        self
    }

    pub fn version(mut self, version: &str) -> Self {
        self.version = Some(version.to_string());
        self
    }
}

pub trait ComponentExt: 'static {
    //#[doc(alias = "ibus_component_add_engine")]
    //fn add_engine(&self, engine: /*Ignored*/&EngineDesc);

    #[doc(alias = "ibus_component_add_observed_path")]
    fn add_observed_path(&self, path: &str, access_fs: bool);

    #[doc(alias = "ibus_component_check_modification")]
    fn check_modification(&self) -> bool;

    #[doc(alias = "ibus_component_get_author")]
    #[doc(alias = "get_author")]
    fn author(&self) -> Option<glib::GString>;

    #[doc(alias = "ibus_component_get_description")]
    #[doc(alias = "get_description")]
    fn description(&self) -> Option<glib::GString>;

    //#[doc(alias = "ibus_component_get_engines")]
    //#[doc(alias = "get_engines")]
    //fn engines(&self) -> /*Ignored*/Vec<EngineDesc>;

    #[doc(alias = "ibus_component_get_exec")]
    #[doc(alias = "get_exec")]
    fn exec(&self) -> Option<glib::GString>;

    #[doc(alias = "ibus_component_get_homepage")]
    #[doc(alias = "get_homepage")]
    fn homepage(&self) -> Option<glib::GString>;

    #[doc(alias = "ibus_component_get_license")]
    #[doc(alias = "get_license")]
    fn license(&self) -> Option<glib::GString>;

    #[doc(alias = "ibus_component_get_name")]
    #[doc(alias = "get_name")]
    fn name(&self) -> Option<glib::GString>;

    //#[doc(alias = "ibus_component_get_observed_paths")]
    //#[doc(alias = "get_observed_paths")]
    //fn observed_paths(&self) -> /*Ignored*/Vec<ObservedPath>;

    #[doc(alias = "ibus_component_get_textdomain")]
    #[doc(alias = "get_textdomain")]
    fn textdomain(&self) -> Option<glib::GString>;

    #[doc(alias = "ibus_component_get_version")]
    #[doc(alias = "get_version")]
    fn version(&self) -> Option<glib::GString>;

    //#[doc(alias = "ibus_component_output")]
    //fn output(&self, output: /*Ignored*/&mut glib::String, indent: i32);

    //#[doc(alias = "ibus_component_output_engines")]
    //fn output_engines(&self, output: /*Ignored*/&mut glib::String, indent: i32);

    #[doc(alias = "command-line")]
    fn command_line(&self) -> Option<glib::GString>;
}

impl<O: IsA<Component>> ComponentExt for O {
    //fn add_engine(&self, engine: /*Ignored*/&EngineDesc) {
    //    unsafe { TODO: call ffi:ibus_component_add_engine() }
    //}

    fn add_observed_path(&self, path: &str, access_fs: bool) {
        unsafe {
            ffi::ibus_component_add_observed_path(
                self.as_ref().to_glib_none().0,
                path.to_glib_none().0,
                access_fs.into_glib(),
            );
        }
    }

    fn check_modification(&self) -> bool {
        unsafe {
            from_glib(ffi::ibus_component_check_modification(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn author(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_component_get_author(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn description(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_component_get_description(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    //fn engines(&self) -> /*Ignored*/Vec<EngineDesc> {
    //    unsafe { TODO: call ffi:ibus_component_get_engines() }
    //}

    fn exec(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::ibus_component_get_exec(self.as_ref().to_glib_none().0)) }
    }

    fn homepage(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_component_get_homepage(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn license(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_component_get_license(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn name(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::ibus_component_get_name(self.as_ref().to_glib_none().0)) }
    }

    //fn observed_paths(&self) -> /*Ignored*/Vec<ObservedPath> {
    //    unsafe { TODO: call ffi:ibus_component_get_observed_paths() }
    //}

    fn textdomain(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_component_get_textdomain(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    fn version(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_component_get_version(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    //fn output(&self, output: /*Ignored*/&mut glib::String, indent: i32) {
    //    unsafe { TODO: call ffi:ibus_component_output() }
    //}

    //fn output_engines(&self, output: /*Ignored*/&mut glib::String, indent: i32) {
    //    unsafe { TODO: call ffi:ibus_component_output_engines() }
    //}

    fn command_line(&self) -> Option<glib::GString> {
        glib::ObjectExt::property(self.as_ref(), "command-line")
    }
}

impl fmt::Display for Component {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Component")
    }
}
