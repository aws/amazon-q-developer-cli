#!/bin/bash

# Based somewhat on https://builderhub.corp.amazon.com/docs/brazil/user-guide/cargobrazil.html#write-your-own-build-script

# Make bash exit early on failure
set -euxo pipefail

# Disables warning about cargo brazil not liking the "mac-trampoline-build" build system
export CARGO_BRAZIL_ALLOW_NONSTANDARD_NAME=1

# Start the registry proxy in the background.
#
# Load npm configs in to the current processes environment. Any call to npm
# in this process will use the proxy registry.
# Kill the server that's running in the background when this process exits.
#
# https://code.amazon.com/packages/NpmPrettyMuch/blobs/mainline-1.1/--/advanced-readme.md#
# npm_registry() {
#     eval_me="$(npm-pretty-much-registry)"
#     eval "$eval_me"
#
#     if ! [ "$(command -v pnpm)" ]; then
#         PNPM_VERSION="$(sed -n '/"packageManager"/p' package.json | sed 's/^.*"\(.*\)".*$/\1/')"
#
#         # This line HAS to be invoked after the registry proxy starts in order to use CodeArtifact
#         # as the source repository for nodejs packages.
#         #
#         # Anyway, even if you tried to use npm, it won't work because Builder (build.amazon.com)
#         # doesn't have internet access so it can't reach the npm registry (registry.npmjs.org).
#         npm install -g "$PNPM_VERSION"
#     fi
#
#     # Now tell `pnpm` to use this registry
#     # https://code.amazon.com/packages/NpmPrettyMuch/blobs/mainline/--/src/bin/npm-pretty-much-registry.ts
#     # https://bytesafe.dev/posts/pnpm-package-manager/
#     pnpm config set npmRegistryServer "$NPM_CONFIG_REGISTRY"
#     trap 'kill $NPM_PRETTY_MUCH_REGISTRY_PID' EXIT
# }

# Ensure that development on macOS works
PATH="$(path-allowing-local-dev)"
export PATH

python3.11 --version

# Fast-path for cleaning build artifacts
if [[ $# -gt 0 ]] && [[ "$1" = clean ]]; then
    cargo-brazil-build clean
    exit 0
fi

# Interact directly with pnpm with the proxy
# if [[ $# -gt 0 ]] && [[ "$1" = pnpm ]]; then
#     npm_registry
#     pnpm "${@:2}"
#     exit 0
# fi

# Generate the necessary Cargo configuration so that idiomatic commands work.
# This produces two things:
#
# 1. rust-toolchain.toml that sets a Rustup override to a Brazil-managed
#    toolchain that lives in build/private/cargo-brazil-toolchain. It's only
#    purpose is to apply environment variables from
#    build/private/cargo-home/brazil.toml, which primarily means setting
#    CARGO_HOME to build/private/cargo-home and PATH to include the appropriate
#    Brazil dependencies (like Rustup).
# 2. A Cargo configuration file in CARGO_HOME that sets the various bits and
#    pieces needed to make Cargo work right in the context of Brazil.
#
# Once this command has been run, standard Cargo commands _and_ `cargo brazil`
# should be executable directly on the command-line.
#
# Note that the CARGO_HOME=$() + export here is only needed to also support
# non-Rustup-based RustLang1x builds. If you're writing a custom build script
# and copy-pasting this and don't need that (you probably don't), then just
# make this a simple call to `cargo brazil configure`.
CARGO_HOME=$(
    # Work around https://github.com/rust-lang/cargo/issues/7431,
    # which makes rustup prepend ~/.rustup/bin to `$PATH`, which makes
    # CargoBrazil think it's forced to _not_ use Brazil artifacts.
    #
    # Can be removed once upstream fix from
    # https://github.com/rust-lang/rustup/pull/2978 is merged and released.
    env CARGO_HOME=/rust-lang/cargo/issues/7431 \
    cargo brazil configure
)
export CARGO_HOME

cargo brazil fetch --workspace

# https://code.amazon.com/packages/CargoBrazil/blobs/841280a3f0f9bf659c26cfa50b16f1c075aa6906/--/bin/cargo-brazil-build#L184-L214
# Provide a convenient hook for cargo-eevee.
if [[ $# -gt 0 ]] && [[ "$1" = eevee-audit ]]; then
    if ! command -v cargo-eevee &> /dev/null; then
        echo "cargo-eevee was not found in \$PATH." >&2
        echo "Add 'CargoEevee' to 'build-tools' in 'Config'." >&2
        exit 1
    fi
    echo "delegating to cargo-eevee"
    shift
    # If running on ToD, we should pick up credentials from there.
    if [[ -n "${TOD_CUSTOMER_CREDENTIAL_PATH:-}" ]]; then
        exec cargo eevee --aws --credentials-file "$TOD_CUSTOMER_CREDENTIAL_PATH" audit "$@"
    # If ToD credentials aren't available, check if we _might_ be on ToD
    # and provide a decent warnings that ToD credentials aren't available.
    elif [[ -e tod.json ]]; then
		echo "It looks like you're running eevee-audit on a ToD worker,"
		echo "but TOD_CUSTOMER_CREDENTIAL_PATH isn't set, so cargo-eevee"
		echo "has no way of authenticating to Eevee."
		echo
		echo "You need to set the AWS Role ARN for your ToD step to:"
		echo
		echo "  arn:aws:iam::775576702762:role/cargo-eevee-cli"
		echo
        exit 1
    # Otherwise we'll just use the default (Midway-based) credentials.
    else
        exec cargo eevee audit "$@"
    fi
    # If we get here, exec must have failed somehow.
    exit 1
fi

rustup +stable component add llvm-tools-preview

BUILD_DIR=$(brazil-path package-build-root)
PACKAGE_DIR=$(brazil-path package-src-root)

echo "BUILD_DIR: $BUILD_DIR"
echo "PACKAGE_DIR: $PACKAGE_DIR"

# Fast-path for IDE integration
if [[ $# -gt 0 ]] && [[ "$1" = sync* ]]; then
    exit 0
fi

if [[ $# -gt 0 ]] && [[ "$1" = update ]]; then
    cargo update
    exit 0
fi

# npm_registry

"$BRAZIL_BUILD_HOME/bin/brazil-runtime-exec" python3.11 build-scripts/main.py test --clippy-fail-on-warn
"$BRAZIL_BUILD_HOME/bin/brazil-runtime-exec" python3.11 build-scripts/main.py doc
