// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: fig.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Fig_Anchor: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case cursor // = 0
  case leftEdge // = 1
  case rightEdge // = 2
  case topEdge // = 3
  case bottomEdge // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .cursor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cursor
    case 1: self = .leftEdge
    case 2: self = .rightEdge
    case 3: self = .topEdge
    case 4: self = .bottomEdge
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cursor: return 0
    case .leftEdge: return 1
    case .rightEdge: return 2
    case .topEdge: return 3
    case .bottomEdge: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Fig_Anchor: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Fig_Anchor] = [
    .cursor,
    .leftEdge,
    .rightEdge,
    .topEdge,
    .bottomEdge,
  ]
}

#endif  // swift(>=4.2)

struct Fig_ClientOriginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var submessage: Fig_ClientOriginatedMessage.OneOf_Submessage? = nil

  var getBufferRequest: Fig_GetBufferRequest {
    get {
      if case .getBufferRequest(let v)? = submessage {return v}
      return Fig_GetBufferRequest()
    }
    set {submessage = .getBufferRequest(newValue)}
  }

  var positionWindowRequest: Fig_PositionWindowRequest {
    get {
      if case .positionWindowRequest(let v)? = submessage {return v}
      return Fig_PositionWindowRequest()
    }
    set {submessage = .positionWindowRequest(newValue)}
  }

  var ptyRequest: Fig_PseudoterminalExecuteRequest {
    get {
      if case .ptyRequest(let v)? = submessage {return v}
      return Fig_PseudoterminalExecuteRequest()
    }
    set {submessage = .ptyRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Submessage: Equatable {
    case getBufferRequest(Fig_GetBufferRequest)
    case positionWindowRequest(Fig_PositionWindowRequest)
    case ptyRequest(Fig_PseudoterminalExecuteRequest)

  #if !swift(>=4.1)
    static func ==(lhs: Fig_ClientOriginatedMessage.OneOf_Submessage, rhs: Fig_ClientOriginatedMessage.OneOf_Submessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getBufferRequest, .getBufferRequest): return {
        guard case .getBufferRequest(let l) = lhs, case .getBufferRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionWindowRequest, .positionWindowRequest): return {
        guard case .positionWindowRequest(let l) = lhs, case .positionWindowRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ptyRequest, .ptyRequest): return {
        guard case .ptyRequest(let l) = lhs, case .ptyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _id: Int64? = nil
}

struct Fig_ServerOriginatedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// Responses to ClientOriginatedMessages of the corresponding type
  var submessage: Fig_ServerOriginatedMessage.OneOf_Submessage? = nil

  /// Set if request was malformed
  var error: String {
    get {
      if case .error(let v)? = submessage {return v}
      return String()
    }
    set {submessage = .error(newValue)}
  }

  var positionWindowResponse: Fig_PositionWindowResponse {
    get {
      if case .positionWindowResponse(let v)? = submessage {return v}
      return Fig_PositionWindowResponse()
    }
    set {submessage = .positionWindowResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Responses to ClientOriginatedMessages of the corresponding type
  enum OneOf_Submessage: Equatable {
    /// Set if request was malformed
    case error(String)
    case positionWindowResponse(Fig_PositionWindowResponse)

  #if !swift(>=4.1)
    static func ==(lhs: Fig_ServerOriginatedMessage.OneOf_Submessage, rhs: Fig_ServerOriginatedMessage.OneOf_Submessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.positionWindowResponse, .positionWindowResponse): return {
        guard case .positionWindowResponse(let l) = lhs, case .positionWindowResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _id: Int64? = nil
}

struct Fig_PseudoterminalWriteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var input: Fig_PseudoterminalWriteRequest.OneOf_Input? = nil

  var text: String {
    get {
      if case .text(let v)? = input {return v}
      return String()
    }
    set {input = .text(newValue)}
  }

  var octal: String {
    get {
      if case .octal(let v)? = input {return v}
      return String()
    }
    set {input = .octal(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Input: Equatable {
    case text(String)
    case octal(String)

  #if !swift(>=4.1)
    static func ==(lhs: Fig_PseudoterminalWriteRequest.OneOf_Input, rhs: Fig_PseudoterminalWriteRequest.OneOf_Input) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.octal, .octal): return {
        guard case .octal(let l) = lhs, case .octal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Fig_PseudoterminalExecuteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: String = String()

  var workingDirectory: String {
    get {return _workingDirectory ?? String()}
    set {_workingDirectory = newValue}
  }
  /// Returns true if `workingDirectory` has been explicitly set.
  var hasWorkingDirectory: Bool {return self._workingDirectory != nil}
  /// Clears the value of `workingDirectory`. Subsequent reads from it will return its default value.
  mutating func clearWorkingDirectory() {self._workingDirectory = nil}

  var backgroundJob: Bool {
    get {return _backgroundJob ?? false}
    set {_backgroundJob = newValue}
  }
  /// Returns true if `backgroundJob` has been explicitly set.
  var hasBackgroundJob: Bool {return self._backgroundJob != nil}
  /// Clears the value of `backgroundJob`. Subsequent reads from it will return its default value.
  mutating func clearBackgroundJob() {self._backgroundJob = nil}

  var isPipelined: Bool {
    get {return _isPipelined ?? false}
    set {_isPipelined = newValue}
  }
  /// Returns true if `isPipelined` has been explicitly set.
  var hasIsPipelined: Bool {return self._isPipelined != nil}
  /// Clears the value of `isPipelined`. Subsequent reads from it will return its default value.
  mutating func clearIsPipelined() {self._isPipelined = nil}

  var env: [Fig_EnvironmentVariable] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _workingDirectory: String? = nil
  fileprivate var _backgroundJob: Bool? = nil
  fileprivate var _isPipelined: Bool? = nil
}

struct Fig_EnvironmentVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: String? = nil
}

struct Fig_PositionWindowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var anchor: Fig_Point {
    get {return _anchor ?? Fig_Point()}
    set {_anchor = newValue}
  }
  /// Returns true if `anchor` has been explicitly set.
  var hasAnchor: Bool {return self._anchor != nil}
  /// Clears the value of `anchor`. Subsequent reads from it will return its default value.
  mutating func clearAnchor() {self._anchor = nil}

  var size: Fig_Size {
    get {return _size ?? Fig_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var dryrun: Bool {
    get {return _dryrun ?? false}
    set {_dryrun = newValue}
  }
  /// Returns true if `dryrun` has been explicitly set.
  var hasDryrun: Bool {return self._dryrun != nil}
  /// Clears the value of `dryrun`. Subsequent reads from it will return its default value.
  mutating func clearDryrun() {self._dryrun = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _anchor: Fig_Point? = nil
  fileprivate var _size: Fig_Size? = nil
  fileprivate var _dryrun: Bool? = nil
}

struct Fig_PositionWindowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isAbove: Bool {
    get {return _isAbove ?? false}
    set {_isAbove = newValue}
  }
  /// Returns true if `isAbove` has been explicitly set.
  var hasIsAbove: Bool {return self._isAbove != nil}
  /// Clears the value of `isAbove`. Subsequent reads from it will return its default value.
  mutating func clearIsAbove() {self._isAbove = nil}

  var isClipped: Bool {
    get {return _isClipped ?? false}
    set {_isClipped = newValue}
  }
  /// Returns true if `isClipped` has been explicitly set.
  var hasIsClipped: Bool {return self._isClipped != nil}
  /// Clears the value of `isClipped`. Subsequent reads from it will return its default value.
  mutating func clearIsClipped() {self._isClipped = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isAbove: Bool? = nil
  fileprivate var _isClipped: Bool? = nil
}

struct Fig_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Fig_Size {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Float = 0

  var height: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Fig_Frame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origin: Fig_Point {
    get {return _origin ?? Fig_Point()}
    set {_origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  var hasOrigin: Bool {return self._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  mutating func clearOrigin() {self._origin = nil}

  var size: Fig_Size {
    get {return _size ?? Fig_Size()}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _origin: Fig_Point? = nil
  fileprivate var _size: Fig_Size? = nil
}

/// Requests the contents of a range of lines.
struct Fig_GetBufferRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See documentation on session IDs. "all" not accepted.
  var session: String {
    get {return _session ?? String()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fig"

extension Fig_Anchor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CURSOR"),
    1: .same(proto: "LEFT_EDGE"),
    2: .same(proto: "RIGHT_EDGE"),
    3: .same(proto: "TOP_EDGE"),
    4: .same(proto: "BOTTOM_EDGE"),
  ]
}

extension Fig_ClientOriginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientOriginatedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    100: .standard(proto: "get_buffer_request"),
    101: .standard(proto: "position_window_request"),
    102: .standard(proto: "pty_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 100: try {
        var v: Fig_GetBufferRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .getBufferRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .getBufferRequest(v)
        }
      }()
      case 101: try {
        var v: Fig_PositionWindowRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .positionWindowRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .positionWindowRequest(v)
        }
      }()
      case 102: try {
        var v: Fig_PseudoterminalExecuteRequest?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .ptyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .ptyRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.submessage {
    case .getBufferRequest?: try {
      guard case .getBufferRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .positionWindowRequest?: try {
      guard case .positionWindowRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .ptyRequest?: try {
      guard case .ptyRequest(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_ClientOriginatedMessage, rhs: Fig_ClientOriginatedMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.submessage != rhs.submessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_ServerOriginatedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerOriginatedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "error"),
    200: .standard(proto: "position_window_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._id) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.submessage != nil {try decoder.handleConflictingOneOf()}
          self.submessage = .error(v)
        }
      }()
      case 200: try {
        var v: Fig_PositionWindowResponse?
        var hadOneofValue = false
        if let current = self.submessage {
          hadOneofValue = true
          if case .positionWindowResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.submessage = .positionWindowResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.submessage {
    case .error?: try {
      guard case .error(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .positionWindowResponse?: try {
      guard case .positionWindowResponse(let v)? = self.submessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_ServerOriginatedMessage, rhs: Fig_ServerOriginatedMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.submessage != rhs.submessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PseudoterminalWriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PseudoterminalWriteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "octal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.input != nil {try decoder.handleConflictingOneOf()}
          self.input = .text(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.input != nil {try decoder.handleConflictingOneOf()}
          self.input = .octal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.input {
    case .text?: try {
      guard case .text(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .octal?: try {
      guard case .octal(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_PseudoterminalWriteRequest, rhs: Fig_PseudoterminalWriteRequest) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PseudoterminalExecuteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PseudoterminalExecuteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "workingDirectory"),
    3: .same(proto: "backgroundJob"),
    4: .same(proto: "isPipelined"),
    5: .same(proto: "env"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._workingDirectory) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._backgroundJob) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isPipelined) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.env) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 1)
    }
    if let v = self._workingDirectory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._backgroundJob {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._isPipelined {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if !self.env.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.env, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_PseudoterminalExecuteRequest, rhs: Fig_PseudoterminalExecuteRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs._workingDirectory != rhs._workingDirectory {return false}
    if lhs._backgroundJob != rhs._backgroundJob {return false}
    if lhs._isPipelined != rhs._isPipelined {return false}
    if lhs.env != rhs.env {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_EnvironmentVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnvironmentVariable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_EnvironmentVariable, rhs: Fig_EnvironmentVariable) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PositionWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionWindowRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "anchor"),
    2: .same(proto: "size"),
    3: .same(proto: "dryrun"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._anchor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._dryrun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._anchor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._dryrun {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_PositionWindowRequest, rhs: Fig_PositionWindowRequest) -> Bool {
    if lhs._anchor != rhs._anchor {return false}
    if lhs._size != rhs._size {return false}
    if lhs._dryrun != rhs._dryrun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_PositionWindowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PositionWindowResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isAbove"),
    2: .same(proto: "isClipped"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isAbove) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isClipped) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._isAbove {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._isClipped {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_PositionWindowResponse, rhs: Fig_PositionWindowResponse) -> Bool {
    if lhs._isAbove != rhs._isAbove {return false}
    if lhs._isClipped != rhs._isClipped {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_Point, rhs: Fig_Point) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Size"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_Size, rhs: Fig_Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Frame"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_Frame, rhs: Fig_Frame) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fig_GetBufferRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBufferRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Fig_GetBufferRequest, rhs: Fig_GetBufferRequest) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
