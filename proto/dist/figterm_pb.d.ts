// @generated by protoc-gen-es v2.2.5 with parameter "target=js+dts,import_extension=js,json_types=false"
// @generated from file figterm.proto (package figterm, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { EnvironmentVariable, ShellContext } from "./fig_common_pb.js";

/**
 * Describes the file figterm.proto.
 */
export declare const file_figterm: GenFile;

/**
 * A request message to figterm
 *
 * @generated from message figterm.FigtermRequestMessage
 */
export declare type FigtermRequestMessage = Message<"figterm.FigtermRequestMessage"> & {
  /**
   * @generated from oneof figterm.FigtermRequestMessage.request
   */
  request: {
    /**
     * @generated from field: figterm.InterceptRequest intercept = 1;
     */
    value: InterceptRequest;
    case: "intercept";
  } | {
    /**
     * @generated from field: figterm.InsertTextRequest insert_text = 2;
     */
    value: InsertTextRequest;
    case: "insertText";
  } | {
    /**
     * @generated from field: figterm.SetBufferRequest set_buffer = 3;
     */
    value: SetBufferRequest;
    case: "setBuffer";
  } | {
    /**
     * @generated from field: figterm.DiagnosticsRequest diagnostics = 4;
     */
    value: DiagnosticsRequest;
    case: "diagnostics";
  } | {
    /**
     * @generated from field: figterm.InsertOnNewCmdRequest insert_on_new_cmd = 5;
     */
    value: InsertOnNewCmdRequest;
    case: "insertOnNewCmd";
  } | {
    /**
     * @generated from field: figterm.UpdateShellContextRequest update_shell_context = 6;
     */
    value: UpdateShellContextRequest;
    case: "updateShellContext";
  } | {
    /**
     * @generated from field: figterm.NotifySSHSessionStartedRequest notify_ssh_session_started = 7;
     */
    value: NotifySSHSessionStartedRequest;
    case: "notifySshSessionStarted";
  } | {
    /**
     * @generated from field: figterm.InlineShellCompletionRequest inline_shell_completion = 8;
     */
    value: InlineShellCompletionRequest;
    case: "inlineShellCompletion";
  } | {
    /**
     * @generated from field: figterm.InlineShellCompletionAcceptRequest inline_shell_completion_accept = 9;
     */
    value: InlineShellCompletionAcceptRequest;
    case: "inlineShellCompletionAccept";
  } | {
    /**
     * @generated from field: figterm.TelemetryRequest telemtety = 10;
     */
    value: TelemetryRequest;
    case: "telemtety";
  } | {
    /**
     * @generated from field: figterm.InlineShellCompletionSetEnabledRequest inline_shell_completion_set_enabled = 11;
     */
    value: InlineShellCompletionSetEnabledRequest;
    case: "inlineShellCompletionSetEnabled";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message figterm.FigtermRequestMessage.
 * Use `create(FigtermRequestMessageSchema)` to create a new message.
 */
export declare const FigtermRequestMessageSchema: GenMessage<FigtermRequestMessage>;

/**
 * A response message back from figterm
 *
 * @generated from message figterm.FigtermResponseMessage
 */
export declare type FigtermResponseMessage = Message<"figterm.FigtermResponseMessage"> & {
  /**
   * @generated from oneof figterm.FigtermResponseMessage.response
   */
  response: {
    /**
     * @generated from field: figterm.DiagnosticsResponse diagnostics = 1;
     */
    value: DiagnosticsResponse;
    case: "diagnostics";
  } | {
    /**
     * @generated from field: figterm.InlineShellCompletionResponse inline_shell_completion = 2;
     */
    value: InlineShellCompletionResponse;
    case: "inlineShellCompletion";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message figterm.FigtermResponseMessage.
 * Use `create(FigtermResponseMessageSchema)` to create a new message.
 */
export declare const FigtermResponseMessageSchema: GenMessage<FigtermResponseMessage>;

/**
 * @generated from message figterm.Action
 */
export declare type Action = Message<"figterm.Action"> & {
  /**
   * unique identifier for the action
   *
   * @generated from field: string identifier = 1;
   */
  identifier: string;

  /**
   * the keys that are bound to the action
   *
   * @generated from field: repeated string bindings = 2;
   */
  bindings: string[];
};

/**
 * Describes the message figterm.Action.
 * Use `create(ActionSchema)` to create a new message.
 */
export declare const ActionSchema: GenMessage<Action>;

/**
 * Intercept command
 * Used to set which input is intercepted by figterm
 *
 * @generated from message figterm.InterceptRequest
 */
export declare type InterceptRequest = Message<"figterm.InterceptRequest"> & {
  /**
   * The intercept command to execute
   *
   * @generated from oneof figterm.InterceptRequest.intercept_command
   */
  interceptCommand: {
    /**
     * Set figterm to intercept keys according to the FigJs interface
     *
     * @generated from field: figterm.InterceptRequest.SetFigjsIntercepts set_figjs_intercepts = 6;
     */
    value: InterceptRequest_SetFigjsIntercepts;
    case: "setFigjsIntercepts";
  } | {
    /**
     * Tell figterm if the figjs window is visible
     *
     * @generated from field: figterm.InterceptRequest.SetFigjsVisible set_figjs_visible = 7;
     */
    value: InterceptRequest_SetFigjsVisible;
    case: "setFigjsVisible";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message figterm.InterceptRequest.
 * Use `create(InterceptRequestSchema)` to create a new message.
 */
export declare const InterceptRequestSchema: GenMessage<InterceptRequest>;

/**
 * @generated from message figterm.InterceptRequest.SetFigjsIntercepts
 */
export declare type InterceptRequest_SetFigjsIntercepts = Message<"figterm.InterceptRequest.SetFigjsIntercepts"> & {
  /**
   * @generated from field: bool intercept_bound_keystrokes = 1;
   */
  interceptBoundKeystrokes: boolean;

  /**
   * @generated from field: bool intercept_global_keystrokes = 2;
   */
  interceptGlobalKeystrokes: boolean;

  /**
   * @generated from field: repeated figterm.Action actions = 3;
   */
  actions: Action[];

  /**
   * If true then figterm will clear the current action bindings and set the
   * bindings to the bindings in the actions field, otherwise it will append
   * if there are any new bindings
   *
   * @generated from field: bool override_actions = 4;
   */
  overrideActions: boolean;
};

/**
 * Describes the message figterm.InterceptRequest.SetFigjsIntercepts.
 * Use `create(InterceptRequest_SetFigjsInterceptsSchema)` to create a new message.
 */
export declare const InterceptRequest_SetFigjsInterceptsSchema: GenMessage<InterceptRequest_SetFigjsIntercepts>;

/**
 * @generated from message figterm.InterceptRequest.SetFigjsVisible
 */
export declare type InterceptRequest_SetFigjsVisible = Message<"figterm.InterceptRequest.SetFigjsVisible"> & {
  /**
   * @generated from field: bool visible = 1;
   */
  visible: boolean;
};

/**
 * Describes the message figterm.InterceptRequest.SetFigjsVisible.
 * Use `create(InterceptRequest_SetFigjsVisibleSchema)` to create a new message.
 */
export declare const InterceptRequest_SetFigjsVisibleSchema: GenMessage<InterceptRequest_SetFigjsVisible>;

/**
 * Insert text command
 * Used to insert text directly into the terminal
 *
 * @generated from message figterm.InsertTextRequest
 */
export declare type InsertTextRequest = Message<"figterm.InsertTextRequest"> & {
  /**
   * insert str at cursor, accounting for deletions
   *
   * @generated from field: optional string insertion = 1;
   */
  insertion?: string;

  /**
   * delete `n` characters to the left of the cursor
   *
   * @generated from field: optional uint64 deletion = 2;
   */
  deletion?: bigint;

  /**
   * move cursor `n` characters from current position,
   * accounting for insertion & deletion
   *
   * @generated from field: optional int64 offset = 3;
   */
  offset?: bigint;

  /**
   * execute editbuffer (if true, append \r)
   *
   * @generated from field: optional bool immediate = 4;
   */
  immediate?: boolean;

  /**
   * client buffer at the time of the insertion request (prior to insertion)
   *
   * @generated from field: optional string insertion_buffer = 5;
   */
  insertionBuffer?: string;

  /**
   * if figterm should insert while a command is running, if false and a command
   * is running the insertion will be ignored
   *
   * @generated from field: optional bool insert_during_command = 6;
   */
  insertDuringCommand?: boolean;
};

/**
 * Describes the message figterm.InsertTextRequest.
 * Use `create(InsertTextRequestSchema)` to create a new message.
 */
export declare const InsertTextRequestSchema: GenMessage<InsertTextRequest>;

/**
 * Set buffer command
 * Used to set the line of text in the edit buffer
 *
 * @generated from message figterm.SetBufferRequest
 */
export declare type SetBufferRequest = Message<"figterm.SetBufferRequest"> & {
  /**
   * The text to set
   *
   * @generated from field: string text = 1;
   */
  text: string;

  /**
   * The cursor position to set
   *
   * @generated from field: optional uint64 cursor_position = 2;
   */
  cursorPosition?: bigint;
};

/**
 * Describes the message figterm.SetBufferRequest.
 * Use `create(SetBufferRequestSchema)` to create a new message.
 */
export declare const SetBufferRequestSchema: GenMessage<SetBufferRequest>;

/**
 * @generated from message figterm.TermColor
 */
export declare type TermColor = Message<"figterm.TermColor"> & {
  /**
   * @generated from oneof figterm.TermColor.color
   */
  color: {
    /**
     * @generated from field: figterm.TermColor.Rgb rgb = 1;
     */
    value: TermColor_Rgb;
    case: "rgb";
  } | {
    /**
     * @generated from field: uint32 indexed = 2;
     */
    value: number;
    case: "indexed";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message figterm.TermColor.
 * Use `create(TermColorSchema)` to create a new message.
 */
export declare const TermColorSchema: GenMessage<TermColor>;

/**
 * @generated from message figterm.TermColor.Rgb
 */
export declare type TermColor_Rgb = Message<"figterm.TermColor.Rgb"> & {
  /**
   * @generated from field: int32 r = 1;
   */
  r: number;

  /**
   * @generated from field: int32 b = 2;
   */
  b: number;

  /**
   * @generated from field: int32 g = 3;
   */
  g: number;
};

/**
 * Describes the message figterm.TermColor.Rgb.
 * Use `create(TermColor_RgbSchema)` to create a new message.
 */
export declare const TermColor_RgbSchema: GenMessage<TermColor_Rgb>;

/**
 * @generated from message figterm.TermStyle
 */
export declare type TermStyle = Message<"figterm.TermStyle"> & {
  /**
   * Background color of the terminal style
   *
   * @generated from field: optional figterm.TermColor fg = 1;
   */
  fg?: TermColor;

  /**
   * Foreground color of the terminal style
   *
   * @generated from field: optional figterm.TermColor bg = 2;
   */
  bg?: TermColor;
};

/**
 * Describes the message figterm.TermStyle.
 * Use `create(TermStyleSchema)` to create a new message.
 */
export declare const TermStyleSchema: GenMessage<TermStyle>;

/**
 * @generated from message figterm.DiagnosticsRequest
 */
export declare type DiagnosticsRequest = Message<"figterm.DiagnosticsRequest"> & {
};

/**
 * Describes the message figterm.DiagnosticsRequest.
 * Use `create(DiagnosticsRequestSchema)` to create a new message.
 */
export declare const DiagnosticsRequestSchema: GenMessage<DiagnosticsRequest>;

/**
 * @generated from message figterm.DiagnosticsResponse
 */
export declare type DiagnosticsResponse = Message<"figterm.DiagnosticsResponse"> & {
  /**
   * Current shell context of the figterm instance
   *
   * @generated from field: optional fig_common.ShellContext shell_context = 1;
   */
  shellContext?: ShellContext;

  /**
   * Current suggestion style for fish
   *
   * @generated from field: optional figterm.TermStyle fish_suggestion_style = 2;
   */
  fishSuggestionStyle?: TermStyle;

  /**
   * Current suggestion style for zsh autosuggestion
   *
   * @generated from field: optional figterm.TermStyle zsh_autosuggestion_style = 3;
   */
  zshAutosuggestionStyle?: TermStyle;

  /**
   * The current edit buffer
   *
   * @generated from field: optional string edit_buffer = 4;
   */
  editBuffer?: string;

  /**
   * The current cursor cursor position
   *
   * @generated from field: optional uint32 cursor_position = 5;
   */
  cursorPosition?: number;
};

/**
 * Describes the message figterm.DiagnosticsResponse.
 * Use `create(DiagnosticsResponseSchema)` to create a new message.
 */
export declare const DiagnosticsResponseSchema: GenMessage<DiagnosticsResponse>;

/**
 * @generated from message figterm.InsertOnNewCmdRequest
 */
export declare type InsertOnNewCmdRequest = Message<"figterm.InsertOnNewCmdRequest"> & {
  /**
   * text to insert on new command
   *
   * @generated from field: string text = 1;
   */
  text: string;

  /**
   * if to execute the command immediately
   *
   * @generated from field: bool execute = 2;
   */
  execute: boolean;

  /**
   * if to bracket the text
   *
   * @generated from field: bool bracketed = 3;
   */
  bracketed: boolean;
};

/**
 * Describes the message figterm.InsertOnNewCmdRequest.
 * Use `create(InsertOnNewCmdRequestSchema)` to create a new message.
 */
export declare const InsertOnNewCmdRequestSchema: GenMessage<InsertOnNewCmdRequest>;

/**
 * Command to update values in the shell context
 *
 * Each field needs an associated bool that indicates if it should be
 * updated since we want the ability to do partial updates (not all fields)
 * and there is no way to do optional optional fields in proto3
 *
 * @generated from message figterm.UpdateShellContextRequest
 */
export declare type UpdateShellContextRequest = Message<"figterm.UpdateShellContextRequest"> & {
  /**
   * @generated from field: bool update_environment_variables = 1;
   */
  updateEnvironmentVariables: boolean;

  /**
   * @generated from field: repeated fig_common.EnvironmentVariable environment_variables = 2;
   */
  environmentVariables: EnvironmentVariable[];

  /**
   * @generated from field: bool update_alias = 3;
   */
  updateAlias: boolean;

  /**
   * @generated from field: optional string alias = 4;
   */
  alias?: string;
};

/**
 * Describes the message figterm.UpdateShellContextRequest.
 * Use `create(UpdateShellContextRequestSchema)` to create a new message.
 */
export declare const UpdateShellContextRequestSchema: GenMessage<UpdateShellContextRequest>;

/**
 * Command to notify figterm session that an SSH session has started in the terminal
 *
 * @generated from message figterm.NotifySSHSessionStartedRequest
 */
export declare type NotifySSHSessionStartedRequest = Message<"figterm.NotifySSHSessionStartedRequest"> & {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid: string;

  /**
   * @generated from field: string remote_host = 2;
   */
  remoteHost: string;
};

/**
 * Describes the message figterm.NotifySSHSessionStartedRequest.
 * Use `create(NotifySSHSessionStartedRequestSchema)` to create a new message.
 */
export declare const NotifySSHSessionStartedRequestSchema: GenMessage<NotifySSHSessionStartedRequest>;

/**
 * @generated from message figterm.InlineShellCompletionRequest
 */
export declare type InlineShellCompletionRequest = Message<"figterm.InlineShellCompletionRequest"> & {
  /**
   * The text to complete
   *
   * @generated from field: string buffer = 1;
   */
  buffer: string;
};

/**
 * Describes the message figterm.InlineShellCompletionRequest.
 * Use `create(InlineShellCompletionRequestSchema)` to create a new message.
 */
export declare const InlineShellCompletionRequestSchema: GenMessage<InlineShellCompletionRequest>;

/**
 * @generated from message figterm.InlineShellCompletionResponse
 */
export declare type InlineShellCompletionResponse = Message<"figterm.InlineShellCompletionResponse"> & {
  /**
   * The text to insert
   *
   * @generated from field: optional string insert_text = 1;
   */
  insertText?: string;
};

/**
 * Describes the message figterm.InlineShellCompletionResponse.
 * Use `create(InlineShellCompletionResponseSchema)` to create a new message.
 */
export declare const InlineShellCompletionResponseSchema: GenMessage<InlineShellCompletionResponse>;

/**
 * @generated from message figterm.InlineShellCompletionAcceptRequest
 */
export declare type InlineShellCompletionAcceptRequest = Message<"figterm.InlineShellCompletionAcceptRequest"> & {
  /**
   * @generated from field: string buffer = 1;
   */
  buffer: string;

  /**
   * @generated from field: string suggestion = 2;
   */
  suggestion: string;
};

/**
 * Describes the message figterm.InlineShellCompletionAcceptRequest.
 * Use `create(InlineShellCompletionAcceptRequestSchema)` to create a new message.
 */
export declare const InlineShellCompletionAcceptRequestSchema: GenMessage<InlineShellCompletionAcceptRequest>;

/**
 * @generated from message figterm.InlineShellCompletionSetEnabledRequest
 */
export declare type InlineShellCompletionSetEnabledRequest = Message<"figterm.InlineShellCompletionSetEnabledRequest"> & {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

/**
 * Describes the message figterm.InlineShellCompletionSetEnabledRequest.
 * Use `create(InlineShellCompletionSetEnabledRequestSchema)` to create a new message.
 */
export declare const InlineShellCompletionSetEnabledRequestSchema: GenMessage<InlineShellCompletionSetEnabledRequest>;

/**
 * @generated from message figterm.TelemetryRequest
 */
export declare type TelemetryRequest = Message<"figterm.TelemetryRequest"> & {
  /**
   * A json blob containing the event
   *
   * @generated from field: string event_blob = 1;
   */
  eventBlob: string;
};

/**
 * Describes the message figterm.TelemetryRequest.
 * Use `create(TelemetryRequestSchema)` to create a new message.
 */
export declare const TelemetryRequestSchema: GenMessage<TelemetryRequest>;

